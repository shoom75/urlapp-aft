{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I+DOY,EMGA,EAOA,EAQA,EAaA,EhClCZ,ECHA,EAiCA,EyB3BY,EGPR,EGUQ,EAOA,EAQA,EASA,EAIA,E,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,EpEtCZ,EAAA,OAAA,CAAkB,MAAA,CAAmB,SAAU,IAAI,CAAC,IAAM,EAAc,S,G,E,Q,S,C,C,C,ECAxE,IAAI,EAAgB,WACnB,GAAI,AAAgB,UAAhB,OAAO,MAAqB,KAAM,OAAO,KAC7C,GAAI,AAAkB,UAAlB,OAAO,QAAuB,OAAQ,OAAO,MACjD,OAAM,AAAI,MAAM,kCACjB,CAEA,CAAA,EAAA,OAAA,CAAiB,WAChB,GAAI,IAAI,CAAE,OAAO,IAAI,CAKrB,GAAI,AAAsB,UAAtB,OAAO,YAA2B,WAAY,OAAO,WAKzD,GAAI,CACH,OAAO,cAAc,CAAC,OAAO,SAAS,CAAE,aAAc,CACrD,IAAK,WAAc,OAAO,IAAI,AAAE,EAChC,aAAc,CAAA,CACf,EACD,CAAE,MAAO,EAAO,CAGf,OAAO,GACR,CACA,GAAI,CAEH,GAAI,CAAC,WAAY,OAAO,IACxB,OAAO,UACR,QAAU,CACT,OAAO,OAAO,SAAS,CAAC,UAAU,AACnC,CACD,G,G,E,Q,S,C,C,C,EClCA,EAAA,OAAA,CAAiB,KAAK,KAAK,CAAC,ojC,GSErB,MAAM,EAAkB,CAAE,gBAAiB,oBAAwB,EIY7D,EAAY,IAAM,AAAkB,aAAlB,OAAO,OSTzB,EAAkB,CAC7B,cAAe,iBACf,YAAa,GACb,eAAgB,CACjB,EACY,EAAc,sBACd,EAAiB,CAC5B,KAAM,KACN,SAAU,MACV,OAAQ,GACR,KAAM,IACN,SAAU,KACX,E,I,E,S,C,C,C,C,C,C,C,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AY,EACrE,EAAC,CEtGM,MAAM,GAAe,AAAC,IAC3B,IAAI,EAQJ,OANE,EADE,IAEO,AAAiB,aAAjB,OAAO,MACP,CAAO,GAAG,S,E,E,E,S,EAAQ,KAAA,E,EAAA,KAAA,E,EAAA,KAAA,E,EAAA,YAAC,OAAA,KAAM,AAAC,CAAA,MAAM,EAAA,QAAA,EAAuB,KAAK,IAAI,EAAK,E,G,C,G,C,E,O,C,E,S,C,C,C,E,S,E,C,E,G,C,E,E,I,C,G,C,M,E,C,E,E,C,C,S,E,C,E,G,C,E,E,K,C,G,C,M,E,C,E,E,C,C,S,E,C,M,C,C,E,I,C,E,E,K,E,A,C,C,E,E,K,Y,E,E,I,E,S,C,E,E,E,E,E,I,C,E,E,C,E,A,C,E,E,K,C,E,G,E,C,E,I,G,IAErE,OAEJ,CAAC,GAAG,IAAS,KAAU,EAChC,E,I,G,S,C,C,C,C,C,C,C,E,O,G,C,G,C,E,O,C,E,S,C,C,C,E,S,E,C,E,G,C,E,E,I,C,G,C,M,E,C,E,E,C,C,S,E,C,E,G,C,E,E,K,C,G,C,M,E,C,E,E,C,C,S,E,C,M,C,C,E,I,C,E,E,K,E,A,C,C,E,E,K,Y,E,E,I,E,S,C,E,E,E,E,E,I,C,E,E,C,E,A,C,E,E,K,C,E,G,E,C,E,I,G,E,CRPM,OAAO,GAKX,YAAY,CAAW,CAAE,EAAqC,CAAA,CAAE,CAAE,CAAa,CAA/E,CACE,IAAI,CAAC,GAAG,CAAG,EACX,IAAI,CAAC,OAAO,CAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,EAAQ,IAAoB,GACxC,IAAI,CAAC,KAAK,CAAG,AAAA,GAAa,EAC5B,CAKM,aAAA,C,O,G,I,C,K,E,K,E,YACJ,GAAI,CAEF,MAAO,CAAE,KADI,MAAM,AAAA,GAAI,IAAI,CAAC,KAAK,CAAE,CAAA,EAAG,IAAI,CAAC,GAAG,CAAA,OAAA,CAAS,CAAE,CAAE,QAAS,IAAI,CAAC,OAAO,AAAA,GACjE,MAAO,IAAI,CAC3B,CAAC,MAAO,EAAO,CACd,MAAO,CAAE,KAAM,KAAM,MAAA,CAAK,CAC3B,CACH,EAAC,CAOK,UAAU,CAAU,CAApB,C,O,G,I,C,K,E,K,E,YACJ,GAAI,CAEF,MAAO,CAAE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K,C,G,C,M,E,C,E,E,C,C,S,E,C,M,C,C,E,I,C,E,E,K,E,A,C,C,E,E,K,Y,E,E,I,E,S,C,E,E,E,E,E,I,C,E,E,C,E,A,C,E,E,K,C,E,G,E,C,E,I,G,EAAC,CACF,C,I,G,S,C,C,C,C,C,C,C,E,O,G,C,G,C,E,O,C,E,S,C,C,C,E,S,E,C,E,G,C,E,E,I,C,G,C,M,E,C,E,E,C,C,S,E,C,E,G,C,E,E,K,C,G,C,M,E,C,E,E,C,C,S,E,C,M,C,C,E,I,C,E,E,K,E,A,C,C,E,E,K,Y,E,E,I,E,S,C,E,E,E,E,E,I,C,E,E,C,E,A,C,E,E,K,C,E,G,E,C,E,I,G,E,ErF9DD,MAAM,GAAkB,CACtB,OAAQ,SACR,iBAAkB,CAAA,EAClB,eAAgB,CAAA,EAChB,mBAAoB,CAAA,EACpB,SAAU,CAAA,EACV,QAAS,CACV,EJbY,GEeJ,IEKK,MAAA,EAmCZ,YACY,CAAmB,CACnB,CAAmB,CAC7B,CAA+B,CAHjC,CAKE,GAJU,IAAA,CAAA,WAAW,CAAX,EACA,IAAA,CAAA,WAAW,CAAX,EAGN,CAAC,EAAa,MAAM,AAAI,MAAM,4BAClC,GAAI,CAAC,EAAa,MAAM,AAAI,MAAM,4BAElC,IAAM,EMzDD,ANyDmC,EMzD/B,OAAO,CAAC,MAAO,IN0DlB,EAAQ,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,EAAQ,IAAoB,GAQ1C,GANA,IAAI,CAAC,OAAO,CAAG,CAAA,EAAG,EAAY,QAAA,CAAU,CACxC,IAAI,CAAC,WAAW,CAAG,CAAA,EAAG,EAAY,YAAA,CAAc,CAAC,OAAO,CAAC,OAAQ,MACjE,IAAI,CAAC,OAAO,CAAG,CAAA,EAAG,EAAY,QAAA,CAAU,CACxC,IAAI,CAAC,UAAU,CAAG,CAAA,EAAG,EAAY,WAAA,CAAa,CAE3B,EAAa,KAAK,CAAC,iCACtB,CACd,IAAM,EAAW,EAAa,KAAK,CAAC,IACpC,CAAA,IAAI,CAAC,YAAY,CAAG,CAAA,EAAG,CAAQ,CAAC,EAAE,CAAA,WAAA,EAAc,CAAQ,CAAC,EAAE,CAAA,CAAA,EAAI,CAAQ,CAAC,EAAE,CAAA,CAAE,AAC7E,MACC,IAAI,CAA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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/runtime-5fe8363356929416.js","node_modules/es5-ext/global.js","node_modules/websocket/package.json","src/main.js","src/utils/dbOperations.js","src/utils/supabaseClient.js","node_modules/@supabase/supabase-js/dist/module/index.js","node_modules/@supabase/supabase-js/src/index.ts","node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js","node_modules/@supabase/supabase-js/src/SupabaseClient.ts","node_modules/@supabase/supabase-js/dist/module/lib/constants.js","node_modules/@supabase/supabase-js/src/lib/constants.ts","node_modules/@supabase/supabase-js/dist/module/lib/version.js","node_modules/@supabase/supabase-js/src/lib/version.ts","node_modules/@supabase/supabase-js/dist/module/lib/helpers.js","node_modules/@supabase/supabase-js/src/lib/helpers.ts","node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js","node_modules/@supabase/supabase-js/src/lib/SupabaseAuthClient.ts","node_modules/@supabase/gotrue-js/src/index.ts","node_modules/@supabase/gotrue-js/dist/module/GoTrueApi.js","node_modules/@supabase/gotrue-js/src/GoTrueApi.ts","node_modules/@supabase/gotrue-js/dist/module/lib/fetch.js","node_modules/@supabase/gotrue-js/src/lib/fetch.ts","node_modules/@supabase/gotrue-js/dist/module/lib/constants.js","node_modules/@supabase/gotrue-js/src/lib/constants.ts","node_modules/@supabase/gotrue-js/dist/module/lib/version.js","node_modules/@supabase/gotrue-js/src/lib/version.ts","node_modules/@supabase/gotrue-js/dist/module/lib/cookies.js","node_modules/@supabase/gotrue-js/src/lib/cookies.ts","node_modules/@supabase/gotrue-js/dist/module/lib/helpers.js","node_modules/@supabase/gotrue-js/src/lib/helpers.ts","node_modules/@supabase/gotrue-js/dist/module/GoTrueClient.js","node_modules/@supabase/gotrue-js/src/GoTrueClient.ts","node_modules/@supabase/gotrue-js/dist/module/lib/polyfills.js","node_modules/@supabase/gotrue-js/src/lib/polyfills.ts","node_modules/buffer/index.js","node_modules/base64-js/index.js","node_modules/ieee754/index.js","node_modules/@supabase/gotrue-js/src/lib/types.ts","node_modules/@supabase/supabase-js/dist/module/lib/SupabaseQueryBuilder.js","node_modules/@supabase/supabase-js/src/lib/SupabaseQueryBuilder.ts","node_modules/@supabase/postgrest-js/src/index.ts","node_modules/@supabase/postgrest-js/dist/module/PostgrestClient.js","node_modules/@supabase/postgrest-js/src/PostgrestClient.ts","node_modules/@supabase/postgrest-js/dist/module/lib/PostgrestQueryBuilder.js","node_modules/@supabase/postgrest-js/src/lib/PostgrestQueryBuilder.ts","node_modules/@supabase/postgrest-js/dist/module/lib/types.js","node_modules/@supabase/postgrest-js/src/lib/types.ts","node_modules/@supabase/postgrest-js/dist/module/lib/PostgrestFilterBuilder.js","node_modules/@supabase/postgrest-js/src/lib/PostgrestFilterBuilder.ts","node_modules/@supabase/postgrest-js/dist/module/lib/PostgrestTransformBuilder.js","node_modules/@supabase/postgrest-js/src/lib/PostgrestTransformBuilder.ts","node_modules/@supabase/postgrest-js/dist/module/lib/PostgrestRpcBuilder.js","node_modules/@supabase/postgrest-js/src/lib/PostgrestRpcBuilder.ts","node_modules/@supabase/postgrest-js/dist/module/lib/constants.js","node_modules/@supabase/postgrest-js/src/lib/constants.ts","node_modules/@supabase/postgrest-js/dist/module/lib/version.js","node_modules/@supabase/postgrest-js/src/lib/version.ts","node_modules/@supabase/supabase-js/dist/module/lib/SupabaseRealtimeClient.js","node_modules/@supabase/supabase-js/src/lib/SupabaseRealtimeClient.ts","node_modules/@supabase/realtime-js/src/index.ts","node_modules/@supabase/realtime-js/dist/module/lib/transformers.js","node_modules/@supabase/realtime-js/src/lib/transformers.ts","node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js","node_modules/@supabase/realtime-js/src/RealtimeClient.ts","node_modules/websocket/lib/browser.js","node_modules/websocket/lib/version.js","node_modules/@supabase/realtime-js/dist/module/lib/constants.js","node_modules/@supabase/realtime-js/src/lib/constants.ts","node_modules/@supabase/realtime-js/dist/module/lib/version.js","node_modules/@supabase/realtime-js/src/lib/version.ts","node_modules/@supabase/realtime-js/dist/module/lib/timer.js","node_modules/@supabase/realtime-js/src/lib/timer.ts","node_modules/@supabase/realtime-js/dist/module/lib/serializer.js","node_modules/@supabase/realtime-js/src/lib/serializer.ts","node_modules/@supabase/realtime-js/dist/module/RealtimeSubscription.js","node_modules/@supabase/realtime-js/src/RealtimeSubscription.ts","node_modules/@supabase/realtime-js/dist/module/lib/push.js","node_modules/@supabase/realtime-js/src/lib/push.ts","node_modules/@supabase/storage-js/dist/module/StorageClient.js","node_modules/@supabase/storage-js/src/StorageClient.ts","node_modules/@supabase/storage-js/dist/module/lib/StorageBucketApi.js","node_modules/@supabase/storage-js/src/lib/StorageBucketApi.ts","node_modules/@supabase/storage-js/dist/module/lib/constants.js","node_modules/@supabase/storage-js/src/lib/constants.ts","node_modules/@supabase/storage-js/dist/module/lib/version.js","node_modules/@supabase/storage-js/src/lib/version.ts","node_modules/@supabase/storage-js/dist/module/lib/fetch.js","node_modules/@supabase/storage-js/src/lib/fetch.ts","node_modules/@supabase/storage-js/dist/module/lib/helpers.js","node_modules/@supabase/storage-js/src/lib/helpers.ts","node_modules/@supabase/storage-js/dist/module/lib/StorageFileApi.js","node_modules/@supabase/storage-js/src/lib/StorageFileApi.ts","node_modules/@supabase/functions-js/dist/module/index.js","node_modules/@supabase/functions-js/src/index.ts","node_modules/@supabase/functions-js/dist/module/helper.js","node_modules/@supabase/functions-js/src/helper.ts","src/utils/fetchPreview.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire893f\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire893f\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"6s4wM\", function(module, exports) {\nmodule.exports = import(\"Rqc19\").then(()=>parcelRequire('R5nvG'));\n\n});\n\nparcelRegister(\"1EZeK\", function(module, exports) {\nvar $13590742ec5ba364$var$naiveFallback = function() {\n    if (typeof self === \"object\" && self) return self;\n    if (typeof window === \"object\" && window) return window;\n    throw new Error(\"Unable to resolve global `this`\");\n};\nmodule.exports = function() {\n    if (this) return this;\n    // Unexpected strict mode (may happen if e.g. bundled into ESM module)\n    // Fallback to standard globalThis if available\n    if (typeof globalThis === \"object\" && globalThis) return globalThis;\n    // Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n    // In all ES5+ engines global object inherits from Object.prototype\n    // (if you approached one that doesn't please report)\n    try {\n        Object.defineProperty(Object.prototype, \"__global__\", {\n            get: function() {\n                return this;\n            },\n            configurable: true\n        });\n    } catch (error) {\n        // Unfortunate case of updates to Object.prototype being restricted\n        // via preventExtensions, seal or freeze\n        return $13590742ec5ba364$var$naiveFallback();\n    }\n    try {\n        // Safari case (window.__global__ works, but __global__ does not)\n        if (!__global__) return $13590742ec5ba364$var$naiveFallback();\n        return __global__;\n    } finally{\n        delete Object.prototype.__global__;\n    }\n}();\n\n});\n\nparcelRegister(\"ln8A6\", function(module, exports) {\nmodule.exports = JSON.parse('{\"name\":\"websocket\",\"description\":\"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\",\"keywords\":[\"websocket\",\"websockets\",\"socket\",\"networking\",\"comet\",\"push\",\"RFC-6455\",\"realtime\",\"server\",\"client\"],\"author\":\"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)\",\"contributors\":[\"I\\xf1aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)\"],\"version\":\"1.0.35\",\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/theturtle32/WebSocket-Node.git\"},\"homepage\":\"https://github.com/theturtle32/WebSocket-Node\",\"engines\":{\"node\":\">=4.0.0\"},\"dependencies\":{\"bufferutil\":\"^4.0.1\",\"debug\":\"^2.2.0\",\"es5-ext\":\"^0.10.63\",\"typedarray-to-buffer\":\"^3.1.5\",\"utf-8-validate\":\"^5.0.2\",\"yaeti\":\"^0.0.6\"},\"devDependencies\":{\"buffer-equal\":\"^1.0.0\",\"gulp\":\"^4.0.2\",\"gulp-jshint\":\"^2.0.4\",\"jshint-stylish\":\"^2.2.1\",\"jshint\":\"^2.0.0\",\"tape\":\"^4.9.1\"},\"config\":{\"verbose\":false},\"scripts\":{\"test\":\"tape test/unit/*.js\",\"gulp\":\"gulp\"},\"main\":\"index\",\"directories\":{\"lib\":\"./lib\"},\"browser\":\"lib/browser.js\",\"license\":\"Apache-2.0\"}');\n\n});\n\n// constants.ts\nconst $7ab8bdf3e5c9b693$export$83d89fbfd8236492 = '1.35.6';\n\n\nconst $c0fdce55fc03ad18$export$88a84136db6a4b64 = {\n    'X-Client-Info': `supabase-js/${(0, $7ab8bdf3e5c9b693$export$83d89fbfd8236492)}`\n};\nconst $c0fdce55fc03ad18$export$86880b4b2e1a2384 = 'supabase.auth.token';\n\n\n// helpers.ts\nfunction $0c30a5a89f4b6341$export$31b40729666a4ae0() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\nfunction $0c30a5a89f4b6341$export$d95b4586d238a081(url) {\n    return url.replace(/\\/$/, '');\n}\nconst $0c30a5a89f4b6341$export$4e09c449d6c407f7 = ()=>typeof window !== 'undefined';\n\n\n// generated by genversion\nconst $6d15992d0e95be63$export$83d89fbfd8236492 = '1.24.0';\n\n\nconst $bc9c0ede130f94c1$export$7fedf552187f0c3d = 'http://localhost:9999';\nconst $bc9c0ede130f94c1$export$2f9161bad044dacb = '';\nconst $bc9c0ede130f94c1$export$88a84136db6a4b64 = {\n    'X-Client-Info': `gotrue-js/${(0, $6d15992d0e95be63$export$83d89fbfd8236492)}`\n};\nconst $bc9c0ede130f94c1$export$7d4b3a66850dd9bd = 10; // in seconds\nconst $bc9c0ede130f94c1$export$5615c708618ee858 = {\n    ERROR_MESSAGE: 'Request Failed',\n    MAX_RETRIES: 10,\n    RETRY_INTERVAL: 2\n};\nconst $bc9c0ede130f94c1$export$86880b4b2e1a2384 = 'supabase.auth.token';\nconst $bc9c0ede130f94c1$export$5d04dceb9d38c3f8 = {\n    name: 'sb',\n    lifetime: 28800,\n    domain: '',\n    path: '/',\n    sameSite: 'lax'\n};\n\n\nvar $4bf44b5e4af6a5a5$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst $4bf44b5e4af6a5a5$var$_getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst $4bf44b5e4af6a5a5$var$handleError = (error, reject)=>{\n    if (!(error === null || error === void 0 ? void 0 : error.status)) return reject({\n        message: (0, $bc9c0ede130f94c1$export$5615c708618ee858).ERROR_MESSAGE\n    });\n    if (typeof error.json !== 'function') return reject(error);\n    error.json().then((err)=>{\n        return reject({\n            message: $4bf44b5e4af6a5a5$var$_getErrorMessage(err),\n            status: (error === null || error === void 0 ? void 0 : error.status) || 500\n        });\n    });\n};\nconst $4bf44b5e4af6a5a5$var$_getRequestParams = (method, options, body)=>{\n    const params = {\n        method: method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === 'GET') return params;\n    params.headers = Object.assign({\n        'Content-Type': 'application/json;charset=UTF-8'\n    }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return params;\n};\nfunction $4bf44b5e4af6a5a5$var$_handleRequest(fetcher, method, url, options, body) {\n    return $4bf44b5e4af6a5a5$var$__awaiter(this, void 0, void 0, function*() {\n        return new Promise((resolve, reject)=>{\n            fetcher(url, $4bf44b5e4af6a5a5$var$_getRequestParams(method, options, body)).then((result)=>{\n                if (!result.ok) throw result;\n                if (options === null || options === void 0 ? void 0 : options.noResolveJson) return resolve;\n                return result.json();\n            }).then((data)=>resolve(data)).catch((error)=>$4bf44b5e4af6a5a5$var$handleError(error, reject));\n        });\n    });\n}\nfunction $4bf44b5e4af6a5a5$export$3988ae62b71be9a3(fetcher, url, options) {\n    return $4bf44b5e4af6a5a5$var$__awaiter(this, void 0, void 0, function*() {\n        return $4bf44b5e4af6a5a5$var$_handleRequest(fetcher, 'GET', url, options);\n    });\n}\nfunction $4bf44b5e4af6a5a5$export$299ba2dee77727e9(fetcher, url, body, options) {\n    return $4bf44b5e4af6a5a5$var$__awaiter(this, void 0, void 0, function*() {\n        return $4bf44b5e4af6a5a5$var$_handleRequest(fetcher, 'POST', url, options, body);\n    });\n}\nfunction $4bf44b5e4af6a5a5$export$327f7b26ebf455db(fetcher, url, body, options) {\n    return $4bf44b5e4af6a5a5$var$__awaiter(this, void 0, void 0, function*() {\n        return $4bf44b5e4af6a5a5$var$_handleRequest(fetcher, 'PUT', url, options, body);\n    });\n}\nfunction $4bf44b5e4af6a5a5$export$cd7f480d6b8286c3(fetcher, url, body, options) {\n    return $4bf44b5e4af6a5a5$var$__awaiter(this, void 0, void 0, function*() {\n        return $4bf44b5e4af6a5a5$var$_handleRequest(fetcher, 'DELETE', url, options, body);\n    });\n}\n\n\n\n/**\n * Serialize data into a cookie header.\n */ function $f258538a2399bef1$var$serialize(name, val, options) {\n    const opt = options || {};\n    const enc = encodeURIComponent;\n    /* eslint-disable-next-line no-control-regex */ const fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n    if (typeof enc !== 'function') throw new TypeError('option encode is invalid');\n    if (!fieldContentRegExp.test(name)) throw new TypeError('argument name is invalid');\n    const value = enc(val);\n    if (value && !fieldContentRegExp.test(value)) throw new TypeError('argument val is invalid');\n    let str = name + '=' + value;\n    if (null != opt.maxAge) {\n        const maxAge = opt.maxAge - 0;\n        if (isNaN(maxAge) || !isFinite(maxAge)) throw new TypeError('option maxAge is invalid');\n        str += '; Max-Age=' + Math.floor(maxAge);\n    }\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain)) throw new TypeError('option domain is invalid');\n        str += '; Domain=' + opt.domain;\n    }\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path)) throw new TypeError('option path is invalid');\n        str += '; Path=' + opt.path;\n    }\n    if (opt.expires) {\n        if (typeof opt.expires.toUTCString !== 'function') throw new TypeError('option expires is invalid');\n        str += '; Expires=' + opt.expires.toUTCString();\n    }\n    if (opt.httpOnly) str += '; HttpOnly';\n    if (opt.secure) str += '; Secure';\n    if (opt.sameSite) {\n        const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n        switch(sameSite){\n            case 'lax':\n                str += '; SameSite=Lax';\n                break;\n            case 'strict':\n                str += '; SameSite=Strict';\n                break;\n            case 'none':\n                str += '; SameSite=None';\n                break;\n            default:\n                throw new TypeError('option sameSite is invalid');\n        }\n    }\n    return str;\n}\n/**\n * Based on the environment and the request we know if a secure cookie can be set.\n */ function $f258538a2399bef1$var$isSecureEnvironment(req) {\n    if (!req || !req.headers || !req.headers.host) throw new Error('The \"host\" request header is not available');\n    const host = req.headers.host.indexOf(':') > -1 && req.headers.host.split(':')[0] || req.headers.host;\n    if ([\n        'localhost',\n        '127.0.0.1'\n    ].indexOf(host) > -1 || host.endsWith('.local')) return false;\n    return true;\n}\n/**\n * Serialize a cookie to a string.\n */ function $f258538a2399bef1$var$serializeCookie(cookie, secure) {\n    var _a, _b, _c;\n    return $f258538a2399bef1$var$serialize(cookie.name, cookie.value, {\n        maxAge: cookie.maxAge,\n        expires: new Date(Date.now() + cookie.maxAge * 1000),\n        httpOnly: true,\n        secure: secure,\n        path: (_a = cookie.path) !== null && _a !== void 0 ? _a : '/',\n        domain: (_b = cookie.domain) !== null && _b !== void 0 ? _b : '',\n        sameSite: (_c = cookie.sameSite) !== null && _c !== void 0 ? _c : 'lax'\n    });\n}\nfunction $f258538a2399bef1$export$cabcf1eb6b547ccb(req, res, cookies) {\n    const strCookies = cookies.map((c)=>$f258538a2399bef1$var$serializeCookie(c, $f258538a2399bef1$var$isSecureEnvironment(req)));\n    const previousCookies = res.getHeader('Set-Cookie');\n    if (previousCookies) {\n        if (previousCookies instanceof Array) Array.prototype.push.apply(strCookies, previousCookies);\n        else if (typeof previousCookies === 'string') strCookies.push(previousCookies);\n    }\n    return strCookies;\n}\nfunction $f258538a2399bef1$export$31cdeeae171a741d(req, res, cookies) {\n    res.setHeader('Set-Cookie', $f258538a2399bef1$export$cabcf1eb6b547ccb(req, res, cookies));\n}\nfunction $f258538a2399bef1$export$110700823644f4a6(req, res, cookie) {\n    $f258538a2399bef1$export$31cdeeae171a741d(req, res, [\n        cookie\n    ]);\n}\nfunction $f258538a2399bef1$export$b43e45590305ffaa(req, res, name) {\n    $f258538a2399bef1$export$110700823644f4a6(req, res, {\n        name: name,\n        value: '',\n        maxAge: -1\n    });\n}\n\n\nvar $cca04edb6116d720$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction $cca04edb6116d720$export$e02d0a488392f690(expiresIn) {\n    const timeNow = Math.round(Date.now() / 1000);\n    return timeNow + expiresIn;\n}\nfunction $cca04edb6116d720$export$31b40729666a4ae0() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\nconst $cca04edb6116d720$export$4e09c449d6c407f7 = ()=>typeof window !== 'undefined';\nfunction $cca04edb6116d720$export$7a5418d73bdac342(name, url) {\n    var _a;\n    if (!url) url = ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.href) || '';\n    // eslint-disable-next-line no-useless-escape\n    name = name.replace(/[\\[\\]]/g, '\\\\$&');\n    const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'), results = regex.exec(url);\n    if (!results) return null;\n    if (!results[2]) return '';\n    return decodeURIComponent(results[2].replace(/\\+/g, ' '));\n}\n\nconst $cca04edb6116d720$export$98d92b1aa79f8cc7 = (customFetch)=>{\n    let _fetch;\n    if (customFetch) _fetch = customFetch;\n    else if (typeof fetch === 'undefined') _fetch = (...args)=>$cca04edb6116d720$var$__awaiter(void 0, void 0, void 0, function*() {\n            return yield (yield (parcelRequire(\"6s4wM\"))).fetch(...args);\n        });\n    else _fetch = fetch;\n    return (...args)=>_fetch(...args);\n};\nconst $cca04edb6116d720$export$e82c36d29078a87f = (storage, key, data)=>$cca04edb6116d720$var$__awaiter(void 0, void 0, void 0, function*() {\n        $cca04edb6116d720$export$4e09c449d6c407f7() && (yield storage === null || storage === void 0 ? void 0 : storage.setItem(key, JSON.stringify(data)));\n    });\nconst $cca04edb6116d720$export$ba6fcb7c333d32c0 = (storage, key)=>$cca04edb6116d720$var$__awaiter(void 0, void 0, void 0, function*() {\n        const value = $cca04edb6116d720$export$4e09c449d6c407f7() && (yield storage === null || storage === void 0 ? void 0 : storage.getItem(key));\n        if (!value) return null;\n        try {\n            return JSON.parse(value);\n        } catch (_a) {\n            return value;\n        }\n    });\nconst $cca04edb6116d720$export$97dd154d855aafe0 = (storage, key)=>{\n    const value = $cca04edb6116d720$export$4e09c449d6c407f7() && (storage === null || storage === void 0 ? void 0 : storage.getItem(key));\n    if (!value || typeof value !== 'string') return null;\n    try {\n        return JSON.parse(value);\n    } catch (_a) {\n        return value;\n    }\n};\nconst $cca04edb6116d720$export$d35c645d585317ec = (storage, key)=>$cca04edb6116d720$var$__awaiter(void 0, void 0, void 0, function*() {\n        $cca04edb6116d720$export$4e09c449d6c407f7() && (yield storage === null || storage === void 0 ? void 0 : storage.removeItem(key));\n    });\n\n\nvar $cfa76d5c64f3686e$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass $cfa76d5c64f3686e$export$2e2bcd8739ae039 {\n    constructor({ url: url = '', headers: headers = {}, cookieOptions: cookieOptions, fetch: fetch }){\n        this.url = url;\n        this.headers = headers;\n        this.cookieOptions = Object.assign(Object.assign({}, (0, $bc9c0ede130f94c1$export$5d04dceb9d38c3f8)), cookieOptions);\n        this.fetch = (0, $cca04edb6116d720$export$98d92b1aa79f8cc7)(fetch);\n    }\n    /**\n     * Create a temporary object with all configured headers and\n     * adds the Authorization token to be used on request methods\n     * @param jwt A valid, logged-in JWT.\n     */ _createRequestHeaders(jwt) {\n        const headers = Object.assign({}, this.headers);\n        headers['Authorization'] = `Bearer ${jwt}`;\n        return headers;\n    }\n    cookieName() {\n        var _a;\n        return (_a = this.cookieOptions.name) !== null && _a !== void 0 ? _a : '';\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */ getUrlForProvider(provider, options) {\n        const urlParams = [\n            `provider=${encodeURIComponent(provider)}`\n        ];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n        if (options === null || options === void 0 ? void 0 : options.scopes) urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n        if (options === null || options === void 0 ? void 0 : options.queryParams) {\n            const query = new URLSearchParams(options.queryParams);\n            urlParams.push(`${query}`);\n        }\n        return `${this.url}/authorize?${urlParams.join('&')}`;\n    }\n    /**\n     * Creates a new user using their email address.\n     * @param email The email address of the user.\n     * @param password The password of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param data Optional user metadata.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */ signUpWithEmail(email, password, options = {}) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                const data = yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/signup${queryString}`, {\n                    email: email,\n                    password: password,\n                    data: options.data,\n                    gotrue_meta_security: {\n                        captcha_token: options.captchaToken\n                    }\n                }, {\n                    headers: headers\n                });\n                const session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = (0, $cca04edb6116d720$export$e02d0a488392f690)(data.expires_in);\n                return {\n                    data: session,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Logs in an existing user using their email address.\n     * @param email The email address of the user.\n     * @param password The password of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */ signInWithEmail(email, password, options = {}) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '?grant_type=password';\n                if (options.redirectTo) queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo);\n                const data = yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/token${queryString}`, {\n                    email: email,\n                    password: password,\n                    gotrue_meta_security: {\n                        captcha_token: options.captchaToken\n                    }\n                }, {\n                    headers: headers\n                });\n                const session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = (0, $cca04edb6116d720$export$e02d0a488392f690)(data.expires_in);\n                return {\n                    data: session,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Signs up a new user using their phone number and a password.\n     * @param phone The phone number of the user.\n     * @param password The password of the user.\n     * @param data Optional user metadata.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */ signUpWithPhone(phone, password, options = {}) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const data = yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/signup`, {\n                    phone: phone,\n                    password: password,\n                    data: options.data,\n                    gotrue_meta_security: {\n                        captcha_token: options.captchaToken\n                    }\n                }, {\n                    headers: headers\n                });\n                const session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = (0, $cca04edb6116d720$export$e02d0a488392f690)(data.expires_in);\n                return {\n                    data: session,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Logs in an existing user using their phone number and password.\n     * @param phone The phone number of the user.\n     * @param password The password of the user.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */ signInWithPhone(phone, password, options = {}) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const queryString = '?grant_type=password';\n                const data = yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/token${queryString}`, {\n                    phone: phone,\n                    password: password,\n                    gotrue_meta_security: {\n                        captcha_token: options.captchaToken\n                    }\n                }, {\n                    headers: headers\n                });\n                const session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = (0, $cca04edb6116d720$export$e02d0a488392f690)(data.expires_in);\n                return {\n                    data: session,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Logs in an OpenID Connect user using their id_token.\n     * @param id_token The IDToken of the user.\n     * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n     * @param provider The provider of the user.\n     * @param client_id The clientID of the user.\n     * @param issuer The issuer of the user.\n     */ signInWithOpenIDConnect({ id_token: id_token, nonce: nonce, client_id: client_id, issuer: issuer, provider: provider }) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const queryString = '?grant_type=id_token';\n                const data = yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/token${queryString}`, {\n                    id_token: id_token,\n                    nonce: nonce,\n                    client_id: client_id,\n                    issuer: issuer,\n                    provider: provider\n                }, {\n                    headers: headers\n                });\n                const session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = (0, $cca04edb6116d720$export$e02d0a488392f690)(data.expires_in);\n                return {\n                    data: session,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Sends a magic login link to an email address.\n     * @param email The email address of the user.\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */ sendMagicLinkEmail(email, options = {}) {\n        var _a;\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n                const data = yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/otp${queryString}`, {\n                    email: email,\n                    create_user: shouldCreateUser,\n                    gotrue_meta_security: {\n                        captcha_token: options.captchaToken\n                    }\n                }, {\n                    headers: headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n     * @param phone The user's phone number WITH international prefix\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */ sendMobileOTP(phone, options = {}) {\n        var _a;\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n                const headers = Object.assign({}, this.headers);\n                const data = yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/otp`, {\n                    phone: phone,\n                    create_user: shouldCreateUser,\n                    gotrue_meta_security: {\n                        captcha_token: options.captchaToken\n                    }\n                }, {\n                    headers: headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     */ signOut(jwt) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/logout`, {}, {\n                    headers: this._createRequestHeaders(jwt),\n                    noResolveJson: true\n                });\n                return {\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * @deprecated Use `verifyOTP` instead!\n     * @param phone The user's phone number WITH international prefix\n     * @param token token that user was sent to their mobile phone\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */ verifyMobileOTP(phone, token, options = {}) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const data = yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/verify`, {\n                    phone: phone,\n                    token: token,\n                    type: 'sms',\n                    redirect_to: options.redirectTo\n                }, {\n                    headers: headers\n                });\n                const session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = (0, $cca04edb6116d720$export$e02d0a488392f690)(data.expires_in);\n                return {\n                    data: session,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Send User supplied Email / Mobile OTP to be verified\n     * @param email The user's email address\n     * @param phone The user's phone number WITH international prefix\n     * @param token token that user was sent to their mobile phone\n     * @param type verification type that the otp is generated for\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */ verifyOTP({ email: email, phone: phone, token: token, type: type = 'sms' }, options = {}) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const data = yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/verify`, {\n                    email: email,\n                    phone: phone,\n                    token: token,\n                    type: type,\n                    redirect_to: options.redirectTo\n                }, {\n                    headers: headers\n                });\n                const session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = (0, $cca04edb6116d720$export$e02d0a488392f690)(data.expires_in);\n                return {\n                    data: session,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param data Optional user metadata\n     */ inviteUserByEmail(email, options = {}) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                const data = yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/invite${queryString}`, {\n                    email: email,\n                    data: options.data\n                }, {\n                    headers: headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Sends a reset request to an email address.\n     * @param email The email address of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */ resetPasswordForEmail(email, options = {}) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                const data = yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/recover${queryString}`, {\n                    email: email,\n                    gotrue_meta_security: {\n                        captcha_token: options.captchaToken\n                    }\n                }, {\n                    headers: headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */ refreshAccessToken(refreshToken) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/token?grant_type=refresh_token`, {\n                    refresh_token: refreshToken\n                }, {\n                    headers: this.headers\n                });\n                const session = Object.assign({}, data);\n                if (session.expires_in) session.expires_at = (0, $cca04edb6116d720$export$e02d0a488392f690)(data.expires_in);\n                return {\n                    data: session,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Set/delete the auth cookie based on the AuthChangeEvent.\n     * Works for Next.js & Express (requires cookie-parser middleware).\n     * @param req The request object.\n     * @param res The response object.\n     */ setAuthCookie(req, res) {\n        if (req.method !== 'POST') {\n            res.setHeader('Allow', 'POST');\n            res.status(405).end('Method Not Allowed');\n        }\n        const { event: event, session: session } = req.body;\n        if (!event) throw new Error('Auth event missing!');\n        if (event === 'SIGNED_IN') {\n            if (!session) throw new Error('Auth session missing!');\n            (0, $f258538a2399bef1$export$31cdeeae171a741d)(req, res, [\n                {\n                    key: 'access-token',\n                    value: session.access_token\n                },\n                {\n                    key: 'refresh-token',\n                    value: session.refresh_token\n                }\n            ].map((token)=>{\n                var _a;\n                return {\n                    name: `${this.cookieName()}-${token.key}`,\n                    value: token.value,\n                    domain: this.cookieOptions.domain,\n                    maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                    path: this.cookieOptions.path,\n                    sameSite: this.cookieOptions.sameSite\n                };\n            }));\n        }\n        if (event === 'SIGNED_OUT') (0, $f258538a2399bef1$export$31cdeeae171a741d)(req, res, [\n            'access-token',\n            'refresh-token'\n        ].map((key)=>({\n                name: `${this.cookieName()}-${key}`,\n                value: '',\n                maxAge: -1\n            })));\n        res.status(200).json({});\n    }\n    /**\n     * Deletes the Auth Cookies and redirects to the\n     * @param req The request object.\n     * @param res The response object.\n     * @param options Optionally specify a `redirectTo` URL in the options.\n     */ deleteAuthCookie(req, res, { redirectTo: redirectTo = '/' }) {\n        (0, $f258538a2399bef1$export$31cdeeae171a741d)(req, res, [\n            'access-token',\n            'refresh-token'\n        ].map((key)=>({\n                name: `${this.cookieName()}-${key}`,\n                value: '',\n                maxAge: -1\n            })));\n        return res.redirect(307, redirectTo);\n    }\n    /**\n     * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n     * @param req The request object.\n     * @param res The response object.\n     * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n     */ getAuthCookieString(req, res) {\n        if (req.method !== 'POST') {\n            res.setHeader('Allow', 'POST');\n            res.status(405).end('Method Not Allowed');\n        }\n        const { event: event, session: session } = req.body;\n        if (!event) throw new Error('Auth event missing!');\n        if (event === 'SIGNED_IN') {\n            if (!session) throw new Error('Auth session missing!');\n            return (0, $f258538a2399bef1$export$cabcf1eb6b547ccb)(req, res, [\n                {\n                    key: 'access-token',\n                    value: session.access_token\n                },\n                {\n                    key: 'refresh-token',\n                    value: session.refresh_token\n                }\n            ].map((token)=>{\n                var _a;\n                return {\n                    name: `${this.cookieName()}-${token.key}`,\n                    value: token.value,\n                    domain: this.cookieOptions.domain,\n                    maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                    path: this.cookieOptions.path,\n                    sameSite: this.cookieOptions.sameSite\n                };\n            }));\n        }\n        if (event === 'SIGNED_OUT') return (0, $f258538a2399bef1$export$cabcf1eb6b547ccb)(req, res, [\n            'access-token',\n            'refresh-token'\n        ].map((key)=>({\n                name: `${this.cookieName()}-${key}`,\n                value: '',\n                maxAge: -1\n            })));\n        return res.getHeader('Set-Cookie');\n    }\n    /**\n     * Generates links to be sent via email or other.\n     * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n     * @param email The user's email.\n     * @param password User password. For signup only.\n     * @param data Optional user metadata. For signup only.\n     * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n     */ generateLink(type, email, options = {}) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/admin/generate_link`, {\n                    type: type,\n                    email: email,\n                    password: options.password,\n                    data: options.data,\n                    redirect_to: options.redirectTo\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    // User Admin API\n    /**\n     * Creates a new user.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     *\n     * @param attributes The data you want to create the user with.\n     */ createUser(attributes) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $4bf44b5e4af6a5a5$export$299ba2dee77727e9)(this.fetch, `${this.url}/admin/users`, attributes, {\n                    headers: this.headers\n                });\n                return {\n                    user: data,\n                    data: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    user: null,\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ listUsers() {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $4bf44b5e4af6a5a5$export$3988ae62b71be9a3)(this.fetch, `${this.url}/admin/users`, {\n                    headers: this.headers\n                });\n                return {\n                    data: data.users,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ getUserById(uid) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $4bf44b5e4af6a5a5$export$3988ae62b71be9a3)(this.fetch, `${this.url}/admin/users/${uid}`, {\n                    headers: this.headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Get user by reading the cookie from the request.\n     * Works for Next.js & Express (requires cookie-parser middleware).\n     */ getUserByCookie(req, res) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                if (!req.cookies) throw new Error('Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!');\n                const access_token = req.cookies[`${this.cookieName()}-access-token`];\n                const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`];\n                if (!access_token) throw new Error('No cookie found!');\n                const { user: user, error: getUserError } = yield this.getUser(access_token);\n                if (getUserError) {\n                    if (!refresh_token) throw new Error('No refresh_token cookie found!');\n                    if (!res) throw new Error('You need to pass the res object to automatically refresh the session!');\n                    const { data: data, error: error } = yield this.refreshAccessToken(refresh_token);\n                    if (error) throw error;\n                    else if (data) {\n                        (0, $f258538a2399bef1$export$31cdeeae171a741d)(req, res, [\n                            {\n                                key: 'access-token',\n                                value: data.access_token\n                            },\n                            {\n                                key: 'refresh-token',\n                                value: data.refresh_token\n                            }\n                        ].map((token)=>{\n                            var _a;\n                            return {\n                                name: `${this.cookieName()}-${token.key}`,\n                                value: token.value,\n                                domain: this.cookieOptions.domain,\n                                maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                                path: this.cookieOptions.path,\n                                sameSite: this.cookieOptions.sameSite\n                            };\n                        }));\n                        return {\n                            token: data.access_token,\n                            user: data.user,\n                            data: data.user,\n                            error: null\n                        };\n                    }\n                }\n                return {\n                    token: access_token,\n                    user: user,\n                    data: user,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    token: null,\n                    user: null,\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Updates the user data.\n     *\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ updateUserById(uid, attributes) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                this; //\n                const data = yield (0, $4bf44b5e4af6a5a5$export$327f7b26ebf455db)(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n                    headers: this.headers\n                });\n                return {\n                    user: data,\n                    data: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    user: null,\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     *\n     * @param uid The user uid you want to remove.\n     */ deleteUser(uid) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $4bf44b5e4af6a5a5$export$cd7f480d6b8286c3)(this.fetch, `${this.url}/admin/users/${uid}`, {}, {\n                    headers: this.headers\n                });\n                return {\n                    user: data,\n                    data: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    user: null,\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Gets the current user details.\n     *\n     * This method is called by the GoTrueClient `update` where\n     * the jwt is set to this.currentSession.access_token\n     * and therefore, acts like getting the currently authenticated user\n     *\n     * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n     */ getUser(jwt) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $4bf44b5e4af6a5a5$export$3988ae62b71be9a3)(this.fetch, `${this.url}/user`, {\n                    headers: this._createRequestHeaders(jwt)\n                });\n                return {\n                    user: data,\n                    data: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    user: null,\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Updates the user data.\n     * @param jwt A valid, logged-in JWT.\n     * @param attributes The data you want to update.\n     */ updateUser(jwt, attributes) {\n        return $cfa76d5c64f3686e$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $4bf44b5e4af6a5a5$export$327f7b26ebf455db)(this.fetch, `${this.url}/user`, attributes, {\n                    headers: this._createRequestHeaders(jwt)\n                });\n                return {\n                    user: data,\n                    data: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    user: null,\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n}\n\n\n\n\n\n/**\n * https://mathiasbynens.be/notes/globalthis\n */ function $f95d1a6fd20fe489$export$ad067ce270531206() {\n    if (typeof globalThis === 'object') return;\n    try {\n        Object.defineProperty(Object.prototype, '__magic__', {\n            get: function() {\n                return this;\n            },\n            configurable: true\n        });\n        // @ts-expect-error 'Allow access to magic'\n        __magic__.globalThis = __magic__;\n        // @ts-expect-error 'Allow access to magic'\n        delete Object.prototype.__magic__;\n    } catch (e) {\n        if (typeof self !== 'undefined') // @ts-expect-error 'Allow access to globals'\n        self.globalThis = self;\n    }\n}\n\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ /* eslint-disable no-proto */ var $51861dfc7ca9d588$export$a143d493d941bafc;\nvar $51861dfc7ca9d588$export$e4cf37d7f6fb9e0a;\nvar $51861dfc7ca9d588$export$f99ded8fe4b79145;\nvar $51861dfc7ca9d588$export$599f31c3813fae4d;\n'use strict';\nvar $eeb0961446aae8e3$export$a48f0734ac7c2329;\nvar $eeb0961446aae8e3$export$d622b2ad8d90c771;\nvar $eeb0961446aae8e3$export$6100ba28696e12de;\n'use strict';\n$eeb0961446aae8e3$export$a48f0734ac7c2329 = $eeb0961446aae8e3$var$byteLength;\n$eeb0961446aae8e3$export$d622b2ad8d90c771 = $eeb0961446aae8e3$var$toByteArray;\n$eeb0961446aae8e3$export$6100ba28696e12de = $eeb0961446aae8e3$var$fromByteArray;\nvar $eeb0961446aae8e3$var$lookup = [];\nvar $eeb0961446aae8e3$var$revLookup = [];\nvar $eeb0961446aae8e3$var$Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar $eeb0961446aae8e3$var$code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor(var $eeb0961446aae8e3$var$i = 0, $eeb0961446aae8e3$var$len = $eeb0961446aae8e3$var$code.length; $eeb0961446aae8e3$var$i < $eeb0961446aae8e3$var$len; ++$eeb0961446aae8e3$var$i){\n    $eeb0961446aae8e3$var$lookup[$eeb0961446aae8e3$var$i] = $eeb0961446aae8e3$var$code[$eeb0961446aae8e3$var$i];\n    $eeb0961446aae8e3$var$revLookup[$eeb0961446aae8e3$var$code.charCodeAt($eeb0961446aae8e3$var$i)] = $eeb0961446aae8e3$var$i;\n}\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n$eeb0961446aae8e3$var$revLookup['-'.charCodeAt(0)] = 62;\n$eeb0961446aae8e3$var$revLookup['_'.charCodeAt(0)] = 63;\nfunction $eeb0961446aae8e3$var$getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');\n    // Trim off extra bytes after placeholder bytes are found\n    // See: https://github.com/beatgammit/base64-js/issues/42\n    var validLen = b64.indexOf('=');\n    if (validLen === -1) validLen = len;\n    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [\n        validLen,\n        placeHoldersLen\n    ];\n}\n// base64 is 4/3 + up to two characters of the original data\nfunction $eeb0961446aae8e3$var$byteLength(b64) {\n    var lens = $eeb0961446aae8e3$var$getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction $eeb0961446aae8e3$var$_byteLength(b64, validLen, placeHoldersLen) {\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction $eeb0961446aae8e3$var$toByteArray(b64) {\n    var tmp;\n    var lens = $eeb0961446aae8e3$var$getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new $eeb0961446aae8e3$var$Arr($eeb0961446aae8e3$var$_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    // if there are placeholders, only get up to the last complete 4 chars\n    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i;\n    for(i = 0; i < len; i += 4){\n        tmp = $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i)] << 18 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 1)] << 12 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 2)] << 6 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = tmp >> 16 & 0xFF;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 2) {\n        tmp = $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i)] << 2 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 1) {\n        tmp = $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i)] << 10 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 1)] << 4 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction $eeb0961446aae8e3$var$tripletToBase64(num) {\n    return $eeb0961446aae8e3$var$lookup[num >> 18 & 0x3F] + $eeb0961446aae8e3$var$lookup[num >> 12 & 0x3F] + $eeb0961446aae8e3$var$lookup[num >> 6 & 0x3F] + $eeb0961446aae8e3$var$lookup[num & 0x3F];\n}\nfunction $eeb0961446aae8e3$var$encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for(var i = start; i < end; i += 3){\n        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n        output.push($eeb0961446aae8e3$var$tripletToBase64(tmp));\n    }\n    return output.join('');\n}\nfunction $eeb0961446aae8e3$var$fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n    ;\n    var parts = [];\n    var maxChunkLength = 16383 // must be multiple of 3\n    ;\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push($eeb0961446aae8e3$var$encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push($eeb0961446aae8e3$var$lookup[tmp >> 2] + $eeb0961446aae8e3$var$lookup[tmp << 4 & 0x3F] + '==');\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push($eeb0961446aae8e3$var$lookup[tmp >> 10] + $eeb0961446aae8e3$var$lookup[tmp >> 4 & 0x3F] + $eeb0961446aae8e3$var$lookup[tmp << 2 & 0x3F] + '=');\n    }\n    return parts.join('');\n}\n\n\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ var $7221566bd4d49f44$export$aafa59e2e03f2942;\nvar $7221566bd4d49f44$export$68d8715fc104d294;\n$7221566bd4d49f44$export$aafa59e2e03f2942 = function(buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n    if (e === 0) e = 1 - eBias;\n    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;\n    else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n$7221566bd4d49f44$export$68d8715fc104d294 = function(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) value += rt / c;\n        else value += rt * Math.pow(2, 1 - eBias);\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n    e = e << mLen | m;\n    eLen += mLen;\n    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n    buffer[offset + i - d] |= s * 128;\n};\n\n\nconst $51861dfc7ca9d588$var$customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation\n ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n : null;\n$51861dfc7ca9d588$export$a143d493d941bafc = $51861dfc7ca9d588$var$Buffer;\n$51861dfc7ca9d588$export$e4cf37d7f6fb9e0a = $51861dfc7ca9d588$var$SlowBuffer;\n$51861dfc7ca9d588$export$f99ded8fe4b79145 = 50;\nconst $51861dfc7ca9d588$var$K_MAX_LENGTH = 0x7fffffff;\n$51861dfc7ca9d588$export$599f31c3813fae4d = $51861dfc7ca9d588$var$K_MAX_LENGTH;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */ $51861dfc7ca9d588$var$Buffer.TYPED_ARRAY_SUPPORT = $51861dfc7ca9d588$var$typedArraySupport();\nif (!$51861dfc7ca9d588$var$Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\nfunction $51861dfc7ca9d588$var$typedArraySupport() {\n    // Can typed array instances can be augmented?\n    try {\n        const arr = new Uint8Array(1);\n        const proto = {\n            foo: function() {\n                return 42;\n            }\n        };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n    } catch (e) {\n        return false;\n    }\n}\nObject.defineProperty($51861dfc7ca9d588$var$Buffer.prototype, 'parent', {\n    enumerable: true,\n    get: function() {\n        if (!$51861dfc7ca9d588$var$Buffer.isBuffer(this)) return undefined;\n        return this.buffer;\n    }\n});\nObject.defineProperty($51861dfc7ca9d588$var$Buffer.prototype, 'offset', {\n    enumerable: true,\n    get: function() {\n        if (!$51861dfc7ca9d588$var$Buffer.isBuffer(this)) return undefined;\n        return this.byteOffset;\n    }\n});\nfunction $51861dfc7ca9d588$var$createBuffer(length) {\n    if (length > $51861dfc7ca9d588$var$K_MAX_LENGTH) throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n    // Return an augmented `Uint8Array` instance\n    const buf = new Uint8Array(length);\n    Object.setPrototypeOf(buf, $51861dfc7ca9d588$var$Buffer.prototype);\n    return buf;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */ function $51861dfc7ca9d588$var$Buffer(arg, encodingOrOffset, length) {\n    // Common case.\n    if (typeof arg === 'number') {\n        if (typeof encodingOrOffset === 'string') throw new TypeError('The \"string\" argument must be of type string. Received type number');\n        return $51861dfc7ca9d588$var$allocUnsafe(arg);\n    }\n    return $51861dfc7ca9d588$var$from(arg, encodingOrOffset, length);\n}\n$51861dfc7ca9d588$var$Buffer.poolSize = 8192 // not used by this implementation\n;\nfunction $51861dfc7ca9d588$var$from(value, encodingOrOffset, length) {\n    if (typeof value === 'string') return $51861dfc7ca9d588$var$fromString(value, encodingOrOffset);\n    if (ArrayBuffer.isView(value)) return $51861dfc7ca9d588$var$fromArrayView(value);\n    if (value == null) throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n    if ($51861dfc7ca9d588$var$isInstance(value, ArrayBuffer) || value && $51861dfc7ca9d588$var$isInstance(value.buffer, ArrayBuffer)) return $51861dfc7ca9d588$var$fromArrayBuffer(value, encodingOrOffset, length);\n    if (typeof SharedArrayBuffer !== 'undefined' && ($51861dfc7ca9d588$var$isInstance(value, SharedArrayBuffer) || value && $51861dfc7ca9d588$var$isInstance(value.buffer, SharedArrayBuffer))) return $51861dfc7ca9d588$var$fromArrayBuffer(value, encodingOrOffset, length);\n    if (typeof value === 'number') throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null && valueOf !== value) return $51861dfc7ca9d588$var$Buffer.from(valueOf, encodingOrOffset, length);\n    const b = $51861dfc7ca9d588$var$fromObject(value);\n    if (b) return b;\n    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return $51861dfc7ca9d588$var$Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/ $51861dfc7ca9d588$var$Buffer.from = function(value, encodingOrOffset, length) {\n    return $51861dfc7ca9d588$var$from(value, encodingOrOffset, length);\n};\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf($51861dfc7ca9d588$var$Buffer.prototype, Uint8Array.prototype);\nObject.setPrototypeOf($51861dfc7ca9d588$var$Buffer, Uint8Array);\nfunction $51861dfc7ca9d588$var$assertSize(size) {\n    if (typeof size !== 'number') throw new TypeError('\"size\" argument must be of type number');\n    else if (size < 0) throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n}\nfunction $51861dfc7ca9d588$var$alloc(size, fill, encoding) {\n    $51861dfc7ca9d588$var$assertSize(size);\n    if (size <= 0) return $51861dfc7ca9d588$var$createBuffer(size);\n    if (fill !== undefined) // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string' ? $51861dfc7ca9d588$var$createBuffer(size).fill(fill, encoding) : $51861dfc7ca9d588$var$createBuffer(size).fill(fill);\n    return $51861dfc7ca9d588$var$createBuffer(size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/ $51861dfc7ca9d588$var$Buffer.alloc = function(size, fill, encoding) {\n    return $51861dfc7ca9d588$var$alloc(size, fill, encoding);\n};\nfunction $51861dfc7ca9d588$var$allocUnsafe(size) {\n    $51861dfc7ca9d588$var$assertSize(size);\n    return $51861dfc7ca9d588$var$createBuffer(size < 0 ? 0 : $51861dfc7ca9d588$var$checked(size) | 0);\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */ $51861dfc7ca9d588$var$Buffer.allocUnsafe = function(size) {\n    return $51861dfc7ca9d588$var$allocUnsafe(size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */ $51861dfc7ca9d588$var$Buffer.allocUnsafeSlow = function(size) {\n    return $51861dfc7ca9d588$var$allocUnsafe(size);\n};\nfunction $51861dfc7ca9d588$var$fromString(string, encoding) {\n    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';\n    if (!$51861dfc7ca9d588$var$Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);\n    const length = $51861dfc7ca9d588$var$byteLength(string, encoding) | 0;\n    let buf = $51861dfc7ca9d588$var$createBuffer(length);\n    const actual = buf.write(string, encoding);\n    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual);\n    return buf;\n}\nfunction $51861dfc7ca9d588$var$fromArrayLike(array) {\n    const length = array.length < 0 ? 0 : $51861dfc7ca9d588$var$checked(array.length) | 0;\n    const buf = $51861dfc7ca9d588$var$createBuffer(length);\n    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;\n    return buf;\n}\nfunction $51861dfc7ca9d588$var$fromArrayView(arrayView) {\n    if ($51861dfc7ca9d588$var$isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return $51861dfc7ca9d588$var$fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n    }\n    return $51861dfc7ca9d588$var$fromArrayLike(arrayView);\n}\nfunction $51861dfc7ca9d588$var$fromArrayBuffer(array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('\"offset\" is outside of buffer bounds');\n    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('\"length\" is outside of buffer bounds');\n    let buf;\n    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);\n    else if (length === undefined) buf = new Uint8Array(array, byteOffset);\n    else buf = new Uint8Array(array, byteOffset, length);\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(buf, $51861dfc7ca9d588$var$Buffer.prototype);\n    return buf;\n}\nfunction $51861dfc7ca9d588$var$fromObject(obj) {\n    if ($51861dfc7ca9d588$var$Buffer.isBuffer(obj)) {\n        const len = $51861dfc7ca9d588$var$checked(obj.length) | 0;\n        const buf = $51861dfc7ca9d588$var$createBuffer(len);\n        if (buf.length === 0) return buf;\n        obj.copy(buf, 0, 0, len);\n        return buf;\n    }\n    if (obj.length !== undefined) {\n        if (typeof obj.length !== 'number' || $51861dfc7ca9d588$var$numberIsNaN(obj.length)) return $51861dfc7ca9d588$var$createBuffer(0);\n        return $51861dfc7ca9d588$var$fromArrayLike(obj);\n    }\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return $51861dfc7ca9d588$var$fromArrayLike(obj.data);\n}\nfunction $51861dfc7ca9d588$var$checked(length) {\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= $51861dfc7ca9d588$var$K_MAX_LENGTH) throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + $51861dfc7ca9d588$var$K_MAX_LENGTH.toString(16) + ' bytes');\n    return length | 0;\n}\nfunction $51861dfc7ca9d588$var$SlowBuffer(length) {\n    if (+length != length) length = 0;\n    return $51861dfc7ca9d588$var$Buffer.alloc(+length);\n}\n$51861dfc7ca9d588$var$Buffer.isBuffer = function isBuffer(b) {\n    return b != null && b._isBuffer === true && b !== $51861dfc7ca9d588$var$Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n    ;\n};\n$51861dfc7ca9d588$var$Buffer.compare = function compare(a, b) {\n    if ($51861dfc7ca9d588$var$isInstance(a, Uint8Array)) a = $51861dfc7ca9d588$var$Buffer.from(a, a.offset, a.byteLength);\n    if ($51861dfc7ca9d588$var$isInstance(b, Uint8Array)) b = $51861dfc7ca9d588$var$Buffer.from(b, b.offset, b.byteLength);\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(a) || !$51861dfc7ca9d588$var$Buffer.isBuffer(b)) throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n    if (a === b) return 0;\n    let x = a.length;\n    let y = b.length;\n    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {\n        x = a[i];\n        y = b[i];\n        break;\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n$51861dfc7ca9d588$var$Buffer.isEncoding = function isEncoding(encoding) {\n    switch(String(encoding).toLowerCase()){\n        case 'hex':\n        case 'utf8':\n        case 'utf-8':\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n        case 'base64':\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return true;\n        default:\n            return false;\n    }\n};\n$51861dfc7ca9d588$var$Buffer.concat = function concat(list, length) {\n    if (!Array.isArray(list)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n    if (list.length === 0) return $51861dfc7ca9d588$var$Buffer.alloc(0);\n    let i;\n    if (length === undefined) {\n        length = 0;\n        for(i = 0; i < list.length; ++i)length += list[i].length;\n    }\n    const buffer = $51861dfc7ca9d588$var$Buffer.allocUnsafe(length);\n    let pos = 0;\n    for(i = 0; i < list.length; ++i){\n        let buf = list[i];\n        if ($51861dfc7ca9d588$var$isInstance(buf, Uint8Array)) {\n            if (pos + buf.length > buffer.length) {\n                if (!$51861dfc7ca9d588$var$Buffer.isBuffer(buf)) buf = $51861dfc7ca9d588$var$Buffer.from(buf);\n                buf.copy(buffer, pos);\n            } else Uint8Array.prototype.set.call(buffer, buf, pos);\n        } else if (!$51861dfc7ca9d588$var$Buffer.isBuffer(buf)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n        else buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction $51861dfc7ca9d588$var$byteLength(string, encoding) {\n    if ($51861dfc7ca9d588$var$Buffer.isBuffer(string)) return string.length;\n    if (ArrayBuffer.isView(string) || $51861dfc7ca9d588$var$isInstance(string, ArrayBuffer)) return string.byteLength;\n    if (typeof string !== 'string') throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);\n    const len = string.length;\n    const mustMatch = arguments.length > 2 && arguments[2] === true;\n    if (!mustMatch && len === 0) return 0;\n    // Use a for loop to avoid recursion\n    let loweredCase = false;\n    for(;;)switch(encoding){\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n            return len;\n        case 'utf8':\n        case 'utf-8':\n            return $51861dfc7ca9d588$var$utf8ToBytes(string).length;\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return len * 2;\n        case 'hex':\n            return len >>> 1;\n        case 'base64':\n            return $51861dfc7ca9d588$var$base64ToBytes(string).length;\n        default:\n            if (loweredCase) return mustMatch ? -1 : $51861dfc7ca9d588$var$utf8ToBytes(string).length // assume utf8\n            ;\n            encoding = ('' + encoding).toLowerCase();\n            loweredCase = true;\n    }\n}\n$51861dfc7ca9d588$var$Buffer.byteLength = $51861dfc7ca9d588$var$byteLength;\nfunction $51861dfc7ca9d588$var$slowToString(encoding, start, end) {\n    let loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) start = 0;\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) return '';\n    if (end === undefined || end > this.length) end = this.length;\n    if (end <= 0) return '';\n    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) return '';\n    if (!encoding) encoding = 'utf8';\n    while(true)switch(encoding){\n        case 'hex':\n            return $51861dfc7ca9d588$var$hexSlice(this, start, end);\n        case 'utf8':\n        case 'utf-8':\n            return $51861dfc7ca9d588$var$utf8Slice(this, start, end);\n        case 'ascii':\n            return $51861dfc7ca9d588$var$asciiSlice(this, start, end);\n        case 'latin1':\n        case 'binary':\n            return $51861dfc7ca9d588$var$latin1Slice(this, start, end);\n        case 'base64':\n            return $51861dfc7ca9d588$var$base64Slice(this, start, end);\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return $51861dfc7ca9d588$var$utf16leSlice(this, start, end);\n        default:\n            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n            encoding = (encoding + '').toLowerCase();\n            loweredCase = true;\n    }\n}\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\n$51861dfc7ca9d588$var$Buffer.prototype._isBuffer = true;\nfunction $51861dfc7ca9d588$var$swap(b, n, m) {\n    const i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.swap16 = function swap16() {\n    const len = this.length;\n    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');\n    for(let i = 0; i < len; i += 2)$51861dfc7ca9d588$var$swap(this, i, i + 1);\n    return this;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.swap32 = function swap32() {\n    const len = this.length;\n    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');\n    for(let i = 0; i < len; i += 4){\n        $51861dfc7ca9d588$var$swap(this, i, i + 3);\n        $51861dfc7ca9d588$var$swap(this, i + 1, i + 2);\n    }\n    return this;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.swap64 = function swap64() {\n    const len = this.length;\n    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');\n    for(let i = 0; i < len; i += 8){\n        $51861dfc7ca9d588$var$swap(this, i, i + 7);\n        $51861dfc7ca9d588$var$swap(this, i + 1, i + 6);\n        $51861dfc7ca9d588$var$swap(this, i + 2, i + 5);\n        $51861dfc7ca9d588$var$swap(this, i + 3, i + 4);\n    }\n    return this;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.toString = function toString() {\n    const length = this.length;\n    if (length === 0) return '';\n    if (arguments.length === 0) return $51861dfc7ca9d588$var$utf8Slice(this, 0, length);\n    return $51861dfc7ca9d588$var$slowToString.apply(this, arguments);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.toLocaleString = $51861dfc7ca9d588$var$Buffer.prototype.toString;\n$51861dfc7ca9d588$var$Buffer.prototype.equals = function equals(b) {\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n    if (this === b) return true;\n    return $51861dfc7ca9d588$var$Buffer.compare(this, b) === 0;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.inspect = function inspect() {\n    let str = '';\n    const max = $51861dfc7ca9d588$export$f99ded8fe4b79145;\n    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n    if (this.length > max) str += ' ... ';\n    return '<Buffer ' + str + '>';\n};\nif ($51861dfc7ca9d588$var$customInspectSymbol) $51861dfc7ca9d588$var$Buffer.prototype[$51861dfc7ca9d588$var$customInspectSymbol] = $51861dfc7ca9d588$var$Buffer.prototype.inspect;\n$51861dfc7ca9d588$var$Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if ($51861dfc7ca9d588$var$isInstance(target, Uint8Array)) target = $51861dfc7ca9d588$var$Buffer.from(target, target.offset, target.byteLength);\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(target)) throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);\n    if (start === undefined) start = 0;\n    if (end === undefined) end = target ? target.length : 0;\n    if (thisStart === undefined) thisStart = 0;\n    if (thisEnd === undefined) thisEnd = this.length;\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');\n    if (thisStart >= thisEnd && start >= end) return 0;\n    if (thisStart >= thisEnd) return -1;\n    if (start >= end) return 1;\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    let x = thisEnd - thisStart;\n    let y = end - start;\n    const len = Math.min(x, y);\n    const thisCopy = this.slice(thisStart, thisEnd);\n    const targetCopy = target.slice(start, end);\n    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {\n        x = thisCopy[i];\n        y = targetCopy[i];\n        break;\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction $51861dfc7ca9d588$var$bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === 'string') {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;\n    else if (byteOffset < -2147483648) byteOffset = -2147483648;\n    byteOffset = +byteOffset // Coerce to Number.\n    ;\n    if ($51861dfc7ca9d588$var$numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n    }\n    // Normalize val\n    if (typeof val === 'string') val = $51861dfc7ca9d588$var$Buffer.from(val, encoding);\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if ($51861dfc7ca9d588$var$Buffer.isBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) return -1;\n        return $51861dfc7ca9d588$var$arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === 'number') {\n        val = val & 0xFF // Search for a byte value [0-255]\n        ;\n        if (typeof Uint8Array.prototype.indexOf === 'function') {\n            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n        }\n        return $51861dfc7ca9d588$var$arrayIndexOf(buffer, [\n            val\n        ], byteOffset, encoding, dir);\n    }\n    throw new TypeError('val must be string, number or Buffer');\n}\nfunction $51861dfc7ca9d588$var$arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    let indexSize = 1;\n    let arrLength = arr.length;\n    let valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n            if (arr.length < 2 || val.length < 2) return -1;\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) return buf[i];\n        else return buf.readUInt16BE(i * indexSize);\n    }\n    let i;\n    if (dir) {\n        let foundIndex = -1;\n        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1) foundIndex = i;\n            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n        } else {\n            if (foundIndex !== -1) i -= i - foundIndex;\n            foundIndex = -1;\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for(i = byteOffset; i >= 0; i--){\n            let found = true;\n            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return $51861dfc7ca9d588$var$bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return $51861dfc7ca9d588$var$bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction $51861dfc7ca9d588$var$hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    const remaining = buf.length - offset;\n    if (!length) length = remaining;\n    else {\n        length = Number(length);\n        if (length > remaining) length = remaining;\n    }\n    const strLen = string.length;\n    if (length > strLen / 2) length = strLen / 2;\n    let i;\n    for(i = 0; i < length; ++i){\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if ($51861dfc7ca9d588$var$numberIsNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction $51861dfc7ca9d588$var$utf8Write(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction $51861dfc7ca9d588$var$asciiWrite(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$asciiToBytes(string), buf, offset, length);\n}\nfunction $51861dfc7ca9d588$var$base64Write(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$base64ToBytes(string), buf, offset, length);\n}\nfunction $51861dfc7ca9d588$var$ucs2Write(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n$51861dfc7ca9d588$var$Buffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = 'utf8';\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === 'string') {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === undefined) encoding = 'utf8';\n        } else {\n            encoding = length;\n            length = undefined;\n        }\n    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n    const remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');\n    if (!encoding) encoding = 'utf8';\n    let loweredCase = false;\n    for(;;)switch(encoding){\n        case 'hex':\n            return $51861dfc7ca9d588$var$hexWrite(this, string, offset, length);\n        case 'utf8':\n        case 'utf-8':\n            return $51861dfc7ca9d588$var$utf8Write(this, string, offset, length);\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n            return $51861dfc7ca9d588$var$asciiWrite(this, string, offset, length);\n        case 'base64':\n            // Warning: maxLength not taken into account in base64Write\n            return $51861dfc7ca9d588$var$base64Write(this, string, offset, length);\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return $51861dfc7ca9d588$var$ucs2Write(this, string, offset, length);\n        default:\n            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n            encoding = ('' + encoding).toLowerCase();\n            loweredCase = true;\n    }\n};\n$51861dfc7ca9d588$var$Buffer.prototype.toJSON = function toJSON() {\n    return {\n        type: 'Buffer',\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction $51861dfc7ca9d588$var$base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) return $eeb0961446aae8e3$export$6100ba28696e12de(buf);\n    else return $eeb0961446aae8e3$export$6100ba28696e12de(buf.slice(start, end));\n}\nfunction $51861dfc7ca9d588$var$utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    const res = [];\n    let i = start;\n    while(i < end){\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch(bytesPerSequence){\n                case 1:\n                    if (firstByte < 0x80) codePoint = firstByte;\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return $51861dfc7ca9d588$var$decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst $51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction $51861dfc7ca9d588$var$decodeCodePointsArray(codePoints) {\n    const len = codePoints.length;\n    if (len <= $51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n    ;\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    let res = '';\n    let i = 0;\n    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += $51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH));\n    return res;\n}\nfunction $51861dfc7ca9d588$var$asciiSlice(buf, start, end) {\n    let ret = '';\n    end = Math.min(buf.length, end);\n    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);\n    return ret;\n}\nfunction $51861dfc7ca9d588$var$latin1Slice(buf, start, end) {\n    let ret = '';\n    end = Math.min(buf.length, end);\n    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);\n    return ret;\n}\nfunction $51861dfc7ca9d588$var$hexSlice(buf, start, end) {\n    const len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    let out = '';\n    for(let i = start; i < end; ++i)out += $51861dfc7ca9d588$var$hexSliceLookupTable[buf[i]];\n    return out;\n}\nfunction $51861dfc7ca9d588$var$utf16leSlice(buf, start, end) {\n    const bytes = buf.slice(start, end);\n    let res = '';\n    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    return res;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.slice = function slice(start, end) {\n    const len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n    } else if (start > len) start = len;\n    if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n    } else if (end > len) end = len;\n    if (end < start) end = start;\n    const newBuf = this.subarray(start, end);\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(newBuf, $51861dfc7ca9d588$var$Buffer.prototype);\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */ function $51861dfc7ca9d588$var$checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n}\n$51861dfc7ca9d588$var$Buffer.prototype.readUintLE = $51861dfc7ca9d588$var$Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUintBE = $51861dfc7ca9d588$var$Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset + --byteLength];\n    let mul = 1;\n    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint8 = $51861dfc7ca9d588$var$Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 1, this.length);\n    return this[offset];\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint16LE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint16BE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint32LE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint32BE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readBigUInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigUInt64LE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, 'offset');\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n    return BigInt(lo) + (BigInt(hi) << BigInt(32));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readBigUInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigUInt64BE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, 'offset');\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];\n    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;\n    return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let i = byteLength;\n    let mul = 1;\n    let val = this[offset + --i];\n    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return this[offset];\n    return (0xff - this[offset] + 1) * -1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    const val = this[offset] | this[offset + 1] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    const val = this[offset + 1] | this[offset] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readBigInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigInt64LE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, 'offset');\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow\n    );\n    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readBigInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigInt64BE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, 'offset');\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];\n    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return $7221566bd4d49f44$export$aafa59e2e03f2942(this, offset, true, 23, 4);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return $7221566bd4d49f44$export$aafa59e2e03f2942(this, offset, false, 23, 4);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 8, this.length);\n    return $7221566bd4d49f44$export$aafa59e2e03f2942(this, offset, true, 52, 8);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 8, this.length);\n    return $7221566bd4d49f44$export$aafa59e2e03f2942(this, offset, false, 52, 8);\n};\nfunction $51861dfc7ca9d588$var$checkInt(buf, value, offset, ext, max, min) {\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError('Index out of range');\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeUintLE = $51861dfc7ca9d588$var$Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    let mul = 1;\n    let i = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUintBE = $51861dfc7ca9d588$var$Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    let i = byteLength - 1;\n    let mul = 1;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint8 = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 1, 0xff, 0);\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint16LE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0xffff, 0);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint16BE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0xffff, 0);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint32LE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0xffffffff, 0);\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n    return offset + 4;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint32BE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0xffffffff, 0);\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n};\nfunction $51861dfc7ca9d588$var$wrtBigUInt64LE(buf, value, offset, min, max) {\n    $51861dfc7ca9d588$var$checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    return offset;\n}\nfunction $51861dfc7ca9d588$var$wrtBigUInt64BE(buf, value, offset, min, max) {\n    $51861dfc7ca9d588$var$checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset + 7] = lo;\n    lo = lo >> 8;\n    buf[offset + 6] = lo;\n    lo = lo >> 8;\n    buf[offset + 5] = lo;\n    lo = lo >> 8;\n    buf[offset + 4] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n    buf[offset + 3] = hi;\n    hi = hi >> 8;\n    buf[offset + 2] = hi;\n    hi = hi >> 8;\n    buf[offset + 1] = hi;\n    hi = hi >> 8;\n    buf[offset] = hi;\n    return offset + 8;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigUInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigUInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength - 1);\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    let i = 0;\n    let mul = 1;\n    let sub = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength - 1);\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    let i = byteLength - 1;\n    let mul = 1;\n    let sub = 0;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 1, 0x7f, -128);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0x7fff, -32768);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0x7fff, -32768);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n    return offset + 4;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);\n    if (value < 0) value = 0xffffffff + value + 1;\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));\n});\nfunction $51861dfc7ca9d588$var$checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError('Index out of range');\n    if (offset < 0) throw new RangeError('Index out of range');\n}\nfunction $51861dfc7ca9d588$var$writeFloat(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);\n    $7221566bd4d49f44$export$68d8715fc104d294(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeFloat(this, value, offset, true, noAssert);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeFloat(this, value, offset, false, noAssert);\n};\nfunction $51861dfc7ca9d588$var$writeDouble(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);\n    $7221566bd4d49f44$export$68d8715fc104d294(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeDouble(this, value, offset, true, noAssert);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n$51861dfc7ca9d588$var$Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start;\n    // Copy 0 bytes; we're done\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0;\n    // Fatal error conditions\n    if (targetStart < 0) throw new RangeError('targetStart out of bounds');\n    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');\n    if (end < 0) throw new RangeError('sourceEnd out of bounds');\n    // Are we oob?\n    if (end > this.length) end = this.length;\n    if (target.length - targetStart < end - start) end = target.length - targetStart + start;\n    const len = end - start;\n    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end);\n    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\n$51861dfc7ca9d588$var$Buffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === 'string') {\n        if (typeof start === 'string') {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        } else if (typeof end === 'string') {\n            encoding = end;\n            end = this.length;\n        }\n        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');\n        if (typeof encoding === 'string' && !$51861dfc7ca9d588$var$Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);\n        if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.\n            val = code;\n        }\n    } else if (typeof val === 'number') val = val & 255;\n    else if (typeof val === 'boolean') val = Number(val);\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');\n    if (end <= start) return this;\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    let i;\n    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;\n    else {\n        const bytes = $51861dfc7ca9d588$var$Buffer.isBuffer(val) ? val : $51861dfc7ca9d588$var$Buffer.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];\n    }\n    return this;\n};\n// CUSTOM ERRORS\n// =============\n// Simplified versions from Node, changed for Buffer-only usage\nconst $51861dfc7ca9d588$var$errors = {};\nfunction $51861dfc7ca9d588$var$E(sym, getMessage, Base) {\n    $51861dfc7ca9d588$var$errors[sym] = class NodeError extends Base {\n        constructor(){\n            super();\n            Object.defineProperty(this, 'message', {\n                value: getMessage.apply(this, arguments),\n                writable: true,\n                configurable: true\n            });\n            // Add the error code to the name to include it in the stack trace.\n            this.name = `${this.name} [${sym}]`;\n            // Access the stack to generate the error message including the error code\n            // from the name.\n            this.stack // eslint-disable-line no-unused-expressions\n            ;\n            // Reset the name to the actual name.\n            delete this.name;\n        }\n        get code() {\n            return sym;\n        }\n        set code(value) {\n            Object.defineProperty(this, 'code', {\n                configurable: true,\n                enumerable: true,\n                value: value,\n                writable: true\n            });\n        }\n        toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n        }\n    };\n}\n$51861dfc7ca9d588$var$E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {\n    if (name) return `${name} is outside of buffer bounds`;\n    return 'Attempt to access memory outside buffer bounds';\n}, RangeError);\n$51861dfc7ca9d588$var$E('ERR_INVALID_ARG_TYPE', function(name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n}, TypeError);\n$51861dfc7ca9d588$var$E('ERR_OUT_OF_RANGE', function(str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`;\n    let received = input;\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = $51861dfc7ca9d588$var$addNumericalSeparator(String(input));\n    else if (typeof input === 'bigint') {\n        received = String(input);\n        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = $51861dfc7ca9d588$var$addNumericalSeparator(received);\n        received += 'n';\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n}, RangeError);\nfunction $51861dfc7ca9d588$var$addNumericalSeparator(val) {\n    let res = '';\n    let i = val.length;\n    const start = val[0] === '-' ? 1 : 0;\n    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;\n    return `${val.slice(0, i)}${res}`;\n}\n// CHECK FUNCTIONS\n// ===============\nfunction $51861dfc7ca9d588$var$checkBounds(buf, offset, byteLength) {\n    $51861dfc7ca9d588$var$validateNumber(offset, 'offset');\n    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) $51861dfc7ca9d588$var$boundsError(offset, buf.length - (byteLength + 1));\n}\nfunction $51861dfc7ca9d588$var$checkIntBI(value, min, max, buf, offset, byteLength) {\n    if (value > max || value < min) {\n        const n = typeof min === 'bigint' ? 'n' : '';\n        let range;\n        if (byteLength > 3) {\n            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;\n        } else range = `>= ${min}${n} and <= ${max}${n}`;\n        throw new $51861dfc7ca9d588$var$errors.ERR_OUT_OF_RANGE('value', range, value);\n    }\n    $51861dfc7ca9d588$var$checkBounds(buf, offset, byteLength);\n}\nfunction $51861dfc7ca9d588$var$validateNumber(value, name) {\n    if (typeof value !== 'number') throw new $51861dfc7ca9d588$var$errors.ERR_INVALID_ARG_TYPE(name, 'number', value);\n}\nfunction $51861dfc7ca9d588$var$boundsError(value, length, type) {\n    if (Math.floor(value) !== value) {\n        $51861dfc7ca9d588$var$validateNumber(value, type);\n        throw new $51861dfc7ca9d588$var$errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);\n    }\n    if (length < 0) throw new $51861dfc7ca9d588$var$errors.ERR_BUFFER_OUT_OF_BOUNDS();\n    throw new $51861dfc7ca9d588$var$errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);\n}\n// HELPER FUNCTIONS\n// ================\nconst $51861dfc7ca9d588$var$INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\nfunction $51861dfc7ca9d588$var$base64clean(str) {\n    // Node takes equal signs as end of the Base64 encoding\n    str = str.split('=')[0];\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = str.trim().replace($51861dfc7ca9d588$var$INVALID_BASE64_RE, '');\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return '';\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while(str.length % 4 !== 0)str = str + '=';\n    return str;\n}\nfunction $51861dfc7ca9d588$var$utf8ToBytes(string, units) {\n    units = units || Infinity;\n    let codePoint;\n    const length = string.length;\n    let leadSurrogate = null;\n    const bytes = [];\n    for(let i = 0; i < length; ++i){\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        } else if (leadSurrogate) // valid bmp char, but last char was a lead\n        {\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else throw new Error('Invalid code point');\n    }\n    return bytes;\n}\nfunction $51861dfc7ca9d588$var$asciiToBytes(str) {\n    const byteArray = [];\n    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n    return byteArray;\n}\nfunction $51861dfc7ca9d588$var$utf16leToBytes(str, units) {\n    let c, hi, lo;\n    const byteArray = [];\n    for(let i = 0; i < str.length; ++i){\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction $51861dfc7ca9d588$var$base64ToBytes(str) {\n    return $eeb0961446aae8e3$export$d622b2ad8d90c771($51861dfc7ca9d588$var$base64clean(str));\n}\nfunction $51861dfc7ca9d588$var$blitBuffer(src, dst, offset, length) {\n    let i;\n    for(i = 0; i < length; ++i){\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction $51861dfc7ca9d588$var$isInstance(obj, type) {\n    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n}\nfunction $51861dfc7ca9d588$var$numberIsNaN(obj) {\n    // For IE11 support\n    return obj !== obj // eslint-disable-line no-self-compare\n    ;\n}\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst $51861dfc7ca9d588$var$hexSliceLookupTable = function() {\n    const alphabet = '0123456789abcdef';\n    const table = new Array(256);\n    for(let i = 0; i < 16; ++i){\n        const i16 = i * 16;\n        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];\n    }\n    return table;\n}();\n// Return not function with Error if BigInt not supported\nfunction $51861dfc7ca9d588$var$defineBigIntMethod(fn) {\n    return typeof BigInt === 'undefined' ? $51861dfc7ca9d588$var$BufferBigIntNotDefined : fn;\n}\nfunction $51861dfc7ca9d588$var$BufferBigIntNotDefined() {\n    throw new Error('BigInt not supported');\n}\n\n\nvar $aa752bc178c144d4$require$Buffer = $51861dfc7ca9d588$export$a143d493d941bafc;\nvar $aa752bc178c144d4$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n(0, $f95d1a6fd20fe489$export$ad067ce270531206)(); // Make \"globalThis\" available\nconst $aa752bc178c144d4$var$DEFAULT_OPTIONS = {\n    url: (0, $bc9c0ede130f94c1$export$7fedf552187f0c3d),\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    multiTab: true,\n    headers: (0, $bc9c0ede130f94c1$export$88a84136db6a4b64)\n};\nconst $aa752bc178c144d4$var$decodeBase64URL = (value)=>{\n    try {\n        // atob is present in all browsers and nodejs >= 16\n        // but if it is not it will throw a ReferenceError in which case we can try to use Buffer\n        // replace are here to convert the Base64-URL into Base64 which is what atob supports\n        // replace with //g regex acts like replaceAll\n        return atob(value.replace(/[-]/g, '+').replace(/[_]/g, '/'));\n    } catch (e) {\n        if (e instanceof ReferenceError) // running on nodejs < 16\n        // Buffer supports Base64-URL transparently\n        return $aa752bc178c144d4$require$Buffer.from(value, 'base64').toString('utf-8');\n        else throw e;\n    }\n};\nclass $aa752bc178c144d4$export$2e2bcd8739ae039 {\n    /**\n     * Create a new client for use in the browser.\n     * @param options.url The URL of the GoTrue server.\n     * @param options.headers Any additional headers to send to the GoTrue server.\n     * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n     * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n     * @param options.cookieOptions\n     * @param options.fetch A custom fetch implementation.\n     */ constructor(options){\n        this.stateChangeEmitters = new Map();\n        this.networkRetries = 0;\n        const settings = Object.assign(Object.assign({}, $aa752bc178c144d4$var$DEFAULT_OPTIONS), options);\n        this.currentUser = null;\n        this.currentSession = null;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.persistSession = settings.persistSession;\n        this.multiTab = settings.multiTab;\n        this.localStorage = settings.localStorage || globalThis.localStorage;\n        this.api = new (0, $cfa76d5c64f3686e$export$2e2bcd8739ae039)({\n            url: settings.url,\n            headers: settings.headers,\n            cookieOptions: settings.cookieOptions,\n            fetch: settings.fetch\n        });\n        this._recoverSession();\n        this._recoverAndRefresh();\n        this._listenForMultiTabEvents();\n        this._handleVisibilityChange();\n        if (settings.detectSessionInUrl && (0, $cca04edb6116d720$export$4e09c449d6c407f7)() && !!(0, $cca04edb6116d720$export$7a5418d73bdac342)('access_token')) // Handle the OAuth redirect\n        this.getSessionFromUrl({\n            storeSession: true\n        }).then(({ error: error })=>{\n            if (error) throw new Error('Error getting session from URL.');\n        });\n    }\n    /**\n     * Creates a new user.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param password The user's password.\n     * @param phone The user's phone number.\n     * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n     * @param data Optional user metadata.\n     */ signUp({ email: email, password: password, phone: phone }, options = {}) {\n        return $aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                this._removeSession();\n                const { data: data, error: error } = phone && password ? yield this.api.signUpWithPhone(phone, password, {\n                    data: options.data,\n                    captchaToken: options.captchaToken\n                }) : yield this.api.signUpWithEmail(email, password, {\n                    redirectTo: options.redirectTo,\n                    data: options.data,\n                    captchaToken: options.captchaToken\n                });\n                if (error) throw error;\n                if (!data) throw 'An error occurred on sign up.';\n                let session = null;\n                let user = null;\n                if (data.access_token) {\n                    session = data;\n                    user = session.user;\n                    this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) user = data;\n                return {\n                    user: user,\n                    session: session,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    user: null,\n                    session: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Log in an existing user, or login via a third-party provider.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param password The user's password.\n     * @param refreshToken A valid refresh token that was returned on login.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */ signIn({ email: email, phone: phone, password: password, refreshToken: refreshToken, provider: provider, oidc: oidc }, options = {}) {\n        return $aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                this._removeSession();\n                if (email && !password) {\n                    const { error: error } = yield this.api.sendMagicLinkEmail(email, {\n                        redirectTo: options.redirectTo,\n                        shouldCreateUser: options.shouldCreateUser,\n                        captchaToken: options.captchaToken\n                    });\n                    return {\n                        user: null,\n                        session: null,\n                        error: error\n                    };\n                }\n                if (email && password) return this._handleEmailSignIn(email, password, {\n                    redirectTo: options.redirectTo,\n                    captchaToken: options.captchaToken\n                });\n                if (phone && !password) {\n                    const { error: error } = yield this.api.sendMobileOTP(phone, {\n                        shouldCreateUser: options.shouldCreateUser,\n                        captchaToken: options.captchaToken\n                    });\n                    return {\n                        user: null,\n                        session: null,\n                        error: error\n                    };\n                }\n                if (phone && password) return this._handlePhoneSignIn(phone, password);\n                if (refreshToken) {\n                    // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n                    const { error: error } = yield this._callRefreshToken(refreshToken);\n                    if (error) throw error;\n                    return {\n                        user: this.currentUser,\n                        session: this.currentSession,\n                        error: null\n                    };\n                }\n                if (provider) return this._handleProviderSignIn(provider, {\n                    redirectTo: options.redirectTo,\n                    scopes: options.scopes,\n                    queryParams: options.queryParams\n                });\n                if (oidc) return this._handleOpenIDConnectSignIn(oidc);\n                throw new Error(`You must provide either an email, phone number, a third-party provider or OpenID Connect.`);\n            } catch (e) {\n                return {\n                    user: null,\n                    session: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param token The user's password.\n     * @param type The user's verification type.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */ verifyOTP(params, options = {}) {\n        return $aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                this._removeSession();\n                const { data: data, error: error } = yield this.api.verifyOTP(params, options);\n                if (error) throw error;\n                if (!data) throw 'An error occurred on token verification.';\n                let session = null;\n                let user = null;\n                if (data.access_token) {\n                    session = data;\n                    user = session.user;\n                    this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) user = data;\n                return {\n                    user: user,\n                    session: session,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    user: null,\n                    session: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n     *\n     * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n     */ user() {\n        return this.currentUser;\n    }\n    /**\n     * Returns the session data, if there is an active session.\n     */ session() {\n        return this.currentSession;\n    }\n    /**\n     * Force refreshes the session including the user data in case it was updated in a different session.\n     */ refreshSession() {\n        var _a;\n        return $aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token)) throw new Error('Not logged in.');\n                // currentSession and currentUser will be updated to latest on _callRefreshToken\n                const { error: error } = yield this._callRefreshToken();\n                if (error) throw error;\n                return {\n                    data: this.currentSession,\n                    user: this.currentUser,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    user: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Updates user data, if there is a logged in user.\n     */ update(attributes) {\n        var _a;\n        return $aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token)) throw new Error('Not logged in.');\n                const { user: user, error: error } = yield this.api.updateUser(this.currentSession.access_token, attributes);\n                if (error) throw error;\n                if (!user) throw Error('Invalid user data.');\n                const session = Object.assign(Object.assign({}, this.currentSession), {\n                    user: user\n                });\n                this._saveSession(session);\n                this._notifyAllSubscribers('USER_UPDATED');\n                return {\n                    data: user,\n                    user: user,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    user: null,\n                    error: e\n                };\n            }\n        });\n    }\n    setSession(arg0) {\n        return $aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n            let session;\n            if (typeof arg0 === 'string') {\n                // using the refresh_token string API\n                const refresh_token = arg0;\n                const { data: data, error: error } = yield this.api.refreshAccessToken(refresh_token);\n                if (error) return {\n                    session: null,\n                    error: error\n                };\n                session = data;\n            } else {\n                // using the object parameter API\n                const timeNow = Math.round(Date.now() / 1000);\n                let { refresh_token: refresh_token, access_token: access_token } = arg0;\n                let expires_at = 0;\n                let expires_in = 0;\n                const tokenParts = access_token.split('.');\n                if (tokenParts.length !== 3) throw new Error('access_token is not a proper JWT');\n                const bodyJSON = $aa752bc178c144d4$var$decodeBase64URL(tokenParts[1]);\n                let parsed = undefined;\n                try {\n                    parsed = JSON.parse(bodyJSON);\n                } catch (e) {\n                    throw new Error('access_token is not a proper JWT, invalid JSON in body');\n                }\n                if (typeof parsed === 'object' && parsed && typeof parsed.exp === 'number') {\n                    expires_at = parsed.exp;\n                    expires_in = timeNow - parsed.exp;\n                } else throw new Error('access_token is not a proper JWT, missing exp claim');\n                if (timeNow > expires_at) {\n                    const { data: data, error: error } = yield this.api.refreshAccessToken(refresh_token);\n                    if (error) return {\n                        session: null,\n                        error: error\n                    };\n                    session = data;\n                } else {\n                    const { user: user, error: error } = yield this.api.getUser(access_token);\n                    if (error) throw error;\n                    session = {\n                        access_token: access_token,\n                        expires_in: expires_in,\n                        expires_at: expires_at,\n                        refresh_token: refresh_token,\n                        token_type: 'bearer',\n                        user: user\n                    };\n                }\n            }\n            try {\n                this._saveSession(session);\n                this._notifyAllSubscribers('SIGNED_IN');\n                return {\n                    session: session,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    error: e,\n                    session: null\n                };\n            }\n        });\n    }\n    /**\n     * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n     * @param access_token a jwt access token\n     */ setAuth(access_token) {\n        this.currentSession = Object.assign(Object.assign({}, this.currentSession), {\n            access_token: access_token,\n            token_type: 'bearer',\n            user: this.user()\n        });\n        this._notifyAllSubscribers('TOKEN_REFRESHED');\n        return this.currentSession;\n    }\n    /**\n     * Gets the session data from a URL string\n     * @param options.storeSession Optionally store the session in the browser\n     */ getSessionFromUrl(options) {\n        return $aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                if (!(0, $cca04edb6116d720$export$4e09c449d6c407f7)()) throw new Error('No browser detected.');\n                const error_description = (0, $cca04edb6116d720$export$7a5418d73bdac342)('error_description');\n                if (error_description) throw new Error(error_description);\n                const provider_token = (0, $cca04edb6116d720$export$7a5418d73bdac342)('provider_token');\n                const provider_refresh_token = (0, $cca04edb6116d720$export$7a5418d73bdac342)('provider_refresh_token');\n                const access_token = (0, $cca04edb6116d720$export$7a5418d73bdac342)('access_token');\n                if (!access_token) throw new Error('No access_token detected.');\n                const expires_in = (0, $cca04edb6116d720$export$7a5418d73bdac342)('expires_in');\n                if (!expires_in) throw new Error('No expires_in detected.');\n                const refresh_token = (0, $cca04edb6116d720$export$7a5418d73bdac342)('refresh_token');\n                if (!refresh_token) throw new Error('No refresh_token detected.');\n                const token_type = (0, $cca04edb6116d720$export$7a5418d73bdac342)('token_type');\n                if (!token_type) throw new Error('No token_type detected.');\n                const timeNow = Math.round(Date.now() / 1000);\n                const expires_at = timeNow + parseInt(expires_in);\n                const { user: user, error: error } = yield this.api.getUser(access_token);\n                if (error) throw error;\n                const session = {\n                    provider_token: provider_token,\n                    provider_refresh_token: provider_refresh_token,\n                    access_token: access_token,\n                    expires_in: parseInt(expires_in),\n                    expires_at: expires_at,\n                    refresh_token: refresh_token,\n                    token_type: token_type,\n                    user: user\n                };\n                if (options === null || options === void 0 ? void 0 : options.storeSession) {\n                    this._saveSession(session);\n                    const recoveryMode = (0, $cca04edb6116d720$export$7a5418d73bdac342)('type');\n                    this._notifyAllSubscribers('SIGNED_IN');\n                    if (recoveryMode === 'recovery') this._notifyAllSubscribers('PASSWORD_RECOVERY');\n                }\n                // Remove tokens from URL\n                window.location.hash = '';\n                return {\n                    data: session,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`. There is no way to revoke a user's session JWT before it automatically expires\n     */ signOut() {\n        var _a;\n        return $aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n            const accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n            this._removeSession();\n            this._notifyAllSubscribers('SIGNED_OUT');\n            if (accessToken) {\n                const { error: error } = yield this.api.signOut(accessToken);\n                if (error) return {\n                    error: error\n                };\n            }\n            return {\n                error: null\n            };\n        });\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n     */ onAuthStateChange(callback) {\n        try {\n            const id = (0, $cca04edb6116d720$export$31b40729666a4ae0)();\n            const subscription = {\n                id: id,\n                callback: callback,\n                unsubscribe: ()=>{\n                    this.stateChangeEmitters.delete(id);\n                }\n            };\n            this.stateChangeEmitters.set(id, subscription);\n            return {\n                data: subscription,\n                error: null\n            };\n        } catch (e) {\n            return {\n                data: null,\n                error: e\n            };\n        }\n    }\n    _handleEmailSignIn(email, password, options = {}) {\n        var _a, _b;\n        return $aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const { data: data, error: error } = yield this.api.signInWithEmail(email, password, {\n                    redirectTo: options.redirectTo,\n                    captchaToken: options.captchaToken\n                });\n                if (error || !data) return {\n                    data: null,\n                    user: null,\n                    session: null,\n                    error: error\n                };\n                if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return {\n                    data: data,\n                    user: data.user,\n                    session: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    user: null,\n                    session: null,\n                    error: e\n                };\n            }\n        });\n    }\n    _handlePhoneSignIn(phone, password, options = {}) {\n        var _a;\n        return $aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const { data: data, error: error } = yield this.api.signInWithPhone(phone, password, options);\n                if (error || !data) return {\n                    data: null,\n                    user: null,\n                    session: null,\n                    error: error\n                };\n                if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return {\n                    data: data,\n                    user: data.user,\n                    session: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    user: null,\n                    session: null,\n                    error: e\n                };\n            }\n        });\n    }\n    _handleProviderSignIn(provider, options = {}) {\n        const url = this.api.getUrlForProvider(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams\n        });\n        try {\n            // try to open on the browser\n            if ((0, $cca04edb6116d720$export$4e09c449d6c407f7)()) window.location.href = url;\n            return {\n                provider: provider,\n                url: url,\n                data: null,\n                session: null,\n                user: null,\n                error: null\n            };\n        } catch (e) {\n            // fallback to returning the URL\n            if (url) return {\n                provider: provider,\n                url: url,\n                data: null,\n                session: null,\n                user: null,\n                error: null\n            };\n            return {\n                data: null,\n                user: null,\n                session: null,\n                error: e\n            };\n        }\n    }\n    _handleOpenIDConnectSignIn({ id_token: id_token, nonce: nonce, client_id: client_id, issuer: issuer, provider: provider }) {\n        return $aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n            if (id_token && nonce && (client_id && issuer || provider)) try {\n                const { data: data, error: error } = yield this.api.signInWithOpenIDConnect({\n                    id_token: id_token,\n                    nonce: nonce,\n                    client_id: client_id,\n                    issuer: issuer,\n                    provider: provider\n                });\n                if (error || !data) return {\n                    user: null,\n                    session: null,\n                    error: error\n                };\n                this._saveSession(data);\n                this._notifyAllSubscribers('SIGNED_IN');\n                return {\n                    user: data.user,\n                    session: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    user: null,\n                    session: null,\n                    error: e\n                };\n            }\n            throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`);\n        });\n    }\n    /**\n     * Attempts to get the session from LocalStorage\n     * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n     */ _recoverSession() {\n        try {\n            const data = (0, $cca04edb6116d720$export$97dd154d855aafe0)(this.localStorage, (0, $bc9c0ede130f94c1$export$86880b4b2e1a2384));\n            if (!data) return null;\n            const { currentSession: currentSession, expiresAt: expiresAt } = data;\n            const timeNow = Math.round(Date.now() / 1000);\n            if (expiresAt >= timeNow + (0, $bc9c0ede130f94c1$export$7d4b3a66850dd9bd) && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n                this._saveSession(currentSession);\n                this._notifyAllSubscribers('SIGNED_IN');\n            }\n        } catch (error) {\n            console.log('error', error);\n        }\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */ _recoverAndRefresh() {\n        return $aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $cca04edb6116d720$export$ba6fcb7c333d32c0)(this.localStorage, (0, $bc9c0ede130f94c1$export$86880b4b2e1a2384));\n                if (!data) return null;\n                const { currentSession: currentSession, expiresAt: expiresAt } = data;\n                const timeNow = Math.round(Date.now() / 1000);\n                if (expiresAt < timeNow + (0, $bc9c0ede130f94c1$export$7d4b3a66850dd9bd)) {\n                    if (this.autoRefreshToken && currentSession.refresh_token) {\n                        this.networkRetries++;\n                        const { error: error } = yield this._callRefreshToken(currentSession.refresh_token);\n                        if (error) {\n                            console.log(error.message);\n                            if (error.message === (0, $bc9c0ede130f94c1$export$5615c708618ee858).ERROR_MESSAGE && this.networkRetries < (0, $bc9c0ede130f94c1$export$5615c708618ee858).MAX_RETRIES) {\n                                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                                this.refreshTokenTimer = setTimeout(()=>this._recoverAndRefresh(), Math.pow((0, $bc9c0ede130f94c1$export$5615c708618ee858).RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                                );\n                                return;\n                            }\n                            yield this._removeSession();\n                        }\n                        this.networkRetries = 0;\n                    } else this._removeSession();\n                } else if (!currentSession) {\n                    console.log('Current session is missing data.');\n                    this._removeSession();\n                } else {\n                    // should be handled on _recoverSession method already\n                    // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n                    this._saveSession(currentSession);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n            } catch (err) {\n                console.error(err);\n                return null;\n            }\n        });\n    }\n    _callRefreshToken(refresh_token) {\n        var _a;\n        if (refresh_token === void 0) refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token;\n        return $aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                if (!refresh_token) throw new Error('No current session.');\n                const { data: data, error: error } = yield this.api.refreshAccessToken(refresh_token);\n                if (error) throw error;\n                if (!data) throw Error('Invalid session data.');\n                this._saveSession(data);\n                this._notifyAllSubscribers('TOKEN_REFRESHED');\n                this._notifyAllSubscribers('SIGNED_IN');\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (e) {\n                return {\n                    data: null,\n                    error: e\n                };\n            }\n        });\n    }\n    _notifyAllSubscribers(event) {\n        this.stateChangeEmitters.forEach((x)=>x.callback(event, this.currentSession));\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */ _saveSession(session) {\n        this.currentSession = session;\n        this.currentUser = session.user;\n        const expiresAt = session.expires_at;\n        if (expiresAt) {\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = expiresAt - timeNow;\n            const refreshDurationBeforeExpires = expiresIn > (0, $bc9c0ede130f94c1$export$7d4b3a66850dd9bd) ? (0, $bc9c0ede130f94c1$export$7d4b3a66850dd9bd) : 0.5;\n            this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n        }\n        // Do we need any extra check before persist session\n        // access_token or user ?\n        if (this.persistSession && session.expires_at) this._persistSession(this.currentSession);\n    }\n    _persistSession(currentSession) {\n        const data = {\n            currentSession: currentSession,\n            expiresAt: currentSession.expires_at\n        };\n        (0, $cca04edb6116d720$export$e82c36d29078a87f)(this.localStorage, (0, $bc9c0ede130f94c1$export$86880b4b2e1a2384), data);\n    }\n    _removeSession() {\n        return $aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n            this.currentSession = null;\n            this.currentUser = null;\n            if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n            (0, $cca04edb6116d720$export$d35c645d585317ec)(this.localStorage, (0, $bc9c0ede130f94c1$export$86880b4b2e1a2384));\n        });\n    }\n    /**\n     * Clear and re-create refresh token timer\n     * @param value time intervals in milliseconds\n     */ _startAutoRefreshToken(value) {\n        if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n        if (value <= 0 || !this.autoRefreshToken) return;\n        this.refreshTokenTimer = setTimeout(()=>$aa752bc178c144d4$var$__awaiter(this, void 0, void 0, function*() {\n                this.networkRetries++;\n                const { error: error } = yield this._callRefreshToken();\n                if (!error) this.networkRetries = 0;\n                if ((error === null || error === void 0 ? void 0 : error.message) === (0, $bc9c0ede130f94c1$export$5615c708618ee858).ERROR_MESSAGE && this.networkRetries < (0, $bc9c0ede130f94c1$export$5615c708618ee858).MAX_RETRIES) this._startAutoRefreshToken(Math.pow((0, $bc9c0ede130f94c1$export$5615c708618ee858).RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n            }), value);\n        if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n    }\n    /**\n     * Listens for changes to LocalStorage and updates the current session.\n     */ _listenForMultiTabEvents() {\n        if (!this.multiTab || !(0, $cca04edb6116d720$export$4e09c449d6c407f7)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) return false;\n        try {\n            window === null || window === void 0 || window.addEventListener('storage', (e)=>{\n                var _a;\n                if (e.key === (0, $bc9c0ede130f94c1$export$86880b4b2e1a2384)) {\n                    const newSession = JSON.parse(String(e.newValue));\n                    if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n                        this._saveSession(newSession.currentSession);\n                        this._notifyAllSubscribers('SIGNED_IN');\n                    } else {\n                        this._removeSession();\n                        this._notifyAllSubscribers('SIGNED_OUT');\n                    }\n                }\n            });\n        } catch (error) {\n            console.error('_listenForMultiTabEvents', error);\n        }\n    }\n    _handleVisibilityChange() {\n        if (!this.multiTab || !(0, $cca04edb6116d720$export$4e09c449d6c407f7)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) return false;\n        try {\n            window === null || window === void 0 || window.addEventListener('visibilitychange', ()=>{\n                if (document.visibilityState === 'visible') this._recoverAndRefresh();\n            });\n        } catch (error) {\n            console.error('_handleVisibilityChange', error);\n        }\n    }\n}\n\n\n\n\n\n\nclass $b6000684d7c6c56c$export$8199a418bb09bd56 extends (0, $aa752bc178c144d4$export$2e2bcd8739ae039) {\n    constructor(options){\n        super(options);\n    }\n}\n\n\nvar $3aaf6419364c17d6$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass $3aaf6419364c17d6$export$3106e21688a06353 {\n    constructor(builder){\n        Object.assign(this, builder);\n        let _fetch;\n        if (builder.fetch) _fetch = builder.fetch;\n        else if (typeof fetch === 'undefined') _fetch = (...args)=>$3aaf6419364c17d6$var$__awaiter(this, void 0, void 0, function*() {\n                return yield (yield (parcelRequire(\"6s4wM\"))).fetch(...args);\n            });\n        else _fetch = fetch;\n        this.fetch = (...args)=>_fetch(...args);\n        this.shouldThrowOnError = builder.shouldThrowOnError || false;\n        this.allowEmpty = builder.allowEmpty || false;\n    }\n    /**\n     * If there's an error with the query, throwOnError will reject the promise by\n     * throwing the error instead of returning it as part of a successful response.\n     *\n     * {@link https://github.com/supabase/supabase-js/issues/92}\n     */ throwOnError(throwOnError) {\n        if (throwOnError === null || throwOnError === undefined) throwOnError = true;\n        this.shouldThrowOnError = throwOnError;\n        return this;\n    }\n    then(onfulfilled, onrejected) {\n        // https://postgrest.org/en/stable/api.html#switching-schemas\n        if (typeof this.schema === 'undefined') ;\n        else if ([\n            'GET',\n            'HEAD'\n        ].includes(this.method)) this.headers['Accept-Profile'] = this.schema;\n        else this.headers['Content-Profile'] = this.schema;\n        if (this.method !== 'GET' && this.method !== 'HEAD') this.headers['Content-Type'] = 'application/json';\n        let res = this.fetch(this.url.toString(), {\n            method: this.method,\n            headers: this.headers,\n            body: JSON.stringify(this.body),\n            signal: this.signal\n        }).then((res)=>$3aaf6419364c17d6$var$__awaiter(this, void 0, void 0, function*() {\n                var _a, _b, _c, _d;\n                let error = null;\n                let data = null;\n                let count = null;\n                let status = res.status;\n                let statusText = res.statusText;\n                if (res.ok) {\n                    const isReturnMinimal = (_a = this.headers['Prefer']) === null || _a === void 0 ? void 0 : _a.split(',').includes('return=minimal');\n                    if (this.method !== 'HEAD' && !isReturnMinimal) {\n                        const text = yield res.text();\n                        if (!text) ;\n                        else if (this.headers['Accept'] === 'text/csv') data = text;\n                        else data = JSON.parse(text);\n                    }\n                    const countHeader = (_b = this.headers['Prefer']) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);\n                    const contentRange = (_c = res.headers.get('content-range')) === null || _c === void 0 ? void 0 : _c.split('/');\n                    if (countHeader && contentRange && contentRange.length > 1) count = parseInt(contentRange[1]);\n                } else {\n                    const body = yield res.text();\n                    try {\n                        error = JSON.parse(body);\n                    } catch (_e) {\n                        error = {\n                            message: body\n                        };\n                    }\n                    if (error && this.allowEmpty && ((_d = error === null || error === void 0 ? void 0 : error.details) === null || _d === void 0 ? void 0 : _d.includes('Results contain 0 rows'))) {\n                        error = null;\n                        status = 200;\n                        statusText = 'OK';\n                    }\n                    if (error && this.shouldThrowOnError) throw error;\n                }\n                const postgrestResponse = {\n                    error: error,\n                    data: data,\n                    count: count,\n                    status: status,\n                    statusText: statusText,\n                    body: data\n                };\n                return postgrestResponse;\n            }));\n        if (!this.shouldThrowOnError) res = res.catch((fetchError)=>({\n                error: {\n                    message: `FetchError: ${fetchError.message}`,\n                    details: '',\n                    hint: '',\n                    code: fetchError.code || ''\n                },\n                data: null,\n                body: null,\n                count: null,\n                status: 400,\n                statusText: 'Bad Request'\n            }));\n        return res.then(onfulfilled, onrejected);\n    }\n}\n\n\n\nclass $a1803de8df26892f$export$2e2bcd8739ae039 extends (0, $3aaf6419364c17d6$export$3106e21688a06353) {\n    /**\n     * Performs vertical filtering with SELECT.\n     *\n     * @param columns  The columns to retrieve, separated by commas.\n     */ select(columns = '*') {\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = columns.split('').map((c)=>{\n            if (/\\s/.test(c) && !quoted) return '';\n            if (c === '\"') quoted = !quoted;\n            return c;\n        }).join('');\n        this.url.searchParams.set('select', cleanedColumns);\n        return this;\n    }\n    /**\n     * Orders the result with the specified `column`.\n     *\n     * @param column  The column to order on.\n     * @param ascending  If `true`, the result will be in ascending order.\n     * @param nullsFirst  If `true`, `null`s appear first.\n     * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n     */ order(column, { ascending: ascending = true, nullsFirst: nullsFirst = false, foreignTable: foreignTable } = {}) {\n        const key = typeof foreignTable === 'undefined' ? 'order' : `${foreignTable}.order`;\n        const existingOrder = this.url.searchParams.get(key);\n        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}.${nullsFirst ? 'nullsfirst' : 'nullslast'}`);\n        return this;\n    }\n    /**\n     * Limits the result with the specified `count`.\n     *\n     * @param count  The maximum no. of rows to limit to.\n     * @param foreignTable  The foreign table to use (for foreign columns).\n     */ limit(count, { foreignTable: foreignTable } = {}) {\n        const key = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`;\n        this.url.searchParams.set(key, `${count}`);\n        return this;\n    }\n    /**\n     * Limits the result to rows within the specified range, inclusive.\n     *\n     * @param from  The starting index from which to limit the result, inclusive.\n     * @param to  The last index to which to limit the result, inclusive.\n     * @param foreignTable  The foreign table to use (for foreign columns).\n     */ range(from, to, { foreignTable: foreignTable } = {}) {\n        const keyOffset = typeof foreignTable === 'undefined' ? 'offset' : `${foreignTable}.offset`;\n        const keyLimit = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`;\n        this.url.searchParams.set(keyOffset, `${from}`);\n        // Range is inclusive, so add 1\n        this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n        return this;\n    }\n    /**\n     * Sets the AbortSignal for the fetch request.\n     */ abortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    /**\n     * Retrieves only one row from the result. Result must be one row (e.g. using\n     * `limit`), otherwise this will result in an error.\n     */ single() {\n        this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n        return this;\n    }\n    /**\n     * Retrieves at most one row from the result. Result must be at most one row\n     * (e.g. using `eq` on a UNIQUE column), otherwise this will result in an\n     * error.\n     */ maybeSingle() {\n        this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n        this.allowEmpty = true;\n        return this;\n    }\n    /**\n     * Set the response type to CSV.\n     */ csv() {\n        this.headers['Accept'] = 'text/csv';\n        return this;\n    }\n}\n\n\nclass $7183990437551054$export$2e2bcd8739ae039 extends (0, $a1803de8df26892f$export$2e2bcd8739ae039) {\n    constructor(){\n        super(...arguments);\n        /** @deprecated Use `contains()` instead. */ this.cs = this.contains;\n        /** @deprecated Use `containedBy()` instead. */ this.cd = this.containedBy;\n        /** @deprecated Use `rangeLt()` instead. */ this.sl = this.rangeLt;\n        /** @deprecated Use `rangeGt()` instead. */ this.sr = this.rangeGt;\n        /** @deprecated Use `rangeGte()` instead. */ this.nxl = this.rangeGte;\n        /** @deprecated Use `rangeLte()` instead. */ this.nxr = this.rangeLte;\n        /** @deprecated Use `rangeAdjacent()` instead. */ this.adj = this.rangeAdjacent;\n        /** @deprecated Use `overlaps()` instead. */ this.ov = this.overlaps;\n    }\n    /**\n     * Finds all rows which doesn't satisfy the filter.\n     *\n     * @param column  The column to filter on.\n     * @param operator  The operator to filter with.\n     * @param value  The value to filter with.\n     */ not(column, operator, value) {\n        this.url.searchParams.append(`${column}`, `not.${operator}.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows satisfying at least one of the filters.\n     *\n     * @param filters  The filters to use, separated by commas.\n     * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n     */ or(filters, { foreignTable: foreignTable } = {}) {\n        const key = typeof foreignTable === 'undefined' ? 'or' : `${foreignTable}.or`;\n        this.url.searchParams.append(key, `(${filters})`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` exactly matches the\n     * specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */ eq(column, value) {\n        this.url.searchParams.append(`${column}`, `eq.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` doesn't match the\n     * specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */ neq(column, value) {\n        this.url.searchParams.append(`${column}`, `neq.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is greater than the\n     * specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */ gt(column, value) {\n        this.url.searchParams.append(`${column}`, `gt.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is greater than or\n     * equal to the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */ gte(column, value) {\n        this.url.searchParams.append(`${column}`, `gte.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is less than the\n     * specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */ lt(column, value) {\n        this.url.searchParams.append(`${column}`, `lt.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is less than or equal\n     * to the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */ lte(column, value) {\n        this.url.searchParams.append(`${column}`, `lte.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value in the stated `column` matches the supplied\n     * `pattern` (case sensitive).\n     *\n     * @param column  The column to filter on.\n     * @param pattern  The pattern to filter with.\n     */ like(column, pattern) {\n        this.url.searchParams.append(`${column}`, `like.${pattern}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value in the stated `column` matches the supplied\n     * `pattern` (case insensitive).\n     *\n     * @param column  The column to filter on.\n     * @param pattern  The pattern to filter with.\n     */ ilike(column, pattern) {\n        this.url.searchParams.append(`${column}`, `ilike.${pattern}`);\n        return this;\n    }\n    /**\n     * A check for exact equality (null, true, false), finds all rows whose\n     * value on the stated `column` exactly match the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */ is(column, value) {\n        this.url.searchParams.append(`${column}`, `is.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is found on the\n     * specified `values`.\n     *\n     * @param column  The column to filter on.\n     * @param values  The values to filter with.\n     */ in(column, values) {\n        const cleanedValues = values.map((s)=>{\n            // handle postgrest reserved characters\n            // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n            if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`;\n            else return `${s}`;\n        }).join(',');\n        this.url.searchParams.append(`${column}`, `in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n     * Finds all rows whose json, array, or range value on the stated `column`\n     * contains the values specified in `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */ contains(column, value) {\n        if (typeof value === 'string') // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n        // keep it simple and accept a string\n        this.url.searchParams.append(`${column}`, `cs.${value}`);\n        else if (Array.isArray(value)) // array\n        this.url.searchParams.append(`${column}`, `cs.{${value.join(',')}}`);\n        else // json\n        this.url.searchParams.append(`${column}`, `cs.${JSON.stringify(value)}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose json, array, or range value on the stated `column` is\n     * contained by the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */ containedBy(column, value) {\n        if (typeof value === 'string') // range\n        this.url.searchParams.append(`${column}`, `cd.${value}`);\n        else if (Array.isArray(value)) // array\n        this.url.searchParams.append(`${column}`, `cd.{${value.join(',')}}`);\n        else // json\n        this.url.searchParams.append(`${column}`, `cd.${JSON.stringify(value)}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` is strictly to the\n     * left of the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */ rangeLt(column, range) {\n        this.url.searchParams.append(`${column}`, `sl.${range}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` is strictly to\n     * the right of the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */ rangeGt(column, range) {\n        this.url.searchParams.append(`${column}`, `sr.${range}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` does not extend\n     * to the left of the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */ rangeGte(column, range) {\n        this.url.searchParams.append(`${column}`, `nxl.${range}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` does not extend\n     * to the right of the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */ rangeLte(column, range) {\n        this.url.searchParams.append(`${column}`, `nxr.${range}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` is adjacent to\n     * the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */ rangeAdjacent(column, range) {\n        this.url.searchParams.append(`${column}`, `adj.${range}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose array or range value on the stated `column` overlaps\n     * (has a value in common) with the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */ overlaps(column, value) {\n        if (typeof value === 'string') // range\n        this.url.searchParams.append(`${column}`, `ov.${value}`);\n        else // array\n        this.url.searchParams.append(`${column}`, `ov.{${value.join(',')}}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose text or tsvector value on the stated `column` matches\n     * the tsquery in `query`.\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     * @param type  The type of tsquery conversion to use on `query`.\n     */ textSearch(column, query, { config: config, type: type = null } = {}) {\n        let typePart = '';\n        if (type === 'plain') typePart = 'pl';\n        else if (type === 'phrase') typePart = 'ph';\n        else if (type === 'websearch') typePart = 'w';\n        const configPart = config === undefined ? '' : `(${config})`;\n        this.url.searchParams.append(`${column}`, `${typePart}fts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose tsvector value on the stated `column` matches\n     * to_tsquery(`query`).\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     *\n     * @deprecated Use `textSearch()` instead.\n     */ fts(column, query, { config: config } = {}) {\n        const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n        this.url.searchParams.append(`${column}`, `fts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose tsvector value on the stated `column` matches\n     * plainto_tsquery(`query`).\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     *\n     * @deprecated Use `textSearch()` with `type: 'plain'` instead.\n     */ plfts(column, query, { config: config } = {}) {\n        const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n        this.url.searchParams.append(`${column}`, `plfts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose tsvector value on the stated `column` matches\n     * phraseto_tsquery(`query`).\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     *\n     * @deprecated Use `textSearch()` with `type: 'phrase'` instead.\n     */ phfts(column, query, { config: config } = {}) {\n        const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n        this.url.searchParams.append(`${column}`, `phfts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose tsvector value on the stated `column` matches\n     * websearch_to_tsquery(`query`).\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     *\n     * @deprecated Use `textSearch()` with `type: 'websearch'` instead.\n     */ wfts(column, query, { config: config } = {}) {\n        const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n        this.url.searchParams.append(`${column}`, `wfts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose `column` satisfies the filter.\n     *\n     * @param column  The column to filter on.\n     * @param operator  The operator to filter with.\n     * @param value  The value to filter with.\n     */ filter(column, operator, value) {\n        this.url.searchParams.append(`${column}`, `${operator}.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose columns match the specified `query` object.\n     *\n     * @param query  The object to filter with, with column names as keys mapped\n     *               to their filter values.\n     */ match(query) {\n        Object.keys(query).forEach((key)=>{\n            this.url.searchParams.append(`${key}`, `eq.${query[key]}`);\n        });\n        return this;\n    }\n}\n\n\nclass $c0d502ff80704788$export$2e2bcd8739ae039 extends (0, $3aaf6419364c17d6$export$3106e21688a06353) {\n    constructor(url, { headers: headers = {}, schema: schema, fetch: fetch, shouldThrowOnError: shouldThrowOnError } = {}){\n        super({\n            fetch: fetch,\n            shouldThrowOnError: shouldThrowOnError\n        });\n        this.url = new URL(url);\n        this.headers = Object.assign({}, headers);\n        this.schema = schema;\n    }\n    /**\n     * Performs vertical filtering with SELECT.\n     *\n     * @param columns  The columns to retrieve, separated by commas.\n     * @param head  When set to true, select will void data.\n     * @param count  Count algorithm to use to count rows in a table.\n     */ select(columns = '*', { head: head = false, count: count = null } = {}) {\n        this.method = 'GET';\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = columns.split('').map((c)=>{\n            if (/\\s/.test(c) && !quoted) return '';\n            if (c === '\"') quoted = !quoted;\n            return c;\n        }).join('');\n        this.url.searchParams.set('select', cleanedColumns);\n        if (count) this.headers['Prefer'] = `count=${count}`;\n        if (head) this.method = 'HEAD';\n        return new (0, $7183990437551054$export$2e2bcd8739ae039)(this);\n    }\n    insert(values, { upsert: upsert = false, onConflict: onConflict, returning: returning = 'representation', count: count = null } = {}) {\n        this.method = 'POST';\n        const prefersHeaders = [\n            `return=${returning}`\n        ];\n        if (upsert) prefersHeaders.push('resolution=merge-duplicates');\n        if (upsert && onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);\n        this.body = values;\n        if (count) prefersHeaders.push(`count=${count}`);\n        if (this.headers['Prefer']) prefersHeaders.unshift(this.headers['Prefer']);\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>`\"${column}\"`);\n                this.url.searchParams.set('columns', uniqueColumns.join(','));\n            }\n        }\n        return new (0, $7183990437551054$export$2e2bcd8739ae039)(this);\n    }\n    /**\n     * Performs an UPSERT into the table.\n     *\n     * @param values  The values to insert.\n     * @param onConflict  By specifying the `on_conflict` query parameter, you can make UPSERT work on a column(s) that has a UNIQUE constraint.\n     * @param returning  By default the new record is returned. Set this to 'minimal' if you don't need this value.\n     * @param count  Count algorithm to use to count rows in a table.\n     * @param ignoreDuplicates  Specifies if duplicate rows should be ignored and not inserted.\n     */ upsert(values, { onConflict: onConflict, returning: returning = 'representation', count: count = null, ignoreDuplicates: ignoreDuplicates = false } = {}) {\n        this.method = 'POST';\n        const prefersHeaders = [\n            `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`,\n            `return=${returning}`\n        ];\n        if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);\n        this.body = values;\n        if (count) prefersHeaders.push(`count=${count}`);\n        if (this.headers['Prefer']) prefersHeaders.unshift(this.headers['Prefer']);\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new (0, $7183990437551054$export$2e2bcd8739ae039)(this);\n    }\n    /**\n     * Performs an UPDATE on the table.\n     *\n     * @param values  The values to update.\n     * @param returning  By default the updated record is returned. Set this to 'minimal' if you don't need this value.\n     * @param count  Count algorithm to use to count rows in a table.\n     */ update(values, { returning: returning = 'representation', count: count = null } = {}) {\n        this.method = 'PATCH';\n        const prefersHeaders = [\n            `return=${returning}`\n        ];\n        this.body = values;\n        if (count) prefersHeaders.push(`count=${count}`);\n        if (this.headers['Prefer']) prefersHeaders.unshift(this.headers['Prefer']);\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new (0, $7183990437551054$export$2e2bcd8739ae039)(this);\n    }\n    /**\n     * Performs a DELETE on the table.\n     *\n     * @param returning  If `true`, return the deleted row(s) in the response.\n     * @param count  Count algorithm to use to count rows in a table.\n     */ delete({ returning: returning = 'representation', count: count = null } = {}) {\n        this.method = 'DELETE';\n        const prefersHeaders = [\n            `return=${returning}`\n        ];\n        if (count) prefersHeaders.push(`count=${count}`);\n        if (this.headers['Prefer']) prefersHeaders.unshift(this.headers['Prefer']);\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new (0, $7183990437551054$export$2e2bcd8739ae039)(this);\n    }\n}\n\n\n\n\nclass $025be36b8ad4e2ba$export$2e2bcd8739ae039 extends (0, $3aaf6419364c17d6$export$3106e21688a06353) {\n    constructor(url, { headers: headers = {}, schema: schema, fetch: fetch, shouldThrowOnError: shouldThrowOnError } = {}){\n        super({\n            fetch: fetch,\n            shouldThrowOnError: shouldThrowOnError\n        });\n        this.url = new URL(url);\n        this.headers = Object.assign({}, headers);\n        this.schema = schema;\n    }\n    /**\n     * Perform a function call.\n     */ rpc(params, { head: head = false, count: count = null } = {}) {\n        if (head) {\n            this.method = 'HEAD';\n            if (params) Object.entries(params).forEach(([name, value])=>{\n                this.url.searchParams.append(name, value);\n            });\n        } else {\n            this.method = 'POST';\n            this.body = params;\n        }\n        if (count) {\n            if (this.headers['Prefer'] !== undefined) this.headers['Prefer'] += `,count=${count}`;\n            else this.headers['Prefer'] = `count=${count}`;\n        }\n        return new (0, $7183990437551054$export$2e2bcd8739ae039)(this);\n    }\n}\n\n\n// generated by genversion\nconst $b657937ef2c3fe71$export$83d89fbfd8236492 = '0.37.4';\n\n\nconst $3212d5f3017e8dc3$export$88a84136db6a4b64 = {\n    'X-Client-Info': `postgrest-js/${(0, $b657937ef2c3fe71$export$83d89fbfd8236492)}`\n};\n\n\nclass $83c92f94715fb663$export$2e2bcd8739ae039 {\n    /**\n     * Creates a PostgREST client.\n     *\n     * @param url  URL of the PostgREST endpoint.\n     * @param headers  Custom headers.\n     * @param schema  Postgres schema to switch to.\n     */ constructor(url, { headers: headers = {}, schema: schema, fetch: fetch, throwOnError: throwOnError } = {}){\n        this.url = url;\n        this.headers = Object.assign(Object.assign({}, (0, $3212d5f3017e8dc3$export$88a84136db6a4b64)), headers);\n        this.schema = schema;\n        this.fetch = fetch;\n        this.shouldThrowOnError = throwOnError;\n    }\n    /**\n     * Authenticates the request with JWT.\n     *\n     * @param token  The JWT token to use.\n     */ auth(token) {\n        this.headers['Authorization'] = `Bearer ${token}`;\n        return this;\n    }\n    /**\n     * Perform a table operation.\n     *\n     * @param table  The table name to operate on.\n     */ from(table) {\n        const url = `${this.url}/${table}`;\n        return new (0, $c0d502ff80704788$export$2e2bcd8739ae039)(url, {\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            shouldThrowOnError: this.shouldThrowOnError\n        });\n    }\n    /**\n     * Perform a function call.\n     *\n     * @param fn  The function name to call.\n     * @param params  The parameters to pass to the function call.\n     * @param head  When set to true, no data will be returned.\n     * @param count  Count algorithm to use to count rows in a table.\n     */ rpc(fn, params, { head: head = false, count: count = null } = {}) {\n        const url = `${this.url}/rpc/${fn}`;\n        return new (0, $025be36b8ad4e2ba$export$2e2bcd8739ae039)(url, {\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            shouldThrowOnError: this.shouldThrowOnError\n        }).rpc(params, {\n            head: head,\n            count: count\n        });\n    }\n}\n\n\n\n\n\n\n\nvar $3f01feefa94fd48b$exports = {};\n\n$parcel$export($3f01feefa94fd48b$exports, \"PostgresTypes\", () => $3f01feefa94fd48b$export$4d213a7d364021dc);\n$parcel$export($3f01feefa94fd48b$exports, \"convertChangeData\", () => $3f01feefa94fd48b$export$20ce708a1f594c5e);\n$parcel$export($3f01feefa94fd48b$exports, \"convertColumn\", () => $3f01feefa94fd48b$export$c054edfec1afa88d);\n$parcel$export($3f01feefa94fd48b$exports, \"convertCell\", () => $3f01feefa94fd48b$export$3df02a362b86a91);\n$parcel$export($3f01feefa94fd48b$exports, \"toArray\", () => $3f01feefa94fd48b$export$45b10814cc054894);\n$parcel$export($3f01feefa94fd48b$exports, \"toBoolean\", () => $3f01feefa94fd48b$export$3c2e6d1b7583eee6);\n$parcel$export($3f01feefa94fd48b$exports, \"toNumber\", () => $3f01feefa94fd48b$export$a0a81dc3380ce7d3);\n$parcel$export($3f01feefa94fd48b$exports, \"toJson\", () => $3f01feefa94fd48b$export$d5b7a8bf56ee1fe2);\n$parcel$export($3f01feefa94fd48b$exports, \"toTimestampString\", () => $3f01feefa94fd48b$export$eccf8c5d91d19e3a);\n/**\n * Helpers to convert the change Payload into native JS types.\n */ // Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nvar $3f01feefa94fd48b$export$4d213a7d364021dc;\n(function(PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"text\"] = \"text\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})($3f01feefa94fd48b$export$4d213a7d364021dc || ($3f01feefa94fd48b$export$4d213a7d364021dc = {}));\nconst $3f01feefa94fd48b$export$20ce708a1f594c5e = (columns, record, options = {})=>{\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    return Object.keys(record).reduce((acc, rec_key)=>{\n        acc[rec_key] = $3f01feefa94fd48b$export$c054edfec1afa88d(rec_key, columns, record, skipTypes);\n        return acc;\n    }, {});\n};\nconst $3f01feefa94fd48b$export$c054edfec1afa88d = (columnName, columns, record, skipTypes)=>{\n    const column = columns.find((x)=>x.name === columnName);\n    const colType = column === null || column === void 0 ? void 0 : column.type;\n    const value = record[columnName];\n    if (colType && !skipTypes.includes(colType)) return $3f01feefa94fd48b$export$3df02a362b86a91(colType, value);\n    return $3f01feefa94fd48b$var$noop(value);\n};\nconst $3f01feefa94fd48b$export$3df02a362b86a91 = (type, value)=>{\n    // if data type is an array\n    if (type.charAt(0) === '_') {\n        const dataType = type.slice(1, type.length);\n        return $3f01feefa94fd48b$export$45b10814cc054894(value, dataType);\n    }\n    // If not null, convert to correct type.\n    switch(type){\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.bool:\n            return $3f01feefa94fd48b$export$3c2e6d1b7583eee6(value);\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.float4:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.float8:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.int2:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.int4:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.int8:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.numeric:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.oid:\n            return $3f01feefa94fd48b$export$a0a81dc3380ce7d3(value);\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.json:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.jsonb:\n            return $3f01feefa94fd48b$export$d5b7a8bf56ee1fe2(value);\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.timestamp:\n            return $3f01feefa94fd48b$export$eccf8c5d91d19e3a(value); // Format to be consistent with PostgREST\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.abstime:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.date:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.daterange:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.int4range:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.int8range:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.money:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.reltime:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.text:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.time:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.timestamptz:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.timetz:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.tsrange:\n        case $3f01feefa94fd48b$export$4d213a7d364021dc.tstzrange:\n            return $3f01feefa94fd48b$var$noop(value);\n        default:\n            // Return the value for remaining types\n            return $3f01feefa94fd48b$var$noop(value);\n    }\n};\nconst $3f01feefa94fd48b$var$noop = (value)=>{\n    return value;\n};\nconst $3f01feefa94fd48b$export$3c2e6d1b7583eee6 = (value)=>{\n    switch(value){\n        case 't':\n            return true;\n        case 'f':\n            return false;\n        default:\n            return value;\n    }\n};\nconst $3f01feefa94fd48b$export$a0a81dc3380ce7d3 = (value)=>{\n    if (typeof value === 'string') {\n        const parsedValue = parseFloat(value);\n        if (!Number.isNaN(parsedValue)) return parsedValue;\n    }\n    return value;\n};\nconst $3f01feefa94fd48b$export$d5b7a8bf56ee1fe2 = (value)=>{\n    if (typeof value === 'string') try {\n        return JSON.parse(value);\n    } catch (error) {\n        console.log(`JSON parse error: ${error}`);\n        return value;\n    }\n    return value;\n};\nconst $3f01feefa94fd48b$export$45b10814cc054894 = (value, type)=>{\n    if (typeof value !== 'string') return value;\n    const lastIdx = value.length - 1;\n    const closeBrace = value[lastIdx];\n    const openBrace = value[0];\n    // Confirm value is a Postgres array by checking curly brackets\n    if (openBrace === '{' && closeBrace === '}') {\n        let arr;\n        const valTrim = value.slice(1, lastIdx);\n        // TODO: find a better solution to separate Postgres array data\n        try {\n            arr = JSON.parse('[' + valTrim + ']');\n        } catch (_) {\n            // WARNING: splitting on comma does not cover all edge cases\n            arr = valTrim ? valTrim.split(',') : [];\n        }\n        return arr.map((val)=>$3f01feefa94fd48b$export$3df02a362b86a91(type, val));\n    }\n    return value;\n};\nconst $3f01feefa94fd48b$export$eccf8c5d91d19e3a = (value)=>{\n    if (typeof value === 'string') return value.replace(' ', 'T');\n    return value;\n};\n\n\nvar $b5dc48dc7c306f35$exports = {};\nvar $b5dc48dc7c306f35$var$_globalThis;\n\nif (typeof globalThis === 'object') $b5dc48dc7c306f35$var$_globalThis = globalThis;\nelse try {\n    $b5dc48dc7c306f35$var$_globalThis = (parcelRequire(\"1EZeK\"));\n} catch (error) {} finally{\n    if (!$b5dc48dc7c306f35$var$_globalThis && typeof window !== 'undefined') $b5dc48dc7c306f35$var$_globalThis = window;\n    if (!$b5dc48dc7c306f35$var$_globalThis) throw new Error('Could not determine global this');\n}\nvar $b5dc48dc7c306f35$var$NativeWebSocket = $b5dc48dc7c306f35$var$_globalThis.WebSocket || $b5dc48dc7c306f35$var$_globalThis.MozWebSocket;\nvar $5ac4442c13841201$exports = {};\n\n$5ac4442c13841201$exports = (parcelRequire(\"ln8A6\")).version;\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */ function $b5dc48dc7c306f35$var$W3CWebSocket(uri, protocols) {\n    var native_instance;\n    if (protocols) native_instance = new $b5dc48dc7c306f35$var$NativeWebSocket(uri, protocols);\n    else native_instance = new $b5dc48dc7c306f35$var$NativeWebSocket(uri);\n    /**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */ return native_instance;\n}\nif ($b5dc48dc7c306f35$var$NativeWebSocket) [\n    'CONNECTING',\n    'OPEN',\n    'CLOSING',\n    'CLOSED'\n].forEach(function(prop) {\n    Object.defineProperty($b5dc48dc7c306f35$var$W3CWebSocket, prop, {\n        get: function() {\n            return $b5dc48dc7c306f35$var$NativeWebSocket[prop];\n        }\n    });\n});\n/**\n * Module exports.\n */ $b5dc48dc7c306f35$exports = {\n    'w3cwebsocket': $b5dc48dc7c306f35$var$NativeWebSocket ? $b5dc48dc7c306f35$var$W3CWebSocket : null,\n    'version': $5ac4442c13841201$exports\n};\n\n\nconst $4cff20d240de2de4$export$83d89fbfd8236492 = '1.7.5';\n\n\nconst $3d531e63e1ea7f53$export$88a84136db6a4b64 = {\n    'X-Client-Info': `realtime-js/${(0, $4cff20d240de2de4$export$83d89fbfd8236492)}`\n};\nconst $3d531e63e1ea7f53$export$df3f558bb9a9c991 = '1.0.0';\nconst $3d531e63e1ea7f53$export$7bd623b29ec8e1eb = 10000;\nconst $3d531e63e1ea7f53$export$5e80cf62e56a877b = 1000;\nvar $3d531e63e1ea7f53$export$a6d0320a1563d49e;\n(function(SOCKET_STATES) {\n    SOCKET_STATES[SOCKET_STATES[\"connecting\"] = 0] = \"connecting\";\n    SOCKET_STATES[SOCKET_STATES[\"open\"] = 1] = \"open\";\n    SOCKET_STATES[SOCKET_STATES[\"closing\"] = 2] = \"closing\";\n    SOCKET_STATES[SOCKET_STATES[\"closed\"] = 3] = \"closed\";\n})($3d531e63e1ea7f53$export$a6d0320a1563d49e || ($3d531e63e1ea7f53$export$a6d0320a1563d49e = {}));\nvar $3d531e63e1ea7f53$export$b83816118db74fe7;\n(function(CHANNEL_STATES) {\n    CHANNEL_STATES[\"closed\"] = \"closed\";\n    CHANNEL_STATES[\"errored\"] = \"errored\";\n    CHANNEL_STATES[\"joined\"] = \"joined\";\n    CHANNEL_STATES[\"joining\"] = \"joining\";\n    CHANNEL_STATES[\"leaving\"] = \"leaving\";\n})($3d531e63e1ea7f53$export$b83816118db74fe7 || ($3d531e63e1ea7f53$export$b83816118db74fe7 = {}));\nvar $3d531e63e1ea7f53$export$8db7548e65d6ea55;\n(function(CHANNEL_EVENTS) {\n    CHANNEL_EVENTS[\"close\"] = \"phx_close\";\n    CHANNEL_EVENTS[\"error\"] = \"phx_error\";\n    CHANNEL_EVENTS[\"join\"] = \"phx_join\";\n    CHANNEL_EVENTS[\"reply\"] = \"phx_reply\";\n    CHANNEL_EVENTS[\"leave\"] = \"phx_leave\";\n    CHANNEL_EVENTS[\"access_token\"] = \"access_token\";\n})($3d531e63e1ea7f53$export$8db7548e65d6ea55 || ($3d531e63e1ea7f53$export$8db7548e65d6ea55 = {}));\nvar $3d531e63e1ea7f53$export$b2688bfb999f5751;\n(function(TRANSPORTS) {\n    TRANSPORTS[\"websocket\"] = \"websocket\";\n})($3d531e63e1ea7f53$export$b2688bfb999f5751 || ($3d531e63e1ea7f53$export$b2688bfb999f5751 = {}));\nvar $3d531e63e1ea7f53$export$deda39003d27273;\n(function(CONNECTION_STATE) {\n    CONNECTION_STATE[\"Connecting\"] = \"connecting\";\n    CONNECTION_STATE[\"Open\"] = \"open\";\n    CONNECTION_STATE[\"Closing\"] = \"closing\";\n    CONNECTION_STATE[\"Closed\"] = \"closed\";\n})($3d531e63e1ea7f53$export$deda39003d27273 || ($3d531e63e1ea7f53$export$deda39003d27273 = {}));\n\n\n/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */ class $505c2b2d07197e20$export$2e2bcd8739ae039 {\n    constructor(callback, timerCalc){\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n        this.timer = undefined;\n        this.tries = 0;\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n    }\n    reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n    }\n    // Cancels any previous scheduleTimeout and schedules callback\n    scheduleTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(()=>{\n            this.tries = this.tries + 1;\n            this.callback();\n        }, this.timerCalc(this.tries + 1));\n    }\n}\n\n\n// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe\n// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md\nclass $6805f7080ae1d67f$export$2e2bcd8739ae039 {\n    constructor(){\n        this.HEADER_LENGTH = 1;\n    }\n    decode(rawPayload, callback) {\n        if (rawPayload.constructor === ArrayBuffer) return callback(this._binaryDecode(rawPayload));\n        if (typeof rawPayload === 'string') return callback(JSON.parse(rawPayload));\n        return callback({});\n    }\n    _binaryDecode(buffer) {\n        const view = new DataView(buffer);\n        const decoder = new TextDecoder();\n        return this._decodeBroadcast(buffer, view, decoder);\n    }\n    _decodeBroadcast(buffer, view, decoder) {\n        const topicSize = view.getUint8(1);\n        const eventSize = view.getUint8(2);\n        let offset = this.HEADER_LENGTH + 2;\n        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n        offset = offset + topicSize;\n        const event = decoder.decode(buffer.slice(offset, offset + eventSize));\n        offset = offset + eventSize;\n        const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));\n        return {\n            ref: null,\n            topic: topic,\n            event: event,\n            payload: data\n        };\n    }\n}\n\n\n\n\nclass $9b541112b15eb31d$export$2e2bcd8739ae039 {\n    /**\n     * Initializes the Push\n     *\n     * @param channel The Channel\n     * @param event The event, for example `\"phx_join\"`\n     * @param payload The payload, for example `{user_id: 123}`\n     * @param timeout The push timeout in milliseconds\n     */ constructor(channel, event, payload = {}, timeout = (0, $3d531e63e1ea7f53$export$7bd623b29ec8e1eb)){\n        this.channel = channel;\n        this.event = event;\n        this.payload = payload;\n        this.timeout = timeout;\n        this.sent = false;\n        this.timeoutTimer = undefined;\n        this.ref = '';\n        this.receivedResp = null;\n        this.recHooks = [];\n        this.refEvent = null;\n    }\n    resend(timeout) {\n        this.timeout = timeout;\n        this._cancelRefEvent();\n        this.ref = '';\n        this.refEvent = null;\n        this.receivedResp = null;\n        this.sent = false;\n        this.send();\n    }\n    send() {\n        if (this._hasReceived('timeout')) return;\n        this.startTimeout();\n        this.sent = true;\n        this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload,\n            ref: this.ref,\n            join_ref: this.channel.joinRef()\n        });\n    }\n    updatePayload(payload) {\n        this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n    receive(status, callback) {\n        var _a;\n        if (this._hasReceived(status)) callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n        this.recHooks.push({\n            status: status,\n            callback: callback\n        });\n        return this;\n    }\n    startTimeout() {\n        if (this.timeoutTimer) return;\n        this.ref = this.channel.socket.makeRef();\n        this.refEvent = this.channel.replyEventName(this.ref);\n        const callback = (payload)=>{\n            this._cancelRefEvent();\n            this._cancelTimeout();\n            this.receivedResp = payload;\n            this._matchReceive(payload);\n        };\n        this.channel.on(this.refEvent, callback);\n        this.timeoutTimer = setTimeout(()=>{\n            this.trigger('timeout', {});\n        }, this.timeout);\n    }\n    trigger(status, response) {\n        if (this.refEvent) this.channel.trigger(this.refEvent, {\n            status: status,\n            response: response\n        });\n    }\n    destroy() {\n        this._cancelRefEvent();\n        this._cancelTimeout();\n    }\n    _cancelRefEvent() {\n        if (!this.refEvent) return;\n        this.channel.off(this.refEvent);\n    }\n    _cancelTimeout() {\n        clearTimeout(this.timeoutTimer);\n        this.timeoutTimer = undefined;\n    }\n    _matchReceive({ status: status, response: response }) {\n        this.recHooks.filter((h)=>h.status === status).forEach((h)=>h.callback(response));\n    }\n    _hasReceived(status) {\n        return this.receivedResp && this.receivedResp.status === status;\n    }\n}\n\n\n\nclass $ce3c1d0e07dc916d$export$2e2bcd8739ae039 {\n    constructor(topic, params = {}, socket){\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = [];\n        this.state = (0, $3d531e63e1ea7f53$export$b83816118db74fe7).closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.timeout = this.socket.timeout;\n        this.joinPush = new (0, $9b541112b15eb31d$export$2e2bcd8739ae039)(this, (0, $3d531e63e1ea7f53$export$8db7548e65d6ea55).join, this.params, this.timeout);\n        this.rejoinTimer = new (0, $505c2b2d07197e20$export$2e2bcd8739ae039)(()=>this.rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive('ok', ()=>{\n            this.state = (0, $3d531e63e1ea7f53$export$b83816118db74fe7).joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent)=>pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this.onClose(()=>{\n            this.rejoinTimer.reset();\n            this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`);\n            this.state = (0, $3d531e63e1ea7f53$export$b83816118db74fe7).closed;\n            this.socket.remove(this);\n        });\n        this.onError((reason)=>{\n            if (this.isLeaving() || this.isClosed()) return;\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = (0, $3d531e63e1ea7f53$export$b83816118db74fe7).errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('timeout', ()=>{\n            if (!this.isJoining()) return;\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = (0, $3d531e63e1ea7f53$export$b83816118db74fe7).errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.on((0, $3d531e63e1ea7f53$export$8db7548e65d6ea55).reply, (payload, ref)=>{\n            this.trigger(this.replyEventName(ref), payload);\n        });\n    }\n    rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) this.rejoin();\n    }\n    subscribe(timeout = this.timeout) {\n        if (this.joinedOnce) throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n        else {\n            this.joinedOnce = true;\n            this.rejoin(timeout);\n            return this.joinPush;\n        }\n    }\n    onClose(callback) {\n        this.on((0, $3d531e63e1ea7f53$export$8db7548e65d6ea55).close, callback);\n    }\n    onError(callback) {\n        this.on((0, $3d531e63e1ea7f53$export$8db7548e65d6ea55).error, (reason)=>callback(reason));\n    }\n    on(event, callback) {\n        this.bindings.push({\n            event: event,\n            callback: callback\n        });\n    }\n    off(event) {\n        this.bindings = this.bindings.filter((bind)=>bind.event !== event);\n    }\n    canPush() {\n        return this.socket.isConnected() && this.isJoined();\n    }\n    push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        let pushEvent = new (0, $9b541112b15eb31d$export$2e2bcd8739ae039)(this, event, payload, timeout);\n        if (this.canPush()) pushEvent.send();\n        else {\n            pushEvent.startTimeout();\n            this.pushBuffer.push(pushEvent);\n        }\n        return pushEvent;\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */ unsubscribe(timeout = this.timeout) {\n        this.state = (0, $3d531e63e1ea7f53$export$b83816118db74fe7).leaving;\n        let onClose = ()=>{\n            this.socket.log('channel', `leave ${this.topic}`);\n            this.trigger((0, $3d531e63e1ea7f53$export$8db7548e65d6ea55).close, 'leave', this.joinRef());\n        };\n        // Destroy joinPush to avoid connection timeouts during unscription phase\n        this.joinPush.destroy();\n        let leavePush = new (0, $9b541112b15eb31d$export$2e2bcd8739ae039)(this, (0, $3d531e63e1ea7f53$export$8db7548e65d6ea55).leave, {}, timeout);\n        leavePush.receive('ok', ()=>onClose()).receive('timeout', ()=>onClose());\n        leavePush.send();\n        if (!this.canPush()) leavePush.trigger('ok', {});\n        return leavePush;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     */ onMessage(event, payload, ref) {\n        return payload;\n    }\n    isMember(topic) {\n        return this.topic === topic;\n    }\n    joinRef() {\n        return this.joinPush.ref;\n    }\n    rejoin(timeout = this.timeout) {\n        if (this.isLeaving()) return;\n        this.socket.leaveOpenTopic(this.topic);\n        this.state = (0, $3d531e63e1ea7f53$export$b83816118db74fe7).joining;\n        this.joinPush.resend(timeout);\n    }\n    trigger(event, payload, ref) {\n        let { close: close, error: error, leave: leave, join: join } = (0, $3d531e63e1ea7f53$export$8db7548e65d6ea55);\n        let events = [\n            close,\n            error,\n            leave,\n            join\n        ];\n        if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) return;\n        let handledPayload = this.onMessage(event, payload, ref);\n        if (payload && !handledPayload) throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n        this.bindings.filter((bind)=>{\n            // Bind all events if the user specifies a wildcard.\n            if (bind.event === '*') return event === (payload === null || payload === void 0 ? void 0 : payload.type);\n            else return bind.event === event;\n        }).map((bind)=>bind.callback(handledPayload, ref));\n    }\n    replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    isClosed() {\n        return this.state === (0, $3d531e63e1ea7f53$export$b83816118db74fe7).closed;\n    }\n    isErrored() {\n        return this.state === (0, $3d531e63e1ea7f53$export$b83816118db74fe7).errored;\n    }\n    isJoined() {\n        return this.state === (0, $3d531e63e1ea7f53$export$b83816118db74fe7).joined;\n    }\n    isJoining() {\n        return this.state === (0, $3d531e63e1ea7f53$export$b83816118db74fe7).joining;\n    }\n    isLeaving() {\n        return this.state === (0, $3d531e63e1ea7f53$export$b83816118db74fe7).leaving;\n    }\n}\n\n\nvar $ae049384a7d1c7c8$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst $ae049384a7d1c7c8$var$noop = ()=>{};\nclass $ae049384a7d1c7c8$export$2e2bcd8739ae039 {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket.\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers The optional headers to pass when connecting.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     */ constructor(endPoint, options){\n        this.accessToken = null;\n        this.channels = [];\n        this.endPoint = '';\n        this.headers = (0, $3d531e63e1ea7f53$export$88a84136db6a4b64);\n        this.params = {};\n        this.timeout = (0, $3d531e63e1ea7f53$export$7bd623b29ec8e1eb);\n        this.transport = (0, $b5dc48dc7c306f35$exports.w3cwebsocket);\n        this.heartbeatIntervalMs = 30000;\n        this.longpollerTimeout = 20000;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.ref = 0;\n        this.logger = $ae049384a7d1c7c8$var$noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new (0, $6805f7080ae1d67f$export$2e2bcd8739ae039)();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: []\n        };\n        this.endPoint = `${endPoint}/${(0, $3d531e63e1ea7f53$export$b2688bfb999f5751).websocket}`;\n        if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n        if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n        if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n        if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n        if (options === null || options === void 0 ? void 0 : options.longpollerTimeout) this.longpollerTimeout = options.longpollerTimeout;\n        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : (tries)=>{\n            return [\n                1000,\n                2000,\n                5000,\n                10000\n            ][tries - 1] || 10000;\n        };\n        this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback)=>{\n            return callback(JSON.stringify(payload));\n        };\n        this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n        this.reconnectTimer = new (0, $505c2b2d07197e20$export$2e2bcd8739ae039)(()=>$ae049384a7d1c7c8$var$__awaiter(this, void 0, void 0, function*() {\n                yield this.disconnect();\n                this.connect();\n            }), this.reconnectAfterMs);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */ connect() {\n        if (this.conn) return;\n        this.conn = new this.transport(this.endPointURL(), [], null, this.headers);\n        if (this.conn) {\n            // this.conn.timeout = this.longpollerTimeout // TYPE ERROR\n            this.conn.binaryType = 'arraybuffer';\n            this.conn.onopen = ()=>this._onConnOpen();\n            this.conn.onerror = (error)=>this._onConnError(error);\n            this.conn.onmessage = (event)=>this.onConnMessage(event);\n            this.conn.onclose = (event)=>this._onConnClose(event);\n        }\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */ disconnect(code, reason) {\n        return new Promise((resolve, _reject)=>{\n            try {\n                if (this.conn) {\n                    this.conn.onclose = function() {}; // noop\n                    if (code) this.conn.close(code, reason || '');\n                    else this.conn.close();\n                    this.conn = null;\n                    // remove open handles\n                    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n                    this.reconnectTimer.reset();\n                }\n                resolve({\n                    error: null,\n                    data: true\n                });\n            } catch (error) {\n                resolve({\n                    error: error,\n                    data: false\n                });\n            }\n        });\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overriden.\n     */ log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Registers a callback for connection state change event.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen(() => console.log(\"Socket opened.\"))\n     */ onOpen(callback) {\n        this.stateChangeCallbacks.open.push(callback);\n    }\n    /**\n     * Registers a callback for connection state change events.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen(() => console.log(\"Socket closed.\"))\n     */ onClose(callback) {\n        this.stateChangeCallbacks.close.push(callback);\n    }\n    /**\n     * Registers a callback for connection state change events.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen((error) => console.log(\"An error occurred\"))\n     */ onError(callback) {\n        this.stateChangeCallbacks.error.push(callback);\n    }\n    /**\n     * Calls a function any time a message is received.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onMessage((message) => console.log(message))\n     */ onMessage(callback) {\n        this.stateChangeCallbacks.message.push(callback);\n    }\n    /**\n     * Returns the current state of the socket.\n     */ connectionState() {\n        switch(this.conn && this.conn.readyState){\n            case (0, $3d531e63e1ea7f53$export$a6d0320a1563d49e).connecting:\n                return (0, $3d531e63e1ea7f53$export$deda39003d27273).Connecting;\n            case (0, $3d531e63e1ea7f53$export$a6d0320a1563d49e).open:\n                return (0, $3d531e63e1ea7f53$export$deda39003d27273).Open;\n            case (0, $3d531e63e1ea7f53$export$a6d0320a1563d49e).closing:\n                return (0, $3d531e63e1ea7f53$export$deda39003d27273).Closing;\n            default:\n                return (0, $3d531e63e1ea7f53$export$deda39003d27273).Closed;\n        }\n    }\n    /**\n     * Retuns `true` is the connection is open.\n     */ isConnected() {\n        return this.connectionState() === (0, $3d531e63e1ea7f53$export$deda39003d27273).Open;\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     */ remove(channel) {\n        this.channels = this.channels.filter((c)=>c.joinRef() !== channel.joinRef());\n    }\n    channel(topic, chanParams = {}) {\n        const chan = new (0, $ce3c1d0e07dc916d$export$2e2bcd8739ae039)(topic, chanParams, this);\n        this.channels.push(chan);\n        return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */ push(data) {\n        const { topic: topic, event: event, payload: payload, ref: ref } = data;\n        let callback = ()=>{\n            this.encode(data, (result)=>{\n                var _a;\n                (_a = this.conn) === null || _a === void 0 || _a.send(result);\n            });\n        };\n        this.log('push', `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) callback();\n        else this.sendBuffer.push(callback);\n    }\n    onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg)=>{\n            let { topic: topic, event: event, payload: payload, ref: ref } = msg;\n            if (ref && ref === this.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) this.pendingHeartbeatRef = null;\n            this.log('receive', `${payload.status || ''} ${topic} ${event} ${ref && '(' + ref + ')' || ''}`, payload);\n            this.channels.filter((channel)=>channel.isMember(topic)).forEach((channel)=>channel.trigger(event, payload, ref));\n            this.stateChangeCallbacks.message.forEach((callback)=>callback(msg));\n        });\n    }\n    /**\n     * Returns the URL of the websocket.\n     */ endPointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n            vsn: (0, $3d531e63e1ea7f53$export$df3f558bb9a9c991)\n        }));\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     */ makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) this.ref = 0;\n        else this.ref = newRef;\n        return this.ref.toString();\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */ setAuth(token) {\n        this.accessToken = token;\n        this.channels.forEach((channel)=>{\n            token && channel.updateJoinPayload({\n                user_token: token\n            });\n            if (channel.joinedOnce && channel.isJoined()) channel.push((0, $3d531e63e1ea7f53$export$8db7548e65d6ea55).access_token, {\n                access_token: token\n            });\n        });\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     */ leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c)=>c.topic === topic && (c.isJoined() || c.isJoining()));\n        if (dupChannel) {\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    _onConnOpen() {\n        this.log('transport', `connected to ${this.endPointURL()}`);\n        this._flushSendBuffer();\n        this.reconnectTimer.reset();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(()=>this._sendHeartbeat(), this.heartbeatIntervalMs);\n        this.stateChangeCallbacks.open.forEach((callback)=>callback());\n    }\n    _onConnClose(event) {\n        this.log('transport', 'close', event);\n        this._triggerChanError();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.scheduleTimeout();\n        this.stateChangeCallbacks.close.forEach((callback)=>callback(event));\n    }\n    _onConnError(error) {\n        this.log('transport', error.message);\n        this._triggerChanError();\n        this.stateChangeCallbacks.error.forEach((callback)=>callback(error));\n    }\n    _triggerChanError() {\n        this.channels.forEach((channel)=>channel.trigger((0, $3d531e63e1ea7f53$export$8db7548e65d6ea55).error));\n    }\n    _appendParams(url, params) {\n        if (Object.keys(params).length === 0) return url;\n        const prefix = url.match(/\\?/) ? '&' : '?';\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    _flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback)=>callback());\n            this.sendBuffer = [];\n        }\n    }\n    _sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) return;\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n            (_a = this.conn) === null || _a === void 0 || _a.close((0, $3d531e63e1ea7f53$export$5e80cf62e56a877b), 'hearbeat timeout');\n            return;\n        }\n        this.pendingHeartbeatRef = this.makeRef();\n        this.push({\n            topic: 'phoenix',\n            event: 'heartbeat',\n            payload: {},\n            ref: this.pendingHeartbeatRef\n        });\n        this.setAuth(this.accessToken);\n    }\n}\n\n\n\n\n\nclass $4f581467803a2661$export$a1c0cbe03b169679 {\n    constructor(socket, headers, schema, tableName){\n        const chanParams = {};\n        const topic = tableName === '*' ? `realtime:${schema}` : `realtime:${schema}:${tableName}`;\n        const userToken = headers['Authorization'].split(' ')[1];\n        if (userToken) chanParams['user_token'] = userToken;\n        this.subscription = socket.channel(topic, chanParams);\n    }\n    getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {}\n        };\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') records.new = (0, $3f01feefa94fd48b$exports).convertChangeData(payload.columns, payload.record);\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') records.old = (0, $3f01feefa94fd48b$exports).convertChangeData(payload.columns, payload.old_record);\n        return records;\n    }\n    /**\n     * The event you want to listen to.\n     *\n     * @param event The event\n     * @param callback A callback function that is called whenever the event occurs.\n     */ on(event, callback) {\n        this.subscription.on(event, (payload)=>{\n            let enrichedPayload = {\n                schema: payload.schema,\n                table: payload.table,\n                commit_timestamp: payload.commit_timestamp,\n                eventType: payload.type,\n                new: {},\n                old: {},\n                errors: payload.errors\n            };\n            enrichedPayload = Object.assign(Object.assign({}, enrichedPayload), this.getPayloadRecords(payload));\n            callback(enrichedPayload);\n        });\n        return this;\n    }\n    /**\n     * Enables the subscription.\n     */ subscribe(callback = ()=>{}) {\n        this.subscription.onError((e)=>callback('SUBSCRIPTION_ERROR', e));\n        this.subscription.onClose(()=>callback('CLOSED'));\n        this.subscription.subscribe().receive('ok', ()=>callback('SUBSCRIBED')).receive('error', (e)=>callback('SUBSCRIPTION_ERROR', e)).receive('timeout', ()=>callback('RETRYING_AFTER_TIMEOUT'));\n        return this.subscription;\n    }\n}\n\n\nclass $eabf44873eaa7c75$export$d6b56fa12d975d17 extends (0, $c0d502ff80704788$export$2e2bcd8739ae039) {\n    constructor(url, { headers: headers = {}, schema: schema, realtime: realtime, table: table, fetch: fetch, shouldThrowOnError: shouldThrowOnError }){\n        super(url, {\n            headers: headers,\n            schema: schema,\n            fetch: fetch,\n            shouldThrowOnError: shouldThrowOnError\n        });\n        this._subscription = null;\n        this._realtime = realtime;\n        this._headers = headers;\n        this._schema = schema;\n        this._table = table;\n    }\n    /**\n     * Subscribe to realtime changes in your database.\n     * @param event The database event which you would like to receive updates for, or you can use the special wildcard `*` to listen to all changes.\n     * @param callback A callback that will handle the payload that is sent whenever your database changes.\n     */ on(event, callback) {\n        if (!this._realtime.isConnected()) this._realtime.connect();\n        if (!this._subscription) this._subscription = new (0, $4f581467803a2661$export$a1c0cbe03b169679)(this._realtime, this._headers, this._schema, this._table);\n        return this._subscription.on(event, callback);\n    }\n}\n\n\n// generated by genversion\nconst $a02d8046733ee147$export$83d89fbfd8236492 = '1.7.3';\n\n\nconst $f4c4e1deae4025ef$export$88a84136db6a4b64 = {\n    'X-Client-Info': `storage-js/${(0, $a02d8046733ee147$export$83d89fbfd8236492)}`\n};\n\n\nvar $2ad35efa1b333042$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst $2ad35efa1b333042$var$_getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst $2ad35efa1b333042$var$handleError = (error, reject)=>{\n    if (typeof error.json !== 'function') return reject(error);\n    error.json().then((err)=>{\n        return reject({\n            message: $2ad35efa1b333042$var$_getErrorMessage(err),\n            status: (error === null || error === void 0 ? void 0 : error.status) || 500\n        });\n    });\n};\nconst $2ad35efa1b333042$var$_getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method: method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === 'GET') return params;\n    params.headers = Object.assign({\n        'Content-Type': 'application/json'\n    }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return Object.assign(Object.assign({}, params), parameters);\n};\nfunction $2ad35efa1b333042$var$_handleRequest(fetcher, method, url, options, parameters, body) {\n    return $2ad35efa1b333042$var$__awaiter(this, void 0, void 0, function*() {\n        return new Promise((resolve, reject)=>{\n            fetcher(url, $2ad35efa1b333042$var$_getRequestParams(method, options, parameters, body)).then((result)=>{\n                if (!result.ok) throw result;\n                if (options === null || options === void 0 ? void 0 : options.noResolveJson) return resolve(result);\n                return result.json();\n            }).then((data)=>resolve(data)).catch((error)=>$2ad35efa1b333042$var$handleError(error, reject));\n        });\n    });\n}\nfunction $2ad35efa1b333042$export$3988ae62b71be9a3(fetcher, url, options, parameters) {\n    return $2ad35efa1b333042$var$__awaiter(this, void 0, void 0, function*() {\n        return $2ad35efa1b333042$var$_handleRequest(fetcher, 'GET', url, options, parameters);\n    });\n}\nfunction $2ad35efa1b333042$export$299ba2dee77727e9(fetcher, url, body, options, parameters) {\n    return $2ad35efa1b333042$var$__awaiter(this, void 0, void 0, function*() {\n        return $2ad35efa1b333042$var$_handleRequest(fetcher, 'POST', url, options, parameters, body);\n    });\n}\nfunction $2ad35efa1b333042$export$327f7b26ebf455db(fetcher, url, body, options, parameters) {\n    return $2ad35efa1b333042$var$__awaiter(this, void 0, void 0, function*() {\n        return $2ad35efa1b333042$var$_handleRequest(fetcher, 'PUT', url, options, parameters, body);\n    });\n}\nfunction $2ad35efa1b333042$export$cd7f480d6b8286c3(fetcher, url, body, options, parameters) {\n    return $2ad35efa1b333042$var$__awaiter(this, void 0, void 0, function*() {\n        return $2ad35efa1b333042$var$_handleRequest(fetcher, 'DELETE', url, options, parameters, body);\n    });\n}\n\n\nvar $b8abd4fb4763e533$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nconst $b8abd4fb4763e533$export$98d92b1aa79f8cc7 = (customFetch)=>{\n    let _fetch;\n    if (customFetch) _fetch = customFetch;\n    else if (typeof fetch === 'undefined') _fetch = (...args)=>$b8abd4fb4763e533$var$__awaiter(void 0, void 0, void 0, function*() {\n            return yield (yield (parcelRequire(\"6s4wM\"))).fetch(...args);\n        });\n    else _fetch = fetch;\n    return (...args)=>_fetch(...args);\n};\n\n\nvar $68d30606960d068a$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass $68d30606960d068a$export$698875e798f36d2d {\n    constructor(url, headers = {}, fetch){\n        this.url = url;\n        this.headers = Object.assign(Object.assign({}, (0, $f4c4e1deae4025ef$export$88a84136db6a4b64)), headers);\n        this.fetch = (0, $b8abd4fb4763e533$export$98d92b1aa79f8cc7)(fetch);\n    }\n    /**\n     * Retrieves the details of all Storage buckets within an existing project.\n     */ listBuckets() {\n        return $68d30606960d068a$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $2ad35efa1b333042$export$3988ae62b71be9a3)(this.fetch, `${this.url}/bucket`, {\n                    headers: this.headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error\n                };\n            }\n        });\n    }\n    /**\n     * Retrieves the details of an existing Storage bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to retrieve.\n     */ getBucket(id) {\n        return $68d30606960d068a$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $2ad35efa1b333042$export$3988ae62b71be9a3)(this.fetch, `${this.url}/bucket/${id}`, {\n                    headers: this.headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error\n                };\n            }\n        });\n    }\n    /**\n     * Creates a new Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are creating.\n     * @returns newly created bucket id\n     */ createBucket(id, options = {\n        public: false\n    }) {\n        return $68d30606960d068a$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $2ad35efa1b333042$export$299ba2dee77727e9)(this.fetch, `${this.url}/bucket`, {\n                    id: id,\n                    name: id,\n                    public: options.public\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data: data.name,\n                    error: null\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error\n                };\n            }\n        });\n    }\n    /**\n     * Updates a new Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are updating.\n     */ updateBucket(id, options) {\n        return $68d30606960d068a$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $2ad35efa1b333042$export$327f7b26ebf455db)(this.fetch, `${this.url}/bucket/${id}`, {\n                    id: id,\n                    name: id,\n                    public: options.public\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error\n                };\n            }\n        });\n    }\n    /**\n     * Removes all objects inside a single bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to empty.\n     */ emptyBucket(id) {\n        return $68d30606960d068a$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $2ad35efa1b333042$export$299ba2dee77727e9)(this.fetch, `${this.url}/bucket/${id}/empty`, {}, {\n                    headers: this.headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error\n                };\n            }\n        });\n    }\n    /**\n     * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n     * You must first `empty()` the bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to delete.\n     */ deleteBucket(id) {\n        return $68d30606960d068a$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $2ad35efa1b333042$export$cd7f480d6b8286c3)(this.fetch, `${this.url}/bucket/${id}`, {}, {\n                    headers: this.headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error\n                };\n            }\n        });\n    }\n}\n\n\n\nvar $6c2c44af3462c2fe$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst $6c2c44af3462c2fe$var$DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: 'name',\n        order: 'asc'\n    }\n};\nconst $6c2c44af3462c2fe$var$DEFAULT_FILE_OPTIONS = {\n    cacheControl: '3600',\n    contentType: 'text/plain;charset=UTF-8',\n    upsert: false\n};\nclass $6c2c44af3462c2fe$export$f62f1779c09b9522 {\n    constructor(url, headers = {}, bucketId, fetch){\n        this.url = url;\n        this.headers = headers;\n        this.bucketId = bucketId;\n        this.fetch = (0, $b8abd4fb4763e533$export$98d92b1aa79f8cc7)(fetch);\n    }\n    /**\n     * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n     *\n     * @param method HTTP method.\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     * @param fileOptions HTTP headers.\n     * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n     * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n     * `upsert`: boolean, whether to perform an upsert.\n     */ uploadOrUpdate(method, path, fileBody, fileOptions) {\n        return $6c2c44af3462c2fe$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                let body;\n                const options = Object.assign(Object.assign({}, $6c2c44af3462c2fe$var$DEFAULT_FILE_OPTIONS), fileOptions);\n                const headers = Object.assign(Object.assign({}, this.headers), method === 'POST' && {\n                    'x-upsert': String(options.upsert)\n                });\n                if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n                    body = new FormData();\n                    body.append('cacheControl', options.cacheControl);\n                    body.append('', fileBody);\n                } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n                    body = fileBody;\n                    body.append('cacheControl', options.cacheControl);\n                } else {\n                    body = fileBody;\n                    headers['cache-control'] = `max-age=${options.cacheControl}`;\n                    headers['content-type'] = options.contentType;\n                }\n                const cleanPath = this._removeEmptyFolders(path);\n                const _path = this._getFinalPath(cleanPath);\n                const res = yield this.fetch(`${this.url}/object/${_path}`, {\n                    method: method,\n                    body: body,\n                    headers: headers\n                });\n                if (res.ok) // const data = await res.json()\n                // temporary fix till backend is updated to the latest storage-api version\n                return {\n                    data: {\n                        Key: _path\n                    },\n                    error: null\n                };\n                else {\n                    const error = yield res.json();\n                    return {\n                        data: null,\n                        error: error\n                    };\n                }\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error\n                };\n            }\n        });\n    }\n    /**\n     * Uploads a file to an existing bucket.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     * @param fileOptions HTTP headers.\n     * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n     * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n     * `upsert`: boolean, whether to perform an upsert.\n     */ upload(path, fileBody, fileOptions) {\n        return $6c2c44af3462c2fe$var$__awaiter(this, void 0, void 0, function*() {\n            return this.uploadOrUpdate('POST', path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Replaces an existing file at the specified path with a new one.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     * @param fileOptions HTTP headers.\n     * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n     * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n     * `upsert`: boolean, whether to perform an upsert.\n     */ update(path, fileBody, fileOptions) {\n        return $6c2c44af3462c2fe$var$__awaiter(this, void 0, void 0, function*() {\n            return this.uploadOrUpdate('PUT', path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Moves an existing file.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n     */ move(fromPath, toPath) {\n        return $6c2c44af3462c2fe$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $2ad35efa1b333042$export$299ba2dee77727e9)(this.fetch, `${this.url}/object/move`, {\n                    bucketId: this.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error\n                };\n            }\n        });\n    }\n    /**\n     * Copies an existing file.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n     */ copy(fromPath, toPath) {\n        return $6c2c44af3462c2fe$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $2ad35efa1b333042$export$299ba2dee77727e9)(this.fetch, `${this.url}/object/copy`, {\n                    bucketId: this.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error\n                };\n            }\n        });\n    }\n    /**\n     * Create signed URL to download file without requiring permissions. This URL can be valid for a set number of seconds.\n     *\n     * @param path The file path to be downloaded, including the current file name. For example `folder/image.png`.\n     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n     */ createSignedUrl(path, expiresIn) {\n        return $6c2c44af3462c2fe$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const _path = this._getFinalPath(path);\n                let data = yield (0, $2ad35efa1b333042$export$299ba2dee77727e9)(this.fetch, `${this.url}/object/sign/${_path}`, {\n                    expiresIn: expiresIn\n                }, {\n                    headers: this.headers\n                });\n                const signedURL = `${this.url}${data.signedURL}`;\n                data = {\n                    signedURL: signedURL\n                };\n                return {\n                    data: data,\n                    error: null,\n                    signedURL: signedURL\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error,\n                    signedURL: null\n                };\n            }\n        });\n    }\n    /**\n     * Create signed URLs to download files without requiring permissions. These URLs can be valid for a set number of seconds.\n     *\n     * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n     * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n     */ createSignedUrls(paths, expiresIn) {\n        return $6c2c44af3462c2fe$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $2ad35efa1b333042$export$299ba2dee77727e9)(this.fetch, `${this.url}/object/sign/${this.bucketId}`, {\n                    expiresIn: expiresIn,\n                    paths: paths\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data: data.map((datum)=>Object.assign(Object.assign({}, datum), {\n                            signedURL: datum.signedURL ? `${this.url}${datum.signedURL}` : null\n                        })),\n                    error: null\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error\n                };\n            }\n        });\n    }\n    /**\n     * Downloads a file.\n     *\n     * @param path The file path to be downloaded, including the path and file name. For example `folder/image.png`.\n     */ download(path) {\n        return $6c2c44af3462c2fe$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const _path = this._getFinalPath(path);\n                const res = yield (0, $2ad35efa1b333042$export$3988ae62b71be9a3)(this.fetch, `${this.url}/object/${_path}`, {\n                    headers: this.headers,\n                    noResolveJson: true\n                });\n                const data = yield res.blob();\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error\n                };\n            }\n        });\n    }\n    /**\n     * Retrieve URLs for assets in public buckets\n     *\n     * @param path The file path to be downloaded, including the path and file name. For example `folder/image.png`.\n     */ getPublicUrl(path) {\n        try {\n            const _path = this._getFinalPath(path);\n            const publicURL = `${this.url}/object/public/${_path}`;\n            const data = {\n                publicURL: publicURL\n            };\n            return {\n                data: data,\n                error: null,\n                publicURL: publicURL\n            };\n        } catch (error) {\n            return {\n                data: null,\n                error: error,\n                publicURL: null\n            };\n        }\n    }\n    /**\n     * Deletes files within the same bucket\n     *\n     * @param paths An array of files to be deleted, including the path and file name. For example [`folder/image.png`].\n     */ remove(paths) {\n        return $6c2c44af3462c2fe$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0, $2ad35efa1b333042$export$cd7f480d6b8286c3)(this.fetch, `${this.url}/object/${this.bucketId}`, {\n                    prefixes: paths\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error\n                };\n            }\n        });\n    }\n    /**\n     * Get file metadata\n     * @param id the file id to retrieve metadata\n     */ // async getMetadata(id: string): Promise<{ data: Metadata | null; error: Error | null }> {\n    //   try {\n    //     const data = await get(`${this.url}/metadata/${id}`, { headers: this.headers })\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     return { data: null, error }\n    //   }\n    // }\n    /**\n     * Update file metadata\n     * @param id the file id to update metadata\n     * @param meta the new file metadata\n     */ // async updateMetadata(\n    //   id: string,\n    //   meta: Metadata\n    // ): Promise<{ data: Metadata | null; error: Error | null }> {\n    //   try {\n    //     const data = await post(`${this.url}/metadata/${id}`, { ...meta }, { headers: this.headers })\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     return { data: null, error }\n    //   }\n    // }\n    /**\n     * Lists all the files within a bucket.\n     * @param path The folder path.\n     * @param options Search options, including `limit`, `offset`, `sortBy`, and `search`.\n     * @param parameters Fetch parameters, currently only supports `signal`, which is an AbortController's signal\n     */ list(path, options, parameters) {\n        return $6c2c44af3462c2fe$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const body = Object.assign(Object.assign(Object.assign({}, $6c2c44af3462c2fe$var$DEFAULT_SEARCH_OPTIONS), options), {\n                    prefix: path || ''\n                });\n                const data = yield (0, $2ad35efa1b333042$export$299ba2dee77727e9)(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, {\n                    headers: this.headers\n                }, parameters);\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error\n                };\n            }\n        });\n    }\n    _getFinalPath(path) {\n        return `${this.bucketId}/${path}`;\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/');\n    }\n}\n\n\nclass $3ac213f23af4773a$export$6c85f5032e75eff9 extends (0, $68d30606960d068a$export$698875e798f36d2d) {\n    constructor(url, headers = {}, fetch){\n        super(url, headers, fetch);\n    }\n    /**\n     * Perform file operation in a bucket.\n     *\n     * @param id The bucket id to operate on.\n     */ from(id) {\n        return new (0, $6c2c44af3462c2fe$export$f62f1779c09b9522)(this.url, this.headers, id, this.fetch);\n    }\n}\n\n\nvar $b1b44af3c77a62f9$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nconst $b1b44af3c77a62f9$export$98d92b1aa79f8cc7 = (customFetch)=>{\n    let _fetch;\n    if (customFetch) _fetch = customFetch;\n    else if (typeof fetch === 'undefined') _fetch = (...args)=>$b1b44af3c77a62f9$var$__awaiter(void 0, void 0, void 0, function*() {\n            return yield (yield (parcelRequire(\"6s4wM\"))).fetch(...args);\n        });\n    else _fetch = fetch;\n    return (...args)=>_fetch(...args);\n};\n\n\nvar $a976488f0e157f77$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass $a976488f0e157f77$export$1d0b400bf8a0fa55 {\n    constructor(url, { headers: headers = {}, customFetch: customFetch } = {}){\n        this.url = url;\n        this.headers = headers;\n        this.fetch = (0, $b1b44af3c77a62f9$export$98d92b1aa79f8cc7)(customFetch);\n    }\n    /**\n     * Updates the authorization header\n     * @params token - the new jwt token sent in the authorisation header\n     */ setAuth(token) {\n        this.headers.Authorization = `Bearer ${token}`;\n    }\n    /**\n     * Invokes a function\n     * @param functionName - the name of the function to invoke\n     * @param invokeOptions - object with the following properties\n     * `headers`: object representing the headers to send with the request\n     * `body`: the body of the request\n     * `responseType`: how the response should be parsed. The default is `json`\n     */ invoke(functionName, invokeOptions) {\n        return $a976488f0e157f77$var$__awaiter(this, void 0, void 0, function*() {\n            try {\n                const { headers: headers, body: body } = invokeOptions !== null && invokeOptions !== void 0 ? invokeOptions : {};\n                const response = yield this.fetch(`${this.url}/${functionName}`, {\n                    method: 'POST',\n                    headers: Object.assign({}, this.headers, headers),\n                    body: body\n                });\n                const isRelayError = response.headers.get('x-relay-error');\n                if (isRelayError && isRelayError === 'true') return {\n                    data: null,\n                    error: new Error((yield response.text()))\n                };\n                let data;\n                const { responseType: responseType } = invokeOptions !== null && invokeOptions !== void 0 ? invokeOptions : {};\n                if (!responseType || responseType === 'json') data = yield response.json();\n                else if (responseType === 'arrayBuffer') data = yield response.arrayBuffer();\n                else if (responseType === 'blob') data = yield response.blob();\n                else data = yield response.text();\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error: error\n                };\n            }\n        });\n    }\n}\n\n\n\n\nvar $adb6551412d48394$var$__awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst $adb6551412d48394$var$DEFAULT_OPTIONS = {\n    schema: 'public',\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    multiTab: true,\n    headers: (0, $c0fdce55fc03ad18$export$88a84136db6a4b64)\n};\nclass $adb6551412d48394$export$2e2bcd8739ae039 {\n    /**\n     * Create a new client for use in the browser.\n     * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n     * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n     * @param options.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n     * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.headers Any additional headers to send with each network request.\n     * @param options.realtime Options passed along to realtime-js constructor.\n     * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n     * @param options.fetch A custom fetch implementation.\n     */ constructor(supabaseUrl, supabaseKey, options){\n        this.supabaseUrl = supabaseUrl;\n        this.supabaseKey = supabaseKey;\n        if (!supabaseUrl) throw new Error('supabaseUrl is required.');\n        if (!supabaseKey) throw new Error('supabaseKey is required.');\n        const _supabaseUrl = (0, $0c30a5a89f4b6341$export$d95b4586d238a081)(supabaseUrl);\n        const settings = Object.assign(Object.assign({}, $adb6551412d48394$var$DEFAULT_OPTIONS), options);\n        this.restUrl = `${_supabaseUrl}/rest/v1`;\n        this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace('http', 'ws');\n        this.authUrl = `${_supabaseUrl}/auth/v1`;\n        this.storageUrl = `${_supabaseUrl}/storage/v1`;\n        const isPlatform = _supabaseUrl.match(/(supabase\\.co)|(supabase\\.in)/);\n        if (isPlatform) {\n            const urlParts = _supabaseUrl.split('.');\n            this.functionsUrl = `${urlParts[0]}.functions.${urlParts[1]}.${urlParts[2]}`;\n        } else this.functionsUrl = `${_supabaseUrl}/functions/v1`;\n        this.schema = settings.schema;\n        this.multiTab = settings.multiTab;\n        this.fetch = settings.fetch;\n        this.headers = Object.assign(Object.assign({}, (0, $c0fdce55fc03ad18$export$88a84136db6a4b64)), options === null || options === void 0 ? void 0 : options.headers);\n        this.shouldThrowOnError = settings.shouldThrowOnError || false;\n        this.auth = this._initSupabaseAuthClient(settings);\n        this.realtime = this._initRealtimeClient(Object.assign({\n            headers: this.headers\n        }, settings.realtime));\n        this._listenForAuthEvents();\n        this._listenForMultiTabEvents();\n    // In the future we might allow the user to pass in a logger to receive these events.\n    // this.realtime.onOpen(() => console.log('OPEN'))\n    // this.realtime.onClose(() => console.log('CLOSED'))\n    // this.realtime.onError((e: Error) => console.log('Socket error', e))\n    }\n    /**\n     * Supabase Functions allows you to deploy and invoke edge functions.\n     */ get functions() {\n        return new (0, $a976488f0e157f77$export$1d0b400bf8a0fa55)(this.functionsUrl, {\n            headers: this._getAuthHeaders(),\n            customFetch: this.fetch\n        });\n    }\n    /**\n     * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n     */ get storage() {\n        return new (0, $3ac213f23af4773a$export$6c85f5032e75eff9)(this.storageUrl, this._getAuthHeaders(), this.fetch);\n    }\n    /**\n     * Perform a table operation.\n     *\n     * @param table The table name to operate on.\n     */ from(table) {\n        const url = `${this.restUrl}/${table}`;\n        return new (0, $eabf44873eaa7c75$export$d6b56fa12d975d17)(url, {\n            headers: this._getAuthHeaders(),\n            schema: this.schema,\n            realtime: this.realtime,\n            table: table,\n            fetch: this.fetch,\n            shouldThrowOnError: this.shouldThrowOnError\n        });\n    }\n    /**\n     * Perform a function call.\n     *\n     * @param fn  The function name to call.\n     * @param params  The parameters to pass to the function call.\n     * @param head   When set to true, no data will be returned.\n     * @param count  Count algorithm to use to count rows in a table.\n     *\n     */ rpc(fn, params, { head: head = false, count: count = null } = {}) {\n        const rest = this._initPostgRESTClient();\n        return rest.rpc(fn, params, {\n            head: head,\n            count: count\n        });\n    }\n    /**\n     * Closes and removes all subscriptions and returns a list of removed\n     * subscriptions and their errors.\n     */ removeAllSubscriptions() {\n        return $adb6551412d48394$var$__awaiter(this, void 0, void 0, function*() {\n            const allSubs = this.getSubscriptions().slice();\n            const allSubPromises = allSubs.map((sub)=>this.removeSubscription(sub));\n            const allRemovedSubs = yield Promise.all(allSubPromises);\n            return allRemovedSubs.map(({ error: error }, i)=>{\n                return {\n                    data: {\n                        subscription: allSubs[i]\n                    },\n                    error: error\n                };\n            });\n        });\n    }\n    /**\n     * Closes and removes a subscription and returns the number of open subscriptions.\n     *\n     * @param subscription The subscription you want to close and remove.\n     */ removeSubscription(subscription) {\n        return $adb6551412d48394$var$__awaiter(this, void 0, void 0, function*() {\n            const { error: error } = yield this._closeSubscription(subscription);\n            const allSubs = this.getSubscriptions();\n            const openSubCount = allSubs.filter((chan)=>chan.isJoined()).length;\n            if (allSubs.length === 0) yield this.realtime.disconnect();\n            return {\n                data: {\n                    openSubscriptions: openSubCount\n                },\n                error: error\n            };\n        });\n    }\n    _closeSubscription(subscription) {\n        return $adb6551412d48394$var$__awaiter(this, void 0, void 0, function*() {\n            let error = null;\n            if (!subscription.isClosed()) {\n                const { error: unsubError } = yield this._unsubscribeSubscription(subscription);\n                error = unsubError;\n            }\n            this.realtime.remove(subscription);\n            return {\n                error: error\n            };\n        });\n    }\n    _unsubscribeSubscription(subscription) {\n        return new Promise((resolve)=>{\n            subscription.unsubscribe().receive('ok', ()=>resolve({\n                    error: null\n                })).receive('error', (error)=>resolve({\n                    error: error\n                })).receive('timeout', ()=>resolve({\n                    error: new Error('timed out')\n                }));\n        });\n    }\n    /**\n     * Returns an array of all your subscriptions.\n     */ getSubscriptions() {\n        return this.realtime.channels;\n    }\n    _initSupabaseAuthClient({ autoRefreshToken: autoRefreshToken, persistSession: persistSession, detectSessionInUrl: detectSessionInUrl, localStorage: localStorage, headers: headers, fetch: fetch, cookieOptions: cookieOptions, multiTab: multiTab }) {\n        const authHeaders = {\n            Authorization: `Bearer ${this.supabaseKey}`,\n            apikey: `${this.supabaseKey}`\n        };\n        return new (0, $b6000684d7c6c56c$export$8199a418bb09bd56)({\n            url: this.authUrl,\n            headers: Object.assign(Object.assign({}, headers), authHeaders),\n            autoRefreshToken: autoRefreshToken,\n            persistSession: persistSession,\n            detectSessionInUrl: detectSessionInUrl,\n            localStorage: localStorage,\n            fetch: fetch,\n            cookieOptions: cookieOptions,\n            multiTab: multiTab\n        });\n    }\n    _initRealtimeClient(options) {\n        return new (0, $ae049384a7d1c7c8$export$2e2bcd8739ae039)(this.realtimeUrl, Object.assign(Object.assign({}, options), {\n            params: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.params), {\n                apikey: this.supabaseKey\n            })\n        }));\n    }\n    _initPostgRESTClient() {\n        return new (0, $83c92f94715fb663$export$2e2bcd8739ae039)(this.restUrl, {\n            headers: this._getAuthHeaders(),\n            schema: this.schema,\n            fetch: this.fetch,\n            throwOnError: this.shouldThrowOnError\n        });\n    }\n    _getAuthHeaders() {\n        var _a, _b;\n        const headers = Object.assign({}, this.headers);\n        const authBearer = (_b = (_a = this.auth.session()) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;\n        headers['apikey'] = this.supabaseKey;\n        headers['Authorization'] = headers['Authorization'] || `Bearer ${authBearer}`;\n        return headers;\n    }\n    _listenForMultiTabEvents() {\n        if (!this.multiTab || !(0, $0c30a5a89f4b6341$export$4e09c449d6c407f7)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) return null;\n        try {\n            return window === null || window === void 0 ? void 0 : window.addEventListener('storage', (e)=>{\n                var _a, _b, _c;\n                if (e.key === (0, $c0fdce55fc03ad18$export$86880b4b2e1a2384)) {\n                    const newSession = JSON.parse(String(e.newValue));\n                    const accessToken = (_b = (_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n                    const previousAccessToken = (_c = this.auth.session()) === null || _c === void 0 ? void 0 : _c.access_token;\n                    if (!accessToken) this._handleTokenChanged('SIGNED_OUT', accessToken, 'STORAGE');\n                    else if (!previousAccessToken && accessToken) this._handleTokenChanged('SIGNED_IN', accessToken, 'STORAGE');\n                    else if (previousAccessToken !== accessToken) this._handleTokenChanged('TOKEN_REFRESHED', accessToken, 'STORAGE');\n                }\n            });\n        } catch (error) {\n            console.error('_listenForMultiTabEvents', error);\n            return null;\n        }\n    }\n    _listenForAuthEvents() {\n        let { data: data } = this.auth.onAuthStateChange((event, session)=>{\n            this._handleTokenChanged(event, session === null || session === void 0 ? void 0 : session.access_token, 'CLIENT');\n        });\n        return data;\n    }\n    _handleTokenChanged(event, token, source) {\n        if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') && this.changedAccessToken !== token) {\n            // Token has changed\n            this.realtime.setAuth(token);\n            // Ideally we should call this.auth.recoverSession() - need to make public\n            // to trigger a \"SIGNED_IN\" event on this client.\n            if (source == 'STORAGE') this.auth.setAuth(token);\n            this.changedAccessToken = token;\n        } else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\n            // Token is removed\n            this.realtime.setAuth(this.supabaseKey);\n            if (source == 'STORAGE') this.auth.signOut();\n        }\n    }\n}\n\n\n\n\n/**\n * Creates a new Supabase Client.\n */ const $99dc17f4947b5a7e$export$5d730b7aed1a3eb0 = (supabaseUrl, supabaseKey, options)=>{\n    return new (0, $adb6551412d48394$export$2e2bcd8739ae039)(supabaseUrl, supabaseKey, options);\n};\n\n\nconst $87b5c749fa3f6a4f$var$supabaseUrl = \"https://zjfleyijqxqjbwabuucw.supabase.co\";\nconst $87b5c749fa3f6a4f$var$supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpqZmxleWlqcXhxamJ3YWJ1dWN3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg4NTEyNjgsImV4cCI6MjA2NDQyNzI2OH0.e4gQgy43WhCQCgPWssWW-_y3_7VHpizBLb9wD60XwzY\";\nconst $87b5c749fa3f6a4f$export$a0b632a28672d3c0 = (0, $99dc17f4947b5a7e$export$5d730b7aed1a3eb0)($87b5c749fa3f6a4f$var$supabaseUrl, $87b5c749fa3f6a4f$var$supabaseKey);\n\n\nasync function $9d4f270d4dd0dae2$export$fc3b441efa2df883(url, title, category, userId, imageUrl) {\n    const { data: data, error: error } = await (0, $87b5c749fa3f6a4f$export$a0b632a28672d3c0).from(\"urls\").insert([\n        {\n            url: url,\n            title: title,\n            category: category,\n            user_id: userId,\n            thumbnail_url: imageUrl\n        }\n    ]);\n    if (error) {\n        console.error(\"Supabase insert error:\", error);\n        return {\n            success: false,\n            error: error\n        };\n    }\n    return {\n        success: true,\n        data: data\n    };\n}\nasync function $9d4f270d4dd0dae2$export$71a7b09aee976d34() {\n    const { data: data, error: error } = await (0, $87b5c749fa3f6a4f$export$a0b632a28672d3c0).from(\"urls\").select(\"id, url, title, category, user_id, thumbnail_url, visited, created_at\").order(\"created_at\", {\n        ascending: false\n    });\n    if (error) {\n        console.error(\"Supabase fetch error:\", error);\n        return [];\n    }\n    return data;\n}\nasync function $9d4f270d4dd0dae2$export$3a99609c3dc7bce9(id) {\n    const { data: data, error: error } = await (0, $87b5c749fa3f6a4f$export$a0b632a28672d3c0).from(\"urls\").delete().eq(\"id\", id);\n    if (error) {\n        console.error(\"Supabase delete error:\", error);\n        return {\n            success: false,\n            error: error\n        };\n    }\n    return {\n        success: true,\n        data: data\n    };\n}\n\n\nasync function $e38d38144a63340f$export$41b3415e6330f1b5(url) {\n    const API_KEY = \"479caf1751a010ec074397313794465c\"; // LinkPreview API \n    const apiUrl = `https://api.linkpreview.net/?key=${API_KEY}&q=${encodeURIComponent(url)}`;\n    try {\n        const res = await fetch(apiUrl);\n        if (!res.ok) throw new Error(`HTTP\\u{30A8}\\u{30E9}\\u{30FC}: ${res.status}`);\n        const data = await res.json();\n        return data.image || \"https://placehold.co/300x200\"; //  \n    } catch (error) {\n        console.error(\"\\u753B\\u50CFURL\\u53D6\\u5F97\\u30A8\\u30E9\\u30FC:\", error);\n        return \"https://placehold.co/300x200\"; //  \n    }\n}\n\n\n\nconsole.log(\"\\u2705 main.js loaded\");\ndocument.addEventListener(\"DOMContentLoaded\", async ()=>{\n    // ID\n    const { data: { session: session } } = await (0, $87b5c749fa3f6a4f$export$a0b632a28672d3c0).auth.getSession();\n    const userId = session?.user?.id || \"user_123\";\n    const urlForm = document.getElementById(\"urlForm\");\n    const urlList = document.getElementById(\"urlList\");\n    const thumbnailPreview = document.getElementById(\"thumbnail\");\n    async function loadUrls() {\n        console.log(\"\\u25B6\\uFE0F loadUrls called\");\n        urlList.innerHTML = \"\";\n        const urls = await (0, $9d4f270d4dd0dae2$export$71a7b09aee976d34)();\n        const fragment = document.createDocumentFragment();\n        urls.forEach(({ id: id, url: url, title: title, thumbnail_url: thumbnail_url })=>{\n            const li = document.createElement(\"li\");\n            li.style.display = \"flex\";\n            li.style.alignItems = \"center\";\n            li.style.gap = \"12px\";\n            li.style.margin = \"10px 0\";\n            // \n            const img = document.createElement(\"img\");\n            const proxiedUrl = thumbnail_url ? `http://localhost:3001/proxy?url=${encodeURIComponent(thumbnail_url)}` : \"https://placehold.co/80x80\";\n            img.src = proxiedUrl;\n            img.width = 80;\n            img.height = 80;\n            img.alt = \"\\u30B5\\u30E0\\u30CD\\u30A4\\u30EB\";\n            img.style.objectFit = \"cover\";\n            img.onerror = ()=>{\n                img.src = \"https://placehold.co/80x80\";\n            };\n            // \n            const link = document.createElement(\"a\");\n            link.href = url;\n            link.target = \"_blank\";\n            link.innerText = title;\n            link.style.flex = \"1\";\n            link.style.fontWeight = \"bold\";\n            link.style.fontSize = \"16px\";\n            link.style.color = \"#E76F51\";\n            link.style.textDecoration = \"none\";\n            // \n            const btnDelete = document.createElement(\"button\");\n            btnDelete.innerText = \"\\u524A\\u9664\";\n            btnDelete.classList.add(\"btn-delete\");\n            btnDelete.onclick = async ()=>{\n                if (!confirm(`\\u{300C}${title}\\u{300D}\\u{3092}\\u{524A}\\u{9664}\\u{3057}\\u{307E}\\u{3059}\\u{304B}\\u{FF1F}`)) return;\n                const { success: success, error: error } = await (0, $9d4f270d4dd0dae2$export$3a99609c3dc7bce9)(id);\n                if (success) loadUrls();\n                else {\n                    alert(\"\\u524A\\u9664\\u306B\\u5931\\u6557\\u3057\\u307E\\u3057\\u305F\");\n                    console.error(error);\n                }\n            };\n            //     \n            li.appendChild(img);\n            li.appendChild(link);\n            li.appendChild(btnDelete);\n            fragment.appendChild(li);\n        });\n        urlList.appendChild(fragment);\n    }\n    urlForm.addEventListener(\"submit\", async (event)=>{\n        event.preventDefault();\n        const url = urlForm.urlInput.value.trim();\n        const title = urlForm.titleInput.value.trim();\n        const category = urlForm.categoryInput.value.trim();\n        if (!url || !title || !category) return;\n        const imageUrl = await (0, $e38d38144a63340f$export$41b3415e6330f1b5)(url);\n        await (0, $9d4f270d4dd0dae2$export$fc3b441efa2df883)(url, title, category, userId, imageUrl);\n        // \n        const proxiedImageUrl = `http://localhost:3001/proxy?url=${encodeURIComponent(imageUrl)}`;\n        thumbnailPreview.src = proxiedImageUrl;\n        thumbnailPreview.onerror = ()=>{\n            thumbnailPreview.src = \"https://placehold.co/300x200\";\n        };\n        urlForm.reset();\n        loadUrls();\n    });\n    loadUrls();\n});\n\n\n//# sourceMappingURL=public.ce29b3c6.js.map\n","module.exports = (__parcel__import__(\"Rqc19\")).then(() => parcelRequire('R5nvG'));","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","{\n  \"name\": \"websocket\",\n  \"description\": \"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\",\n  \"keywords\": [\n    \"websocket\",\n    \"websockets\",\n    \"socket\",\n    \"networking\",\n    \"comet\",\n    \"push\",\n    \"RFC-6455\",\n    \"realtime\",\n    \"server\",\n    \"client\"\n  ],\n  \"author\": \"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)\",\n  \"contributors\": [\n    \"Iaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)\"\n  ],\n  \"version\": \"1.0.35\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/theturtle32/WebSocket-Node.git\"\n  },\n  \"homepage\": \"https://github.com/theturtle32/WebSocket-Node\",\n  \"engines\": {\n    \"node\": \">=4.0.0\"\n  },\n  \"dependencies\": {\n    \"bufferutil\": \"^4.0.1\",\n    \"debug\": \"^2.2.0\",\n    \"es5-ext\": \"^0.10.63\",\n    \"typedarray-to-buffer\": \"^3.1.5\",\n    \"utf-8-validate\": \"^5.0.2\",\n    \"yaeti\": \"^0.0.6\"\n  },\n  \"devDependencies\": {\n    \"buffer-equal\": \"^1.0.0\",\n    \"gulp\": \"^4.0.2\",\n    \"gulp-jshint\": \"^2.0.4\",\n    \"jshint-stylish\": \"^2.2.1\",\n    \"jshint\": \"^2.0.0\",\n    \"tape\": \"^4.9.1\"\n  },\n  \"config\": {\n    \"verbose\": false\n  },\n  \"scripts\": {\n    \"test\": \"tape test/unit/*.js\",\n    \"gulp\": \"gulp\"\n  },\n  \"main\": \"index\",\n  \"directories\": {\n    \"lib\": \"./lib\"\n  },\n  \"browser\": \"lib/browser.js\",\n  \"license\": \"Apache-2.0\"\n}\n","import { addUrl, fetchUrls, deleteUrl } from \"./utils/dbOperations.js\";\r\nimport { getPreview } from \"./utils/fetchPreview.js\";\r\nimport { supabase } from \"./utils/supabaseClient.js\";\r\n\r\nconsole.log(\" main.js loaded\");\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\", async () => {\r\n  // ID\r\n  const {\r\n    data: { session },\r\n  } = await supabase.auth.getSession();\r\n\r\n  const userId = session?.user?.id || \"user_123\";\r\n\r\n  const urlForm = document.getElementById(\"urlForm\");\r\n  const urlList = document.getElementById(\"urlList\");\r\n  const thumbnailPreview = document.getElementById(\"thumbnail\");\r\n\r\n  async function loadUrls() {\r\n    console.log(\" loadUrls called\");\r\n    urlList.innerHTML = \"\";\r\n    const urls = await fetchUrls();\r\n\r\n    const fragment = document.createDocumentFragment();\r\n    urls.forEach(({ id, url, title, thumbnail_url }) => {\r\n      const li = document.createElement(\"li\");\r\n      li.style.display = \"flex\";\r\n      li.style.alignItems = \"center\";\r\n      li.style.gap = \"12px\";\r\n      li.style.margin = \"10px 0\";\r\n\r\n      // \r\n      const img = document.createElement(\"img\");\r\n      const proxiedUrl = thumbnail_url\r\n        ? `http://localhost:3001/proxy?url=${encodeURIComponent(thumbnail_url)}`\r\n        : \"https://placehold.co/80x80\";\r\n\r\n      img.src = proxiedUrl;\r\n      img.width = 80;\r\n      img.height = 80;\r\n      img.alt = \"\";\r\n      img.style.objectFit = \"cover\";\r\n      img.onerror = () => { img.src = \"https://placehold.co/80x80\"; };\r\n\r\n      // \r\n      const link = document.createElement(\"a\");\r\n      link.href = url;\r\n      link.target = \"_blank\";\r\n      link.innerText = title;\r\n      link.style.flex = \"1\";\r\n      link.style.fontWeight = \"bold\";\r\n      link.style.fontSize = \"16px\";\r\n      link.style.color = \"#E76F51\";\r\n      link.style.textDecoration = \"none\";\r\n\r\n      // \r\n     const btnDelete = document.createElement(\"button\");\r\nbtnDelete.innerText = \"\";\r\nbtnDelete.classList.add(\"btn-delete\");\r\n\r\n\r\n\r\n      btnDelete.onclick = async () => {\r\n        if (!confirm(`${title}`)) return;\r\n\r\n        const { success, error } = await deleteUrl(id);\r\n        if (success) {\r\n          loadUrls();\r\n        } else {\r\n          alert(\"\");\r\n          console.error(error);\r\n        }\r\n      };\r\n\r\n      //     \r\n      li.appendChild(img);\r\n      li.appendChild(link);\r\n      li.appendChild(btnDelete);\r\n      fragment.appendChild(li);\r\n    });\r\n\r\n    urlList.appendChild(fragment);\r\n  }\r\n\r\n  urlForm.addEventListener(\"submit\", async (event) => {\r\n    event.preventDefault();\r\n    const url = urlForm.urlInput.value.trim();\r\n    const title = urlForm.titleInput.value.trim();\r\n    const category = urlForm.categoryInput.value.trim();\r\n    if (!url || !title || !category) return;\r\n\r\n    const imageUrl = await getPreview(url);\r\n    await addUrl(url, title, category, userId, imageUrl);\r\n\r\n    // \r\n    const proxiedImageUrl = `http://localhost:3001/proxy?url=${encodeURIComponent(imageUrl)}`;\r\n    thumbnailPreview.src = proxiedImageUrl;\r\n    thumbnailPreview.onerror = () => { thumbnailPreview.src = \"https://placehold.co/300x200\"; };\r\n\r\n    urlForm.reset();\r\n    loadUrls();\r\n  });\r\n\r\n  loadUrls();\r\n});\r\n","import { supabase } from \"./supabaseClient.js\";\r\n\r\n/**\r\n * URLURL Supabase \r\n */\r\nexport async function addUrl(url, title, category, userId, imageUrl) {\r\n  const { data, error } = await supabase\r\n    .from(\"urls\")\r\n    .insert([\r\n      { url, title, category, user_id: userId, thumbnail_url: imageUrl },\r\n    ]);\r\n  if (error) {\r\n    console.error(\"Supabase insert error:\", error);\r\n    return { success: false, error };\r\n  }\r\n  return { success: true, data };\r\n}\r\n\r\n/**\r\n * Supabase  \"urls\" \r\n */\r\nexport async function fetchUrls() {\r\n  const { data, error } = await supabase\r\n    .from(\"urls\")\r\n    .select(\"id, url, title, category, user_id, thumbnail_url, visited, created_at\")\r\n    .order(\"created_at\", { ascending: false });\r\n\r\n  if (error) {\r\n    console.error(\"Supabase fetch error:\", error);\r\n    return [];\r\n  }\r\n  return data;\r\n}\r\n\r\n/**\r\n * IDURL Supabase \r\n */\r\nexport async function deleteUrl(id) {\r\n  const { data, error } = await supabase\r\n    .from(\"urls\")\r\n    .delete()\r\n    .eq(\"id\", id);\r\n\r\n  if (error) {\r\n    console.error(\"Supabase delete error:\", error);\r\n    return { success: false, error };\r\n  }\r\n  return { success: true, data };\r\n}\r\n","import { createClient } from '@supabase/supabase-js';\r\n\r\nconst supabaseUrl = \"https://zjfleyijqxqjbwabuucw.supabase.co\";\r\nconst supabaseKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpqZmxleWlqcXhxamJ3YWJ1dWN3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg4NTEyNjgsImV4cCI6MjA2NDQyNzI2OH0.e4gQgy43WhCQCgPWssWW-_y3_7VHpizBLb9wD60XwzY\";\r\n\r\nexport const supabase = createClient(supabaseUrl, supabaseKey);","import SupabaseClient from './SupabaseClient';\nexport * from '@supabase/gotrue-js';\nexport * from '@supabase/realtime-js';\n/**\n * Creates a new Supabase Client.\n */\nconst createClient = (supabaseUrl, supabaseKey, options) => {\n    return new SupabaseClient(supabaseUrl, supabaseKey, options);\n};\nexport { createClient, SupabaseClient, };\n//# sourceMappingURL=index.js.map","import SupabaseClient from './SupabaseClient'\nimport { SupabaseClientOptions, SupabaseRealtimePayload } from './lib/types'\nimport { User as AuthUser, Session as AuthSession } from '@supabase/gotrue-js'\nexport * from '@supabase/gotrue-js'\nexport {\n  PostgrestResponse,\n  PostgrestSingleResponse,\n  PostgrestMaybeSingleResponse,\n  PostgrestError,\n} from '@supabase/postgrest-js'\nexport * from '@supabase/realtime-js'\n\n/**\n * Creates a new Supabase Client.\n */\nconst createClient = (\n  supabaseUrl: string,\n  supabaseKey: string,\n  options?: SupabaseClientOptions\n): SupabaseClient => {\n  return new SupabaseClient(supabaseUrl, supabaseKey, options)\n}\n\nexport {\n  createClient,\n  SupabaseClient,\n  SupabaseClientOptions,\n  SupabaseRealtimePayload,\n  AuthUser,\n  AuthSession,\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants';\nimport { stripTrailingSlash, isBrowser } from './lib/helpers';\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient';\nimport { SupabaseQueryBuilder } from './lib/SupabaseQueryBuilder';\nimport { SupabaseStorageClient } from '@supabase/storage-js';\nimport { FunctionsClient } from '@supabase/functions-js';\nimport { PostgrestClient } from '@supabase/postgrest-js';\nimport { RealtimeClient } from '@supabase/realtime-js';\nconst DEFAULT_OPTIONS = {\n    schema: 'public',\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    multiTab: true,\n    headers: DEFAULT_HEADERS,\n};\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nexport default class SupabaseClient {\n    /**\n     * Create a new client for use in the browser.\n     * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n     * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n     * @param options.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n     * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.headers Any additional headers to send with each network request.\n     * @param options.realtime Options passed along to realtime-js constructor.\n     * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n     * @param options.fetch A custom fetch implementation.\n     */\n    constructor(supabaseUrl, supabaseKey, options) {\n        this.supabaseUrl = supabaseUrl;\n        this.supabaseKey = supabaseKey;\n        if (!supabaseUrl)\n            throw new Error('supabaseUrl is required.');\n        if (!supabaseKey)\n            throw new Error('supabaseKey is required.');\n        const _supabaseUrl = stripTrailingSlash(supabaseUrl);\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.restUrl = `${_supabaseUrl}/rest/v1`;\n        this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace('http', 'ws');\n        this.authUrl = `${_supabaseUrl}/auth/v1`;\n        this.storageUrl = `${_supabaseUrl}/storage/v1`;\n        const isPlatform = _supabaseUrl.match(/(supabase\\.co)|(supabase\\.in)/);\n        if (isPlatform) {\n            const urlParts = _supabaseUrl.split('.');\n            this.functionsUrl = `${urlParts[0]}.functions.${urlParts[1]}.${urlParts[2]}`;\n        }\n        else {\n            this.functionsUrl = `${_supabaseUrl}/functions/v1`;\n        }\n        this.schema = settings.schema;\n        this.multiTab = settings.multiTab;\n        this.fetch = settings.fetch;\n        this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), options === null || options === void 0 ? void 0 : options.headers);\n        this.shouldThrowOnError = settings.shouldThrowOnError || false;\n        this.auth = this._initSupabaseAuthClient(settings);\n        this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers }, settings.realtime));\n        this._listenForAuthEvents();\n        this._listenForMultiTabEvents();\n        // In the future we might allow the user to pass in a logger to receive these events.\n        // this.realtime.onOpen(() => console.log('OPEN'))\n        // this.realtime.onClose(() => console.log('CLOSED'))\n        // this.realtime.onError((e: Error) => console.log('Socket error', e))\n    }\n    /**\n     * Supabase Functions allows you to deploy and invoke edge functions.\n     */\n    get functions() {\n        return new FunctionsClient(this.functionsUrl, {\n            headers: this._getAuthHeaders(),\n            customFetch: this.fetch,\n        });\n    }\n    /**\n     * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n     */\n    get storage() {\n        return new SupabaseStorageClient(this.storageUrl, this._getAuthHeaders(), this.fetch);\n    }\n    /**\n     * Perform a table operation.\n     *\n     * @param table The table name to operate on.\n     */\n    from(table) {\n        const url = `${this.restUrl}/${table}`;\n        return new SupabaseQueryBuilder(url, {\n            headers: this._getAuthHeaders(),\n            schema: this.schema,\n            realtime: this.realtime,\n            table,\n            fetch: this.fetch,\n            shouldThrowOnError: this.shouldThrowOnError,\n        });\n    }\n    /**\n     * Perform a function call.\n     *\n     * @param fn  The function name to call.\n     * @param params  The parameters to pass to the function call.\n     * @param head   When set to true, no data will be returned.\n     * @param count  Count algorithm to use to count rows in a table.\n     *\n     */\n    rpc(fn, params, { head = false, count = null, } = {}) {\n        const rest = this._initPostgRESTClient();\n        return rest.rpc(fn, params, { head, count });\n    }\n    /**\n     * Closes and removes all subscriptions and returns a list of removed\n     * subscriptions and their errors.\n     */\n    removeAllSubscriptions() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const allSubs = this.getSubscriptions().slice();\n            const allSubPromises = allSubs.map((sub) => this.removeSubscription(sub));\n            const allRemovedSubs = yield Promise.all(allSubPromises);\n            return allRemovedSubs.map(({ error }, i) => {\n                return {\n                    data: { subscription: allSubs[i] },\n                    error,\n                };\n            });\n        });\n    }\n    /**\n     * Closes and removes a subscription and returns the number of open subscriptions.\n     *\n     * @param subscription The subscription you want to close and remove.\n     */\n    removeSubscription(subscription) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { error } = yield this._closeSubscription(subscription);\n            const allSubs = this.getSubscriptions();\n            const openSubCount = allSubs.filter((chan) => chan.isJoined()).length;\n            if (allSubs.length === 0)\n                yield this.realtime.disconnect();\n            return { data: { openSubscriptions: openSubCount }, error };\n        });\n    }\n    _closeSubscription(subscription) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let error = null;\n            if (!subscription.isClosed()) {\n                const { error: unsubError } = yield this._unsubscribeSubscription(subscription);\n                error = unsubError;\n            }\n            this.realtime.remove(subscription);\n            return { error };\n        });\n    }\n    _unsubscribeSubscription(subscription) {\n        return new Promise((resolve) => {\n            subscription\n                .unsubscribe()\n                .receive('ok', () => resolve({ error: null }))\n                .receive('error', (error) => resolve({ error }))\n                .receive('timeout', () => resolve({ error: new Error('timed out') }));\n        });\n    }\n    /**\n     * Returns an array of all your subscriptions.\n     */\n    getSubscriptions() {\n        return this.realtime.channels;\n    }\n    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, localStorage, headers, fetch, cookieOptions, multiTab, }) {\n        const authHeaders = {\n            Authorization: `Bearer ${this.supabaseKey}`,\n            apikey: `${this.supabaseKey}`,\n        };\n        return new SupabaseAuthClient({\n            url: this.authUrl,\n            headers: Object.assign(Object.assign({}, headers), authHeaders),\n            autoRefreshToken,\n            persistSession,\n            detectSessionInUrl,\n            localStorage,\n            fetch,\n            cookieOptions,\n            multiTab,\n        });\n    }\n    _initRealtimeClient(options) {\n        return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), { params: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.params), { apikey: this.supabaseKey }) }));\n    }\n    _initPostgRESTClient() {\n        return new PostgrestClient(this.restUrl, {\n            headers: this._getAuthHeaders(),\n            schema: this.schema,\n            fetch: this.fetch,\n            throwOnError: this.shouldThrowOnError,\n        });\n    }\n    _getAuthHeaders() {\n        var _a, _b;\n        const headers = Object.assign({}, this.headers);\n        const authBearer = (_b = (_a = this.auth.session()) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;\n        headers['apikey'] = this.supabaseKey;\n        headers['Authorization'] = headers['Authorization'] || `Bearer ${authBearer}`;\n        return headers;\n    }\n    _listenForMultiTabEvents() {\n        if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            return null;\n        }\n        try {\n            return window === null || window === void 0 ? void 0 : window.addEventListener('storage', (e) => {\n                var _a, _b, _c;\n                if (e.key === STORAGE_KEY) {\n                    const newSession = JSON.parse(String(e.newValue));\n                    const accessToken = (_b = (_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n                    const previousAccessToken = (_c = this.auth.session()) === null || _c === void 0 ? void 0 : _c.access_token;\n                    if (!accessToken) {\n                        this._handleTokenChanged('SIGNED_OUT', accessToken, 'STORAGE');\n                    }\n                    else if (!previousAccessToken && accessToken) {\n                        this._handleTokenChanged('SIGNED_IN', accessToken, 'STORAGE');\n                    }\n                    else if (previousAccessToken !== accessToken) {\n                        this._handleTokenChanged('TOKEN_REFRESHED', accessToken, 'STORAGE');\n                    }\n                }\n            });\n        }\n        catch (error) {\n            console.error('_listenForMultiTabEvents', error);\n            return null;\n        }\n    }\n    _listenForAuthEvents() {\n        let { data } = this.auth.onAuthStateChange((event, session) => {\n            this._handleTokenChanged(event, session === null || session === void 0 ? void 0 : session.access_token, 'CLIENT');\n        });\n        return data;\n    }\n    _handleTokenChanged(event, token, source) {\n        if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n            this.changedAccessToken !== token) {\n            // Token has changed\n            this.realtime.setAuth(token);\n            // Ideally we should call this.auth.recoverSession() - need to make public\n            // to trigger a \"SIGNED_IN\" event on this client.\n            if (source == 'STORAGE')\n                this.auth.setAuth(token);\n            this.changedAccessToken = token;\n        }\n        else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\n            // Token is removed\n            this.realtime.setAuth(this.supabaseKey);\n            if (source == 'STORAGE')\n                this.auth.signOut();\n        }\n    }\n}\n//# sourceMappingURL=SupabaseClient.js.map","import { DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants'\nimport { stripTrailingSlash, isBrowser } from './lib/helpers'\nimport { Fetch, GenericObject, SupabaseClientOptions } from './lib/types'\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient'\nimport { SupabaseQueryBuilder } from './lib/SupabaseQueryBuilder'\nimport { SupabaseStorageClient } from '@supabase/storage-js'\nimport { FunctionsClient } from '@supabase/functions-js'\nimport { PostgrestClient } from '@supabase/postgrest-js'\nimport { AuthChangeEvent } from '@supabase/gotrue-js'\nimport { RealtimeClient, RealtimeSubscription, RealtimeClientOptions } from '@supabase/realtime-js'\n\nconst DEFAULT_OPTIONS = {\n  schema: 'public',\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS,\n}\n\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nexport default class SupabaseClient {\n  /**\n   * Supabase Auth allows you to create and manage user sessions for access to data that is secured by access policies.\n   */\n  auth: SupabaseAuthClient\n\n  protected schema: string\n  protected restUrl: string\n  protected realtimeUrl: string\n  protected authUrl: string\n  protected storageUrl: string\n  protected functionsUrl: string\n  protected realtime: RealtimeClient\n  protected multiTab: boolean\n  protected fetch?: Fetch\n  protected changedAccessToken: string | undefined\n  protected shouldThrowOnError: boolean\n\n  protected headers: {\n    [key: string]: string\n  }\n\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.headers Any additional headers to send with each network request.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(\n    protected supabaseUrl: string,\n    protected supabaseKey: string,\n    options?: SupabaseClientOptions\n  ) {\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.')\n    if (!supabaseKey) throw new Error('supabaseKey is required.')\n\n    const _supabaseUrl = stripTrailingSlash(supabaseUrl)\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n\n    this.restUrl = `${_supabaseUrl}/rest/v1`\n    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace('http', 'ws')\n    this.authUrl = `${_supabaseUrl}/auth/v1`\n    this.storageUrl = `${_supabaseUrl}/storage/v1`\n\n    const isPlatform = _supabaseUrl.match(/(supabase\\.co)|(supabase\\.in)/)\n    if (isPlatform) {\n      const urlParts = _supabaseUrl.split('.')\n      this.functionsUrl = `${urlParts[0]}.functions.${urlParts[1]}.${urlParts[2]}`\n    } else {\n      this.functionsUrl = `${_supabaseUrl}/functions/v1`\n    }\n\n    this.schema = settings.schema\n    this.multiTab = settings.multiTab\n    this.fetch = settings.fetch\n    this.headers = { ...DEFAULT_HEADERS, ...options?.headers }\n    this.shouldThrowOnError = settings.shouldThrowOnError || false\n\n    this.auth = this._initSupabaseAuthClient(settings)\n    this.realtime = this._initRealtimeClient({ headers: this.headers, ...settings.realtime })\n\n    this._listenForAuthEvents()\n    this._listenForMultiTabEvents()\n\n    // In the future we might allow the user to pass in a logger to receive these events.\n    // this.realtime.onOpen(() => console.log('OPEN'))\n    // this.realtime.onClose(() => console.log('CLOSED'))\n    // this.realtime.onError((e: Error) => console.log('Socket error', e))\n  }\n\n  /**\n   * Supabase Functions allows you to deploy and invoke edge functions.\n   */\n  get functions() {\n    return new FunctionsClient(this.functionsUrl, {\n      headers: this._getAuthHeaders(),\n      customFetch: this.fetch,\n    })\n  }\n\n  /**\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n   */\n  get storage() {\n    return new SupabaseStorageClient(this.storageUrl, this._getAuthHeaders(), this.fetch)\n  }\n\n  /**\n   * Perform a table operation.\n   *\n   * @param table The table name to operate on.\n   */\n  from<T = any>(table: string): SupabaseQueryBuilder<T> {\n    const url = `${this.restUrl}/${table}`\n    return new SupabaseQueryBuilder<T>(url, {\n      headers: this._getAuthHeaders(),\n      schema: this.schema,\n      realtime: this.realtime,\n      table,\n      fetch: this.fetch,\n      shouldThrowOnError: this.shouldThrowOnError,\n    })\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn  The function name to call.\n   * @param params  The parameters to pass to the function call.\n   * @param head   When set to true, no data will be returned.\n   * @param count  Count algorithm to use to count rows in a table.\n   *\n   */\n  rpc<T = any>(\n    fn: string,\n    params?: object,\n    {\n      head = false,\n      count = null,\n    }: { head?: boolean; count?: null | 'exact' | 'planned' | 'estimated' } = {}\n  ) {\n    const rest = this._initPostgRESTClient()\n    return rest.rpc<T>(fn, params, { head, count })\n  }\n\n  /**\n   * Closes and removes all subscriptions and returns a list of removed\n   * subscriptions and their errors.\n   */\n  async removeAllSubscriptions(): Promise<\n    { data: { subscription: RealtimeSubscription }; error: Error | null }[]\n  > {\n    const allSubs: RealtimeSubscription[] = this.getSubscriptions().slice()\n    const allSubPromises = allSubs.map((sub) => this.removeSubscription(sub))\n    const allRemovedSubs = await Promise.all(allSubPromises)\n\n    return allRemovedSubs.map(({ error }, i) => {\n      return {\n        data: { subscription: allSubs[i] },\n        error,\n      }\n    })\n  }\n\n  /**\n   * Closes and removes a subscription and returns the number of open subscriptions.\n   *\n   * @param subscription The subscription you want to close and remove.\n   */\n  async removeSubscription(\n    subscription: RealtimeSubscription\n  ): Promise<{ data: { openSubscriptions: number }; error: Error | null }> {\n    const { error } = await this._closeSubscription(subscription)\n    const allSubs: RealtimeSubscription[] = this.getSubscriptions()\n    const openSubCount = allSubs.filter((chan) => chan.isJoined()).length\n\n    if (allSubs.length === 0) await this.realtime.disconnect()\n\n    return { data: { openSubscriptions: openSubCount }, error }\n  }\n\n  private async _closeSubscription(\n    subscription: RealtimeSubscription\n  ): Promise<{ error: Error | null }> {\n    let error = null\n\n    if (!subscription.isClosed()) {\n      const { error: unsubError } = await this._unsubscribeSubscription(subscription)\n      error = unsubError\n    }\n\n    this.realtime.remove(subscription)\n\n    return { error }\n  }\n\n  private _unsubscribeSubscription(\n    subscription: RealtimeSubscription\n  ): Promise<{ error: Error | null }> {\n    return new Promise((resolve) => {\n      subscription\n        .unsubscribe()\n        .receive('ok', () => resolve({ error: null }))\n        .receive('error', (error: Error) => resolve({ error }))\n        .receive('timeout', () => resolve({ error: new Error('timed out') }))\n    })\n  }\n\n  /**\n   * Returns an array of all your subscriptions.\n   */\n  getSubscriptions(): RealtimeSubscription[] {\n    return this.realtime.channels as RealtimeSubscription[]\n  }\n\n  private _initSupabaseAuthClient({\n    autoRefreshToken,\n    persistSession,\n    detectSessionInUrl,\n    localStorage,\n    headers,\n    fetch,\n    cookieOptions,\n    multiTab,\n  }: SupabaseClientOptions) {\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`,\n    }\n    return new SupabaseAuthClient({\n      url: this.authUrl,\n      headers: { ...headers, ...authHeaders },\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      localStorage,\n      fetch,\n      cookieOptions,\n      multiTab,\n    })\n  }\n\n  private _initRealtimeClient(options?: RealtimeClientOptions) {\n    return new RealtimeClient(this.realtimeUrl, {\n      ...options,\n      params: { ...options?.params, apikey: this.supabaseKey },\n    })\n  }\n\n  private _initPostgRESTClient() {\n    return new PostgrestClient(this.restUrl, {\n      headers: this._getAuthHeaders(),\n      schema: this.schema,\n      fetch: this.fetch,\n      throwOnError: this.shouldThrowOnError,\n    })\n  }\n\n  private _getAuthHeaders(): GenericObject {\n    const headers: GenericObject = { ...this.headers }\n    const authBearer = this.auth.session()?.access_token ?? this.supabaseKey\n    headers['apikey'] = this.supabaseKey\n    headers['Authorization'] = headers['Authorization'] || `Bearer ${authBearer}`\n    return headers\n  }\n\n  private _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !window?.addEventListener) {\n      return null\n    }\n\n    try {\n      return window?.addEventListener('storage', (e: StorageEvent) => {\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue))\n          const accessToken: string | undefined =\n            newSession?.currentSession?.access_token ?? undefined\n          const previousAccessToken = this.auth.session()?.access_token\n          if (!accessToken) {\n            this._handleTokenChanged('SIGNED_OUT', accessToken, 'STORAGE')\n          } else if (!previousAccessToken && accessToken) {\n            this._handleTokenChanged('SIGNED_IN', accessToken, 'STORAGE')\n          } else if (previousAccessToken !== accessToken) {\n            this._handleTokenChanged('TOKEN_REFRESHED', accessToken, 'STORAGE')\n          }\n        }\n      })\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error)\n      return null\n    }\n  }\n\n  private _listenForAuthEvents() {\n    let { data } = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, session?.access_token, 'CLIENT')\n    })\n    return data\n  }\n\n  private _handleTokenChanged(\n    event: AuthChangeEvent,\n    token: string | undefined,\n    source: 'CLIENT' | 'STORAGE'\n  ) {\n    if (\n      (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n      this.changedAccessToken !== token\n    ) {\n      // Token has changed\n      this.realtime.setAuth(token!)\n      // Ideally we should call this.auth.recoverSession() - need to make public\n      // to trigger a \"SIGNED_IN\" event on this client.\n      if (source == 'STORAGE') this.auth.setAuth(token!)\n\n      this.changedAccessToken = token\n    } else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\n      // Token is removed\n      this.realtime.setAuth(this.supabaseKey)\n      if (source == 'STORAGE') this.auth.signOut()\n    }\n  }\n}\n","// constants.ts\nimport { version } from './version';\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `supabase-js/${version}` };\nexport const STORAGE_KEY = 'supabase.auth.token';\n//# sourceMappingURL=constants.js.map","// constants.ts\nimport { version } from './version'\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `supabase-js/${version}` }\nexport const STORAGE_KEY = 'supabase.auth.token'\n","export const version = '1.35.6';\n//# sourceMappingURL=version.js.map","export const version = '1.35.6'\n","// helpers.ts\nexport function uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\nexport function stripTrailingSlash(url) {\n    return url.replace(/\\/$/, '');\n}\nexport const isBrowser = () => typeof window !== 'undefined';\n//# sourceMappingURL=helpers.js.map","// helpers.ts\n\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n\nexport function stripTrailingSlash(url: string): string {\n  return url.replace(/\\/$/, '')\n}\n\nexport const isBrowser = () => typeof window !== 'undefined'\n","import { GoTrueClient } from '@supabase/gotrue-js';\nexport class SupabaseAuthClient extends GoTrueClient {\n    constructor(options) {\n        super(options);\n    }\n}\n//# sourceMappingURL=SupabaseAuthClient.js.map","import { GoTrueClient } from '@supabase/gotrue-js'\nimport { SupabaseAuthClientOptions } from './types'\n\nexport class SupabaseAuthClient extends GoTrueClient {\n  constructor(options: SupabaseAuthClientOptions) {\n    super(options)\n  }\n}\n","import GoTrueApi from './GoTrueApi'\nimport GoTrueClient from './GoTrueClient'\n\nexport { GoTrueApi, GoTrueClient }\nexport * from './lib/types'\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { get, post, put, remove } from './lib/fetch';\nimport { COOKIE_OPTIONS } from './lib/constants';\nimport { setCookies, getCookieString } from './lib/cookies';\nimport { expiresAt, resolveFetch } from './lib/helpers';\nexport default class GoTrueApi {\n    constructor({ url = '', headers = {}, cookieOptions, fetch, }) {\n        this.url = url;\n        this.headers = headers;\n        this.cookieOptions = Object.assign(Object.assign({}, COOKIE_OPTIONS), cookieOptions);\n        this.fetch = resolveFetch(fetch);\n    }\n    /**\n     * Create a temporary object with all configured headers and\n     * adds the Authorization token to be used on request methods\n     * @param jwt A valid, logged-in JWT.\n     */\n    _createRequestHeaders(jwt) {\n        const headers = Object.assign({}, this.headers);\n        headers['Authorization'] = `Bearer ${jwt}`;\n        return headers;\n    }\n    cookieName() {\n        var _a;\n        return (_a = this.cookieOptions.name) !== null && _a !== void 0 ? _a : '';\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */\n    getUrlForProvider(provider, options) {\n        const urlParams = [`provider=${encodeURIComponent(provider)}`];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n            urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.scopes) {\n            urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.queryParams) {\n            const query = new URLSearchParams(options.queryParams);\n            urlParams.push(`${query}`);\n        }\n        return `${this.url}/authorize?${urlParams.join('&')}`;\n    }\n    /**\n     * Creates a new user using their email address.\n     * @param email The email address of the user.\n     * @param password The password of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param data Optional user metadata.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n    signUpWithEmail(email, password, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) {\n                    queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const data = yield post(this.fetch, `${this.url}/signup${queryString}`, {\n                    email,\n                    password,\n                    data: options.data,\n                    gotrue_meta_security: { captcha_token: options.captchaToken },\n                }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Logs in an existing user using their email address.\n     * @param email The email address of the user.\n     * @param password The password of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */\n    signInWithEmail(email, password, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '?grant_type=password';\n                if (options.redirectTo) {\n                    queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const data = yield post(this.fetch, `${this.url}/token${queryString}`, { email, password, gotrue_meta_security: { captcha_token: options.captchaToken } }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Signs up a new user using their phone number and a password.\n     * @param phone The phone number of the user.\n     * @param password The password of the user.\n     * @param data Optional user metadata.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */\n    signUpWithPhone(phone, password, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const data = yield post(this.fetch, `${this.url}/signup`, {\n                    phone,\n                    password,\n                    data: options.data,\n                    gotrue_meta_security: { captcha_token: options.captchaToken },\n                }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Logs in an existing user using their phone number and password.\n     * @param phone The phone number of the user.\n     * @param password The password of the user.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */\n    signInWithPhone(phone, password, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const queryString = '?grant_type=password';\n                const data = yield post(this.fetch, `${this.url}/token${queryString}`, { phone, password, gotrue_meta_security: { captcha_token: options.captchaToken } }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Logs in an OpenID Connect user using their id_token.\n     * @param id_token The IDToken of the user.\n     * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n     * @param provider The provider of the user.\n     * @param client_id The clientID of the user.\n     * @param issuer The issuer of the user.\n     */\n    signInWithOpenIDConnect({ id_token, nonce, client_id, issuer, provider, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const queryString = '?grant_type=id_token';\n                const data = yield post(this.fetch, `${this.url}/token${queryString}`, { id_token, nonce, client_id, issuer, provider }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sends a magic login link to an email address.\n     * @param email The email address of the user.\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */\n    sendMagicLinkEmail(email, options = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) {\n                    queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n                const data = yield post(this.fetch, `${this.url}/otp${queryString}`, {\n                    email,\n                    create_user: shouldCreateUser,\n                    gotrue_meta_security: { captcha_token: options.captchaToken },\n                }, { headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n     * @param phone The user's phone number WITH international prefix\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */\n    sendMobileOTP(phone, options = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const shouldCreateUser = (_a = options.shouldCreateUser) !== null && _a !== void 0 ? _a : true;\n                const headers = Object.assign({}, this.headers);\n                const data = yield post(this.fetch, `${this.url}/otp`, {\n                    phone,\n                    create_user: shouldCreateUser,\n                    gotrue_meta_security: { captcha_token: options.captchaToken },\n                }, { headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     */\n    signOut(jwt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield post(this.fetch, `${this.url}/logout`, {}, { headers: this._createRequestHeaders(jwt), noResolveJson: true });\n                return { error: null };\n            }\n            catch (e) {\n                return { error: e };\n            }\n        });\n    }\n    /**\n     * @deprecated Use `verifyOTP` instead!\n     * @param phone The user's phone number WITH international prefix\n     * @param token token that user was sent to their mobile phone\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    verifyMobileOTP(phone, token, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const data = yield post(this.fetch, `${this.url}/verify`, { phone, token, type: 'sms', redirect_to: options.redirectTo }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Send User supplied Email / Mobile OTP to be verified\n     * @param email The user's email address\n     * @param phone The user's phone number WITH international prefix\n     * @param token token that user was sent to their mobile phone\n     * @param type verification type that the otp is generated for\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    verifyOTP({ email, phone, token, type = 'sms' }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                const data = yield post(this.fetch, `${this.url}/verify`, { email, phone, token, type, redirect_to: options.redirectTo }, { headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param data Optional user metadata\n     */\n    inviteUserByEmail(email, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) {\n                    queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const data = yield post(this.fetch, `${this.url}/invite${queryString}`, { email, data: options.data }, { headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Sends a reset request to an email address.\n     * @param email The email address of the user.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param captchaToken Verification token received when the user completes the captcha on your site.\n     */\n    resetPasswordForEmail(email, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const headers = Object.assign({}, this.headers);\n                let queryString = '';\n                if (options.redirectTo) {\n                    queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo);\n                }\n                const data = yield post(this.fetch, `${this.url}/recover${queryString}`, { email, gotrue_meta_security: { captcha_token: options.captchaToken } }, { headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n    refreshAccessToken(refreshToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/token?grant_type=refresh_token`, { refresh_token: refreshToken }, { headers: this.headers });\n                const session = Object.assign({}, data);\n                if (session.expires_in)\n                    session.expires_at = expiresAt(data.expires_in);\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Set/delete the auth cookie based on the AuthChangeEvent.\n     * Works for Next.js & Express (requires cookie-parser middleware).\n     * @param req The request object.\n     * @param res The response object.\n     */\n    setAuthCookie(req, res) {\n        if (req.method !== 'POST') {\n            res.setHeader('Allow', 'POST');\n            res.status(405).end('Method Not Allowed');\n        }\n        const { event, session } = req.body;\n        if (!event)\n            throw new Error('Auth event missing!');\n        if (event === 'SIGNED_IN') {\n            if (!session)\n                throw new Error('Auth session missing!');\n            setCookies(req, res, [\n                { key: 'access-token', value: session.access_token },\n                { key: 'refresh-token', value: session.refresh_token },\n            ].map((token) => {\n                var _a;\n                return ({\n                    name: `${this.cookieName()}-${token.key}`,\n                    value: token.value,\n                    domain: this.cookieOptions.domain,\n                    maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                    path: this.cookieOptions.path,\n                    sameSite: this.cookieOptions.sameSite,\n                });\n            }));\n        }\n        if (event === 'SIGNED_OUT') {\n            setCookies(req, res, ['access-token', 'refresh-token'].map((key) => ({\n                name: `${this.cookieName()}-${key}`,\n                value: '',\n                maxAge: -1,\n            })));\n        }\n        res.status(200).json({});\n    }\n    /**\n     * Deletes the Auth Cookies and redirects to the\n     * @param req The request object.\n     * @param res The response object.\n     * @param options Optionally specify a `redirectTo` URL in the options.\n     */\n    deleteAuthCookie(req, res, { redirectTo = '/' }) {\n        setCookies(req, res, ['access-token', 'refresh-token'].map((key) => ({\n            name: `${this.cookieName()}-${key}`,\n            value: '',\n            maxAge: -1,\n        })));\n        return res.redirect(307, redirectTo);\n    }\n    /**\n     * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n     * @param req The request object.\n     * @param res The response object.\n     * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n     */\n    getAuthCookieString(req, res) {\n        if (req.method !== 'POST') {\n            res.setHeader('Allow', 'POST');\n            res.status(405).end('Method Not Allowed');\n        }\n        const { event, session } = req.body;\n        if (!event)\n            throw new Error('Auth event missing!');\n        if (event === 'SIGNED_IN') {\n            if (!session)\n                throw new Error('Auth session missing!');\n            return getCookieString(req, res, [\n                { key: 'access-token', value: session.access_token },\n                { key: 'refresh-token', value: session.refresh_token },\n            ].map((token) => {\n                var _a;\n                return ({\n                    name: `${this.cookieName()}-${token.key}`,\n                    value: token.value,\n                    domain: this.cookieOptions.domain,\n                    maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                    path: this.cookieOptions.path,\n                    sameSite: this.cookieOptions.sameSite,\n                });\n            }));\n        }\n        if (event === 'SIGNED_OUT') {\n            return getCookieString(req, res, ['access-token', 'refresh-token'].map((key) => ({\n                name: `${this.cookieName()}-${key}`,\n                value: '',\n                maxAge: -1,\n            })));\n        }\n        return res.getHeader('Set-Cookie');\n    }\n    /**\n     * Generates links to be sent via email or other.\n     * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n     * @param email The user's email.\n     * @param password User password. For signup only.\n     * @param data Optional user metadata. For signup only.\n     * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n     */\n    generateLink(type, email, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/admin/generate_link`, {\n                    type,\n                    email,\n                    password: options.password,\n                    data: options.data,\n                    redirect_to: options.redirectTo,\n                }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    // User Admin API\n    /**\n     * Creates a new user.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     *\n     * @param attributes The data you want to create the user with.\n     */\n    createUser(attributes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/admin/users`, attributes, {\n                    headers: this.headers,\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    listUsers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/admin/users`, {\n                    headers: this.headers,\n                });\n                return { data: data.users, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    getUserById(uid) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/admin/users/${uid}`, {\n                    headers: this.headers,\n                });\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Get user by reading the cookie from the request.\n     * Works for Next.js & Express (requires cookie-parser middleware).\n     */\n    getUserByCookie(req, res) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!req.cookies) {\n                    throw new Error('Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!');\n                }\n                const access_token = req.cookies[`${this.cookieName()}-access-token`];\n                const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`];\n                if (!access_token) {\n                    throw new Error('No cookie found!');\n                }\n                const { user, error: getUserError } = yield this.getUser(access_token);\n                if (getUserError) {\n                    if (!refresh_token)\n                        throw new Error('No refresh_token cookie found!');\n                    if (!res)\n                        throw new Error('You need to pass the res object to automatically refresh the session!');\n                    const { data, error } = yield this.refreshAccessToken(refresh_token);\n                    if (error) {\n                        throw error;\n                    }\n                    else if (data) {\n                        setCookies(req, res, [\n                            { key: 'access-token', value: data.access_token },\n                            { key: 'refresh-token', value: data.refresh_token },\n                        ].map((token) => {\n                            var _a;\n                            return ({\n                                name: `${this.cookieName()}-${token.key}`,\n                                value: token.value,\n                                domain: this.cookieOptions.domain,\n                                maxAge: (_a = this.cookieOptions.lifetime) !== null && _a !== void 0 ? _a : 0,\n                                path: this.cookieOptions.path,\n                                sameSite: this.cookieOptions.sameSite,\n                            });\n                        }));\n                        return { token: data.access_token, user: data.user, data: data.user, error: null };\n                    }\n                }\n                return { token: access_token, user: user, data: user, error: null };\n            }\n            catch (e) {\n                return { token: null, user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Updates the user data.\n     *\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */\n    updateUserById(uid, attributes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this; //\n                const data = yield put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n                    headers: this.headers,\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     *\n     * @param uid The user uid you want to remove.\n     */\n    deleteUser(uid) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield remove(this.fetch, `${this.url}/admin/users/${uid}`, {}, {\n                    headers: this.headers,\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Gets the current user details.\n     *\n     * This method is called by the GoTrueClient `update` where\n     * the jwt is set to this.currentSession.access_token\n     * and therefore, acts like getting the currently authenticated user\n     *\n     * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n     */\n    getUser(jwt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/user`, {\n                    headers: this._createRequestHeaders(jwt),\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Updates the user data.\n     * @param jwt A valid, logged-in JWT.\n     * @param attributes The data you want to update.\n     */\n    updateUser(jwt, attributes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield put(this.fetch, `${this.url}/user`, attributes, {\n                    headers: this._createRequestHeaders(jwt),\n                });\n                return { user: data, data, error: null };\n            }\n            catch (e) {\n                return { user: null, data: null, error: e };\n            }\n        });\n    }\n}\n//# sourceMappingURL=GoTrueApi.js.map","import { Fetch, get, post, put, remove } from './lib/fetch'\nimport {\n  Session,\n  Provider,\n  AdminUserAttributes,\n  UserAttributes,\n  CookieOptions,\n  User,\n  OpenIDConnectCredentials,\n  VerifyOTPParams,\n} from './lib/types'\nimport { COOKIE_OPTIONS } from './lib/constants'\nimport { setCookies, getCookieString } from './lib/cookies'\nimport { expiresAt, resolveFetch } from './lib/helpers'\n\nimport type { ApiError } from './lib/types'\nexport default class GoTrueApi {\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected cookieOptions: CookieOptions\n  protected fetch: Fetch\n\n  constructor({\n    url = '',\n    headers = {},\n    cookieOptions,\n    fetch,\n  }: {\n    url: string\n    headers?: {\n      [key: string]: string\n    }\n    cookieOptions?: CookieOptions\n    fetch?: Fetch\n  }) {\n    this.url = url\n    this.headers = headers\n    this.cookieOptions = { ...COOKIE_OPTIONS, ...cookieOptions }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Create a temporary object with all configured headers and\n   * adds the Authorization token to be used on request methods\n   * @param jwt A valid, logged-in JWT.\n   */\n  private _createRequestHeaders(jwt: string) {\n    const headers = { ...this.headers }\n    headers['Authorization'] = `Bearer ${jwt}`\n    return headers\n  }\n\n  private cookieName() {\n    return this.cookieOptions.name ?? ''\n  }\n\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  getUrlForProvider(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    }\n  ) {\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\n    if (options?.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\n    }\n    if (options?.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\n    }\n    if (options?.queryParams) {\n      const query = new URLSearchParams(options.queryParams)\n      urlParams.push(`${query}`)\n    }\n    return `${this.url}/authorize?${urlParams.join('&')}`\n  }\n\n  /**\n   * Creates a new user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  async signUpWithEmail(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n      data?: object\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString = '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/signup${queryString}`,\n        {\n          email,\n          password,\n          data: options.data,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an existing user using their email address.\n   * @param email The email address of the user.\n   * @param password The password of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async signInWithEmail(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = '?grant_type=password'\n      if (options.redirectTo) {\n        queryString += '&redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { email, password, gotrue_meta_security: { captcha_token: options.captchaToken } },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Signs up a new user using their phone number and a password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param data Optional user metadata.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async signUpWithPhone(\n    phone: string,\n    password: string,\n    options: {\n      data?: object\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/signup`,\n        {\n          phone,\n          password,\n          data: options.data,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an existing user using their phone number and password.\n   * @param phone The phone number of the user.\n   * @param password The password of the user.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async signInWithPhone(\n    phone: string,\n    password: string,\n    options: {\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const queryString = '?grant_type=password'\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { phone, password, gotrue_meta_security: { captcha_token: options.captchaToken } },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Logs in an OpenID Connect user using their id_token.\n   * @param id_token The IDToken of the user.\n   * @param nonce The nonce of the user. The nonce is a random value generated by the developer (= yourself) before the initial grant is started. You should check the OpenID Connect specification for details. https://openid.net/developers/specs/\n   * @param provider The provider of the user.\n   * @param client_id The clientID of the user.\n   * @param issuer The issuer of the user.\n   */\n  async signInWithOpenIDConnect({\n    id_token,\n    nonce,\n    client_id,\n    issuer,\n    provider,\n  }: OpenIDConnectCredentials): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const queryString = '?grant_type=id_token'\n      const data = await post(\n        this.fetch,\n        `${this.url}/token${queryString}`,\n        { id_token, nonce, client_id, issuer, provider },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a magic login link to an email address.\n   * @param email The email address of the user.\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async sendMagicLinkEmail(\n    email: string,\n    options: {\n      shouldCreateUser?: boolean\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n\n      const shouldCreateUser = options.shouldCreateUser ?? true\n      const data = await post(\n        this.fetch,\n        `${this.url}/otp${queryString}`,\n        {\n          email,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a mobile OTP via SMS. Will register the account if it doesn't already exist\n   * @param phone The user's phone number WITH international prefix\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async sendMobileOTP(\n    phone: string,\n    options: {\n      shouldCreateUser?: boolean\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const shouldCreateUser = options.shouldCreateUser ?? true\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/otp`,\n        {\n          phone,\n          create_user: shouldCreateUser,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Removes a logged-in session.\n   * @param jwt A valid, logged-in JWT.\n   */\n  async signOut(jwt: string): Promise<{ error: ApiError | null }> {\n    try {\n      await post(\n        this.fetch,\n        `${this.url}/logout`,\n        {},\n        { headers: this._createRequestHeaders(jwt), noResolveJson: true }\n      )\n      return { error: null }\n    } catch (e) {\n      return { error: e as ApiError }\n    }\n  }\n\n  /**\n   * @deprecated Use `verifyOTP` instead!\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyMobileOTP(\n    phone: string,\n    token: string,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/verify`,\n        { phone, token, type: 'sms', redirect_to: options.redirectTo },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Send User supplied Email / Mobile OTP to be verified\n   * @param email The user's email address\n   * @param phone The user's phone number WITH international prefix\n   * @param token token that user was sent to their mobile phone\n   * @param type verification type that the otp is generated for\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyOTP(\n    { email, phone, token, type = 'sms' }: VerifyOTPParams,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      const data = await post(\n        this.fetch,\n        `${this.url}/verify`,\n        { email, phone, token, type, redirect_to: options.redirectTo },\n        { headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends an invite link to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata\n   */\n  async inviteUserByEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      data?: object\n    } = {}\n  ): Promise<{ data: User | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/invite${queryString}`,\n        { email, data: options.data },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sends a reset request to an email address.\n   * @param email The email address of the user.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param captchaToken Verification token received when the user completes the captcha on your site.\n   */\n  async resetPasswordForEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<{ data: {} | null; error: ApiError | null }> {\n    try {\n      const headers = { ...this.headers }\n      let queryString = ''\n      if (options.redirectTo) {\n        queryString += '?redirect_to=' + encodeURIComponent(options.redirectTo)\n      }\n      const data = await post(\n        this.fetch,\n        `${this.url}/recover${queryString}`,\n        { email, gotrue_meta_security: { captcha_token: options.captchaToken } },\n        { headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  async refreshAccessToken(\n    refreshToken: string\n  ): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      const data: any = await post(\n        this.fetch,\n        `${this.url}/token?grant_type=refresh_token`,\n        { refresh_token: refreshToken },\n        { headers: this.headers }\n      )\n      const session = { ...data }\n      if (session.expires_in) session.expires_at = expiresAt(data.expires_in)\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Set/delete the auth cookie based on the AuthChangeEvent.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   * @param req The request object.\n   * @param res The response object.\n   */\n  setAuthCookie(req: any, res: any) {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST')\n      res.status(405).end('Method Not Allowed')\n    }\n    const { event, session } = req.body\n\n    if (!event) throw new Error('Auth event missing!')\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!')\n      setCookies(\n        req,\n        res,\n        [\n          { key: 'access-token', value: session.access_token },\n          { key: 'refresh-token', value: session.refresh_token },\n        ].map((token) => ({\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: this.cookieOptions.lifetime ?? 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite,\n        }))\n      )\n    }\n    if (event === 'SIGNED_OUT') {\n      setCookies(\n        req,\n        res,\n        ['access-token', 'refresh-token'].map((key) => ({\n          name: `${this.cookieName()}-${key}`,\n          value: '',\n          maxAge: -1,\n        }))\n      )\n    }\n    res.status(200).json({})\n  }\n\n  /**\n   * Deletes the Auth Cookies and redirects to the\n   * @param req The request object.\n   * @param res The response object.\n   * @param options Optionally specify a `redirectTo` URL in the options.\n   */\n  deleteAuthCookie(req: any, res: any, { redirectTo = '/' }: { redirectTo?: string }) {\n    setCookies(\n      req,\n      res,\n      ['access-token', 'refresh-token'].map((key) => ({\n        name: `${this.cookieName()}-${key}`,\n        value: '',\n        maxAge: -1,\n      }))\n    )\n    return res.redirect(307, redirectTo)\n  }\n\n  /**\n   * Helper method to generate the Auth Cookie string for you in case you can't use `setAuthCookie`.\n   * @param req The request object.\n   * @param res The response object.\n   * @returns The Cookie string that needs to be set as the value for the `Set-Cookie` header.\n   */\n  getAuthCookieString(req: any, res: any): string[] {\n    if (req.method !== 'POST') {\n      res.setHeader('Allow', 'POST')\n      res.status(405).end('Method Not Allowed')\n    }\n    const { event, session } = req.body\n\n    if (!event) throw new Error('Auth event missing!')\n    if (event === 'SIGNED_IN') {\n      if (!session) throw new Error('Auth session missing!')\n      return getCookieString(\n        req,\n        res,\n        [\n          { key: 'access-token', value: session.access_token },\n          { key: 'refresh-token', value: session.refresh_token },\n        ].map((token) => ({\n          name: `${this.cookieName()}-${token.key}`,\n          value: token.value,\n          domain: this.cookieOptions.domain,\n          maxAge: this.cookieOptions.lifetime ?? 0,\n          path: this.cookieOptions.path,\n          sameSite: this.cookieOptions.sameSite,\n        }))\n      )\n    }\n    if (event === 'SIGNED_OUT') {\n      return getCookieString(\n        req,\n        res,\n        ['access-token', 'refresh-token'].map((key) => ({\n          name: `${this.cookieName()}-${key}`,\n          value: '',\n          maxAge: -1,\n        }))\n      )\n    }\n    return res.getHeader('Set-Cookie')\n  }\n\n  /**\n   * Generates links to be sent via email or other.\n   * @param type The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   * @param email The user's email.\n   * @param password User password. For signup only.\n   * @param data Optional user metadata. For signup only.\n   * @param redirectTo The link type (\"signup\" or \"magiclink\" or \"recovery\" or \"invite\").\n   */\n  async generateLink(\n    type:\n      | 'signup'\n      | 'magiclink'\n      | 'recovery'\n      | 'invite'\n      | 'email_change_current'\n      | 'email_change_new',\n    email: string,\n    options: {\n      password?: string\n      data?: object\n      redirectTo?: string\n    } = {}\n  ): Promise<{ data: Session | User | null; error: ApiError | null }> {\n    try {\n      const data: any = await post(\n        this.fetch,\n        `${this.url}/admin/generate_link`,\n        {\n          type,\n          email,\n          password: options.password,\n          data: options.data,\n          redirect_to: options.redirectTo,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  // User Admin API\n\n  /**\n   * Creates a new user.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param attributes The data you want to create the user with.\n   */\n  async createUser(\n    attributes: AdminUserAttributes\n  ): Promise<\n    { user: null; data: null; error: ApiError } | { user: User; data: User; error: null }\n  > {\n    try {\n      const data: any = await post(this.fetch, `${this.url}/admin/users`, attributes, {\n        headers: this.headers,\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get a list of users.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async listUsers(): Promise<{ data: null; error: ApiError } | { data: User[]; error: null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/admin/users`, {\n        headers: this.headers,\n      })\n      return { data: data.users, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get user by id.\n   *\n   * @param uid The user's unique identifier\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async getUserById(\n    uid: string\n  ): Promise<{ data: null; error: ApiError } | { data: User; error: null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/admin/users/${uid}`, {\n        headers: this.headers,\n      })\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Get user by reading the cookie from the request.\n   * Works for Next.js & Express (requires cookie-parser middleware).\n   */\n  async getUserByCookie(\n    req: any,\n    res?: any\n  ): Promise<{\n    token: string | null\n    user: User | null\n    data: User | null\n    error: ApiError | null\n  }> {\n    try {\n      if (!req.cookies) {\n        throw new Error(\n          'Not able to parse cookies! When using Express make sure the cookie-parser middleware is in use!'\n        )\n      }\n\n      const access_token = req.cookies[`${this.cookieName()}-access-token`]\n      const refresh_token = req.cookies[`${this.cookieName()}-refresh-token`]\n\n      if (!access_token) {\n        throw new Error('No cookie found!')\n      }\n\n      const { user, error: getUserError } = await this.getUser(access_token)\n      if (getUserError) {\n        if (!refresh_token) throw new Error('No refresh_token cookie found!')\n        if (!res)\n          throw new Error('You need to pass the res object to automatically refresh the session!')\n        const { data, error } = await this.refreshAccessToken(refresh_token)\n        if (error) {\n          throw error\n        } else if (data) {\n          setCookies(\n            req,\n            res,\n            [\n              { key: 'access-token', value: data.access_token },\n              { key: 'refresh-token', value: data.refresh_token! },\n            ].map((token) => ({\n              name: `${this.cookieName()}-${token.key}`,\n              value: token.value,\n              domain: this.cookieOptions.domain,\n              maxAge: this.cookieOptions.lifetime ?? 0,\n              path: this.cookieOptions.path,\n              sameSite: this.cookieOptions.sameSite,\n            }))\n          )\n          return { token: data.access_token, user: data.user, data: data.user, error: null }\n        }\n      }\n      return { token: access_token, user: user, data: user, error: null }\n    } catch (e) {\n      return { token: null, user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates the user data.\n   *\n   * @param attributes The data you want to update.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   */\n  async updateUserById(\n    uid: string,\n    attributes: AdminUserAttributes\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      this //\n      const data: any = await put(this.fetch, `${this.url}/admin/users/${uid}`, attributes, {\n        headers: this.headers,\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Delete a user. Requires a `service_role` key.\n   *\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\n   *\n   * @param uid The user uid you want to remove.\n   */\n  async deleteUser(\n    uid: string\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await remove(\n        this.fetch,\n        `${this.url}/admin/users/${uid}`,\n        {},\n        {\n          headers: this.headers,\n        }\n      )\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Gets the current user details.\n   *\n   * This method is called by the GoTrueClient `update` where\n   * the jwt is set to this.currentSession.access_token\n   * and therefore, acts like getting the currently authenticated user\n   *\n   * @param jwt A valid, logged-in JWT. Typically, the access_token for the currentSession\n   */\n  async getUser(\n    jwt: string\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await get(this.fetch, `${this.url}/user`, {\n        headers: this._createRequestHeaders(jwt),\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates the user data.\n   * @param jwt A valid, logged-in JWT.\n   * @param attributes The data you want to update.\n   */\n  async updateUser(\n    jwt: string,\n    attributes: UserAttributes\n  ): Promise<{ user: User | null; data: User | null; error: ApiError | null }> {\n    try {\n      const data: any = await put(this.fetch, `${this.url}/user`, attributes, {\n        headers: this._createRequestHeaders(jwt),\n      })\n      return { user: data, data, error: null }\n    } catch (e) {\n      return { user: null, data: null, error: e as ApiError }\n    }\n  }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { NETWORK_FAILURE } from './constants';\nconst _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst handleError = (error, reject) => {\n    if (!(error === null || error === void 0 ? void 0 : error.status)) {\n        return reject({ message: NETWORK_FAILURE.ERROR_MESSAGE });\n    }\n    if (typeof error.json !== 'function') {\n        return reject(error);\n    }\n    error.json().then((err) => {\n        return reject({\n            message: _getErrorMessage(err),\n            status: (error === null || error === void 0 ? void 0 : error.status) || 500,\n        });\n    });\n};\nconst _getRequestParams = (method, options, body) => {\n    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };\n    if (method === 'GET') {\n        return params;\n    }\n    params.headers = Object.assign({ 'Content-Type': 'application/json;charset=UTF-8' }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return params;\n};\nfunction _handleRequest(fetcher, method, url, options, body) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            fetcher(url, _getRequestParams(method, options, body))\n                .then((result) => {\n                if (!result.ok)\n                    throw result;\n                if (options === null || options === void 0 ? void 0 : options.noResolveJson)\n                    return resolve;\n                return result.json();\n            })\n                .then((data) => resolve(data))\n                .catch((error) => handleError(error, reject));\n        });\n    });\n}\nexport function get(fetcher, url, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'GET', url, options);\n    });\n}\nexport function post(fetcher, url, body, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'POST', url, options, body);\n    });\n}\nexport function put(fetcher, url, body, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'PUT', url, options, body);\n    });\n}\nexport function remove(fetcher, url, body, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'DELETE', url, options, body);\n    });\n}\n//# sourceMappingURL=fetch.js.map","import { NETWORK_FAILURE } from './constants'\n\nexport type Fetch = typeof fetch\n\nexport interface FetchOptions {\n  headers?: {\n    [key: string]: string\n  }\n  noResolveJson?: boolean\n}\n\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'\n\nconst _getErrorMessage = (err: any): string =>\n  err.msg || err.message || err.error_description || err.error || JSON.stringify(err)\n\nconst handleError = (error: any, reject: any) => {\n  if (!error?.status) {\n    return reject({ message: NETWORK_FAILURE.ERROR_MESSAGE })\n  }\n  if (typeof error.json !== 'function') {\n    return reject(error)\n  }\n  error.json().then((err: any) => {\n    return reject({\n      message: _getErrorMessage(err),\n      status: error?.status || 500,\n    })\n  })\n}\n\nconst _getRequestParams = (method: RequestMethodType, options?: FetchOptions, body?: object) => {\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\n\n  if (method === 'GET') {\n    return params\n  }\n\n  params.headers = { 'Content-Type': 'application/json;charset=UTF-8', ...options?.headers }\n  params.body = JSON.stringify(body)\n\n  return params\n}\n\nasync function _handleRequest(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: FetchOptions,\n  body?: object\n): Promise<any> {\n  return new Promise((resolve, reject) => {\n    fetcher(url, _getRequestParams(method, options, body))\n      .then((result) => {\n        if (!result.ok) throw result\n        if (options?.noResolveJson) return resolve\n        return result.json()\n      })\n      .then((data) => resolve(data))\n      .catch((error) => handleError(error, reject))\n  })\n}\n\nexport async function get(fetcher: Fetch, url: string, options?: FetchOptions): Promise<any> {\n  return _handleRequest(fetcher, 'GET', url, options)\n}\n\nexport async function post(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions\n): Promise<any> {\n  return _handleRequest(fetcher, 'POST', url, options, body)\n}\n\nexport async function put(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions\n): Promise<any> {\n  return _handleRequest(fetcher, 'PUT', url, options, body)\n}\n\nexport async function remove(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions\n): Promise<any> {\n  return _handleRequest(fetcher, 'DELETE', url, options, body)\n}\n","import { version } from './version';\nexport const GOTRUE_URL = 'http://localhost:9999';\nexport const AUDIENCE = '';\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `gotrue-js/${version}` };\nexport const EXPIRY_MARGIN = 10; // in seconds\nexport const NETWORK_FAILURE = {\n    ERROR_MESSAGE: 'Request Failed',\n    MAX_RETRIES: 10,\n    RETRY_INTERVAL: 2, // in deciseconds\n};\nexport const STORAGE_KEY = 'supabase.auth.token';\nexport const COOKIE_OPTIONS = {\n    name: 'sb',\n    lifetime: 60 * 60 * 8,\n    domain: '',\n    path: '/',\n    sameSite: 'lax',\n};\n//# sourceMappingURL=constants.js.map","import { version } from './version'\nexport const GOTRUE_URL = 'http://localhost:9999'\nexport const AUDIENCE = ''\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `gotrue-js/${version}` }\nexport const EXPIRY_MARGIN = 10 // in seconds\nexport const NETWORK_FAILURE = {\n  ERROR_MESSAGE: 'Request Failed',\n  MAX_RETRIES: 10,\n  RETRY_INTERVAL: 2, // in deciseconds\n}\nexport const STORAGE_KEY = 'supabase.auth.token'\nexport const COOKIE_OPTIONS = {\n  name: 'sb',\n  lifetime: 60 * 60 * 8,\n  domain: '',\n  path: '/',\n  sameSite: 'lax',\n}\n","// generated by genversion\nexport const version = '1.24.0';\n//# sourceMappingURL=version.js.map","// generated by genversion\nexport const version = '1.24.0'\n","/**\n * Serialize data into a cookie header.\n */\nfunction serialize(name, val, options) {\n    const opt = options || {};\n    const enc = encodeURIComponent;\n    /* eslint-disable-next-line no-control-regex */\n    const fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n    if (typeof enc !== 'function') {\n        throw new TypeError('option encode is invalid');\n    }\n    if (!fieldContentRegExp.test(name)) {\n        throw new TypeError('argument name is invalid');\n    }\n    const value = enc(val);\n    if (value && !fieldContentRegExp.test(value)) {\n        throw new TypeError('argument val is invalid');\n    }\n    let str = name + '=' + value;\n    if (null != opt.maxAge) {\n        const maxAge = opt.maxAge - 0;\n        if (isNaN(maxAge) || !isFinite(maxAge)) {\n            throw new TypeError('option maxAge is invalid');\n        }\n        str += '; Max-Age=' + Math.floor(maxAge);\n    }\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain)) {\n            throw new TypeError('option domain is invalid');\n        }\n        str += '; Domain=' + opt.domain;\n    }\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path)) {\n            throw new TypeError('option path is invalid');\n        }\n        str += '; Path=' + opt.path;\n    }\n    if (opt.expires) {\n        if (typeof opt.expires.toUTCString !== 'function') {\n            throw new TypeError('option expires is invalid');\n        }\n        str += '; Expires=' + opt.expires.toUTCString();\n    }\n    if (opt.httpOnly) {\n        str += '; HttpOnly';\n    }\n    if (opt.secure) {\n        str += '; Secure';\n    }\n    if (opt.sameSite) {\n        const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n        switch (sameSite) {\n            case 'lax':\n                str += '; SameSite=Lax';\n                break;\n            case 'strict':\n                str += '; SameSite=Strict';\n                break;\n            case 'none':\n                str += '; SameSite=None';\n                break;\n            default:\n                throw new TypeError('option sameSite is invalid');\n        }\n    }\n    return str;\n}\n/**\n * Based on the environment and the request we know if a secure cookie can be set.\n */\nfunction isSecureEnvironment(req) {\n    if (!req || !req.headers || !req.headers.host) {\n        throw new Error('The \"host\" request header is not available');\n    }\n    const host = (req.headers.host.indexOf(':') > -1 && req.headers.host.split(':')[0]) || req.headers.host;\n    if (['localhost', '127.0.0.1'].indexOf(host) > -1 || host.endsWith('.local')) {\n        return false;\n    }\n    return true;\n}\n/**\n * Serialize a cookie to a string.\n */\nfunction serializeCookie(cookie, secure) {\n    var _a, _b, _c;\n    return serialize(cookie.name, cookie.value, {\n        maxAge: cookie.maxAge,\n        expires: new Date(Date.now() + cookie.maxAge * 1000),\n        httpOnly: true,\n        secure,\n        path: (_a = cookie.path) !== null && _a !== void 0 ? _a : '/',\n        domain: (_b = cookie.domain) !== null && _b !== void 0 ? _b : '',\n        sameSite: (_c = cookie.sameSite) !== null && _c !== void 0 ? _c : 'lax',\n    });\n}\n/**\n * Get Cookie Header strings.\n */\nexport function getCookieString(req, res, cookies) {\n    const strCookies = cookies.map((c) => serializeCookie(c, isSecureEnvironment(req)));\n    const previousCookies = res.getHeader('Set-Cookie');\n    if (previousCookies) {\n        if (previousCookies instanceof Array) {\n            Array.prototype.push.apply(strCookies, previousCookies);\n        }\n        else if (typeof previousCookies === 'string') {\n            strCookies.push(previousCookies);\n        }\n    }\n    return strCookies;\n}\n/**\n * Set one or more cookies.\n */\nexport function setCookies(req, res, cookies) {\n    res.setHeader('Set-Cookie', getCookieString(req, res, cookies));\n}\n/**\n * Set one or more cookies.\n */\nexport function setCookie(req, res, cookie) {\n    setCookies(req, res, [cookie]);\n}\nexport function deleteCookie(req, res, name) {\n    setCookie(req, res, {\n        name,\n        value: '',\n        maxAge: -1,\n    });\n}\n//# sourceMappingURL=cookies.js.map","type Cookie = {\n  name: string\n  value: string\n  maxAge: number\n  domain?: string\n  path?: string\n  sameSite?: string\n}\n\n/**\n * Serialize data into a cookie header.\n */\nfunction serialize(\n  name: string,\n  val: string,\n  options: {\n    maxAge: number\n    domain: string\n    path: string\n    expires: Date\n    httpOnly: boolean\n    secure: boolean\n    sameSite: string\n  }\n) {\n  const opt = options || {}\n  const enc = encodeURIComponent\n  /* eslint-disable-next-line no-control-regex */\n  const fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid')\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid')\n  }\n\n  const value = enc(val)\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid')\n  }\n\n  let str = name + '=' + value\n\n  if (null != opt.maxAge) {\n    const maxAge = opt.maxAge - 0\n\n    if (isNaN(maxAge) || !isFinite(maxAge)) {\n      throw new TypeError('option maxAge is invalid')\n    }\n\n    str += '; Max-Age=' + Math.floor(maxAge)\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid')\n    }\n\n    str += '; Domain=' + opt.domain\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid')\n    }\n\n    str += '; Path=' + opt.path\n  }\n\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid')\n    }\n\n    str += '; Expires=' + opt.expires.toUTCString()\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly'\n  }\n\n  if (opt.secure) {\n    str += '; Secure'\n  }\n\n  if (opt.sameSite) {\n    const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite\n\n    switch (sameSite) {\n      case 'lax':\n        str += '; SameSite=Lax'\n        break\n      case 'strict':\n        str += '; SameSite=Strict'\n        break\n      case 'none':\n        str += '; SameSite=None'\n        break\n      default:\n        throw new TypeError('option sameSite is invalid')\n    }\n  }\n\n  return str\n}\n\n/**\n * Based on the environment and the request we know if a secure cookie can be set.\n */\nfunction isSecureEnvironment(req: any) {\n  if (!req || !req.headers || !req.headers.host) {\n    throw new Error('The \"host\" request header is not available')\n  }\n\n  const host =\n    (req.headers.host.indexOf(':') > -1 && req.headers.host.split(':')[0]) || req.headers.host\n  if (['localhost', '127.0.0.1'].indexOf(host) > -1 || host.endsWith('.local')) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Serialize a cookie to a string.\n */\nfunction serializeCookie(cookie: Cookie, secure: boolean) {\n  return serialize(cookie.name, cookie.value, {\n    maxAge: cookie.maxAge,\n    expires: new Date(Date.now() + cookie.maxAge * 1000),\n    httpOnly: true,\n    secure,\n    path: cookie.path ?? '/',\n    domain: cookie.domain ?? '',\n    sameSite: cookie.sameSite ?? 'lax',\n  })\n}\n\n/**\n * Get Cookie Header strings.\n */\nexport function getCookieString(req: any, res: any, cookies: Array<Cookie>): string[] {\n  const strCookies = cookies.map((c) => serializeCookie(c, isSecureEnvironment(req)))\n  const previousCookies = res.getHeader('Set-Cookie')\n  if (previousCookies) {\n    if (previousCookies instanceof Array) {\n      Array.prototype.push.apply(strCookies, previousCookies)\n    } else if (typeof previousCookies === 'string') {\n      strCookies.push(previousCookies)\n    }\n  }\n  return strCookies\n}\n\n/**\n * Set one or more cookies.\n */\nexport function setCookies(req: any, res: any, cookies: Array<Cookie>) {\n  res.setHeader('Set-Cookie', getCookieString(req, res, cookies))\n}\n\n/**\n * Set one or more cookies.\n */\nexport function setCookie(req: any, res: any, cookie: Cookie) {\n  setCookies(req, res, [cookie])\n}\n\nexport function deleteCookie(req: any, res: any, name: string) {\n  setCookie(req, res, {\n    name,\n    value: '',\n    maxAge: -1,\n  })\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport function expiresAt(expiresIn) {\n    const timeNow = Math.round(Date.now() / 1000);\n    return timeNow + expiresIn;\n}\nexport function uuid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\nexport const isBrowser = () => typeof window !== 'undefined';\nexport function getParameterByName(name, url) {\n    var _a;\n    if (!url)\n        url = ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.href) || '';\n    // eslint-disable-next-line no-useless-escape\n    name = name.replace(/[\\[\\]]/g, '\\\\$&');\n    const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'), results = regex.exec(url);\n    if (!results)\n        return null;\n    if (!results[2])\n        return '';\n    return decodeURIComponent(results[2].replace(/\\+/g, ' '));\n}\nexport const resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = (...args) => __awaiter(void 0, void 0, void 0, function* () { return yield (yield import('cross-fetch')).fetch(...args); });\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\n// LocalStorage helpers\nexport const setItemAsync = (storage, key, data) => __awaiter(void 0, void 0, void 0, function* () {\n    isBrowser() && (yield (storage === null || storage === void 0 ? void 0 : storage.setItem(key, JSON.stringify(data))));\n});\nexport const getItemAsync = (storage, key) => __awaiter(void 0, void 0, void 0, function* () {\n    const value = isBrowser() && (yield (storage === null || storage === void 0 ? void 0 : storage.getItem(key)));\n    if (!value)\n        return null;\n    try {\n        return JSON.parse(value);\n    }\n    catch (_a) {\n        return value;\n    }\n});\nexport const getItemSynchronously = (storage, key) => {\n    const value = isBrowser() && (storage === null || storage === void 0 ? void 0 : storage.getItem(key));\n    if (!value || typeof value !== 'string') {\n        return null;\n    }\n    try {\n        return JSON.parse(value);\n    }\n    catch (_a) {\n        return value;\n    }\n};\nexport const removeItemAsync = (storage, key) => __awaiter(void 0, void 0, void 0, function* () {\n    isBrowser() && (yield (storage === null || storage === void 0 ? void 0 : storage.removeItem(key)));\n});\n//# sourceMappingURL=helpers.js.map","import { SupportedStorage } from './types'\n\nexport function expiresAt(expiresIn: number) {\n  const timeNow = Math.round(Date.now() / 1000)\n  return timeNow + expiresIn\n}\n\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8\n    return v.toString(16)\n  })\n}\n\nexport const isBrowser = () => typeof window !== 'undefined'\n\nexport function getParameterByName(name: string, url?: string) {\n  if (!url) url = window?.location?.href || ''\n  // eslint-disable-next-line no-useless-escape\n  name = name.replace(/[\\[\\]]/g, '\\\\$&')\n  const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'),\n    results = regex.exec(url)\n  if (!results) return null\n  if (!results[2]) return ''\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '))\n}\n\ntype Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n\n// LocalStorage helpers\nexport const setItemAsync = async (\n  storage: SupportedStorage,\n  key: string,\n  data: any\n): Promise<void> => {\n  isBrowser() && (await storage?.setItem(key, JSON.stringify(data)))\n}\n\nexport const getItemAsync = async (storage: SupportedStorage, key: string): Promise<any | null> => {\n  const value = isBrowser() && (await storage?.getItem(key))\n  if (!value) return null\n  try {\n    return JSON.parse(value)\n  } catch {\n    return value\n  }\n}\n\nexport const getItemSynchronously = (storage: SupportedStorage, key: string): any | null => {\n  const value = isBrowser() && storage?.getItem(key)\n  if (!value || typeof value !== 'string') {\n    return null\n  }\n  try {\n    return JSON.parse(value)\n  } catch {\n    return value\n  }\n}\n\nexport const removeItemAsync = async (storage: SupportedStorage, key: string): Promise<void> => {\n  isBrowser() && (await storage?.removeItem(key))\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid, setItemAsync, removeItemAsync, getItemSynchronously, getItemAsync, } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY, EXPIRY_MARGIN, NETWORK_FAILURE, } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: GOTRUE_URL,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    multiTab: true,\n    headers: DEFAULT_HEADERS,\n};\nconst decodeBase64URL = (value) => {\n    try {\n        // atob is present in all browsers and nodejs >= 16\n        // but if it is not it will throw a ReferenceError in which case we can try to use Buffer\n        // replace are here to convert the Base64-URL into Base64 which is what atob supports\n        // replace with //g regex acts like replaceAll\n        return atob(value.replace(/[-]/g, '+').replace(/[_]/g, '/'));\n    }\n    catch (e) {\n        if (e instanceof ReferenceError) {\n            // running on nodejs < 16\n            // Buffer supports Base64-URL transparently\n            return Buffer.from(value, 'base64').toString('utf-8');\n        }\n        else {\n            throw e;\n        }\n    }\n};\nexport default class GoTrueClient {\n    /**\n     * Create a new client for use in the browser.\n     * @param options.url The URL of the GoTrue server.\n     * @param options.headers Any additional headers to send to the GoTrue server.\n     * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n     * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n     * @param options.cookieOptions\n     * @param options.fetch A custom fetch implementation.\n     */\n    constructor(options) {\n        this.stateChangeEmitters = new Map();\n        this.networkRetries = 0;\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.currentUser = null;\n        this.currentSession = null;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.persistSession = settings.persistSession;\n        this.multiTab = settings.multiTab;\n        this.localStorage = settings.localStorage || globalThis.localStorage;\n        this.api = new GoTrueApi({\n            url: settings.url,\n            headers: settings.headers,\n            cookieOptions: settings.cookieOptions,\n            fetch: settings.fetch,\n        });\n        this._recoverSession();\n        this._recoverAndRefresh();\n        this._listenForMultiTabEvents();\n        this._handleVisibilityChange();\n        if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n            // Handle the OAuth redirect\n            this.getSessionFromUrl({ storeSession: true }).then(({ error }) => {\n                if (error) {\n                    throw new Error('Error getting session from URL.');\n                }\n            });\n        }\n    }\n    /**\n     * Creates a new user.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param password The user's password.\n     * @param phone The user's phone number.\n     * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n     * @param data Optional user metadata.\n     */\n    signUp({ email, password, phone }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                const { data, error } = phone && password\n                    ? yield this.api.signUpWithPhone(phone, password, {\n                        data: options.data,\n                        captchaToken: options.captchaToken,\n                    })\n                    : yield this.api.signUpWithEmail(email, password, {\n                        redirectTo: options.redirectTo,\n                        data: options.data,\n                        captchaToken: options.captchaToken,\n                    });\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw 'An error occurred on sign up.';\n                }\n                let session = null;\n                let user = null;\n                if (data.access_token) {\n                    session = data;\n                    user = session.user;\n                    this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) {\n                    user = data;\n                }\n                return { user, session, error: null };\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Log in an existing user, or login via a third-party provider.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param password The user's password.\n     * @param refreshToken A valid refresh token that was returned on login.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n     * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */\n    signIn({ email, phone, password, refreshToken, provider, oidc }, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                if (email && !password) {\n                    const { error } = yield this.api.sendMagicLinkEmail(email, {\n                        redirectTo: options.redirectTo,\n                        shouldCreateUser: options.shouldCreateUser,\n                        captchaToken: options.captchaToken,\n                    });\n                    return { user: null, session: null, error };\n                }\n                if (email && password) {\n                    return this._handleEmailSignIn(email, password, {\n                        redirectTo: options.redirectTo,\n                        captchaToken: options.captchaToken,\n                    });\n                }\n                if (phone && !password) {\n                    const { error } = yield this.api.sendMobileOTP(phone, {\n                        shouldCreateUser: options.shouldCreateUser,\n                        captchaToken: options.captchaToken,\n                    });\n                    return { user: null, session: null, error };\n                }\n                if (phone && password) {\n                    return this._handlePhoneSignIn(phone, password);\n                }\n                if (refreshToken) {\n                    // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n                    const { error } = yield this._callRefreshToken(refreshToken);\n                    if (error)\n                        throw error;\n                    return {\n                        user: this.currentUser,\n                        session: this.currentSession,\n                        error: null,\n                    };\n                }\n                if (provider) {\n                    return this._handleProviderSignIn(provider, {\n                        redirectTo: options.redirectTo,\n                        scopes: options.scopes,\n                        queryParams: options.queryParams,\n                    });\n                }\n                if (oidc) {\n                    return this._handleOpenIDConnectSignIn(oidc);\n                }\n                throw new Error(`You must provide either an email, phone number, a third-party provider or OpenID Connect.`);\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     * @param email The user's email address.\n     * @param phone The user's phone number.\n     * @param token The user's password.\n     * @param type The user's verification type.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n    verifyOTP(params, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this._removeSession();\n                const { data, error } = yield this.api.verifyOTP(params, options);\n                if (error) {\n                    throw error;\n                }\n                if (!data) {\n                    throw 'An error occurred on token verification.';\n                }\n                let session = null;\n                let user = null;\n                if (data.access_token) {\n                    session = data;\n                    user = session.user;\n                    this._saveSession(session);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                if (data.id) {\n                    user = data;\n                }\n                return { user, session, error: null };\n            }\n            catch (e) {\n                return { user: null, session: null, error: e };\n            }\n        });\n    }\n    /**\n     * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n     *\n     * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n     */\n    user() {\n        return this.currentUser;\n    }\n    /**\n     * Returns the session data, if there is an active session.\n     */\n    session() {\n        return this.currentSession;\n    }\n    /**\n     * Force refreshes the session including the user data in case it was updated in a different session.\n     */\n    refreshSession() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))\n                    throw new Error('Not logged in.');\n                // currentSession and currentUser will be updated to latest on _callRefreshToken\n                const { error } = yield this._callRefreshToken();\n                if (error)\n                    throw error;\n                return { data: this.currentSession, user: this.currentUser, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, error: e };\n            }\n        });\n    }\n    /**\n     * Updates user data, if there is a logged in user.\n     */\n    update(attributes) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token))\n                    throw new Error('Not logged in.');\n                const { user, error } = yield this.api.updateUser(this.currentSession.access_token, attributes);\n                if (error)\n                    throw error;\n                if (!user)\n                    throw Error('Invalid user data.');\n                const session = Object.assign(Object.assign({}, this.currentSession), { user });\n                this._saveSession(session);\n                this._notifyAllSubscribers('USER_UPDATED');\n                return { data: user, user, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, error: e };\n            }\n        });\n    }\n    setSession(arg0) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let session;\n            if (typeof arg0 === 'string') {\n                // using the refresh_token string API\n                const refresh_token = arg0;\n                const { data, error } = yield this.api.refreshAccessToken(refresh_token);\n                if (error) {\n                    return { session: null, error: error };\n                }\n                session = data;\n            }\n            else {\n                // using the object parameter API\n                const timeNow = Math.round(Date.now() / 1000);\n                let { refresh_token, access_token } = arg0;\n                let expires_at = 0;\n                let expires_in = 0;\n                const tokenParts = access_token.split('.');\n                if (tokenParts.length !== 3)\n                    throw new Error('access_token is not a proper JWT');\n                const bodyJSON = decodeBase64URL(tokenParts[1]);\n                let parsed = undefined;\n                try {\n                    parsed = JSON.parse(bodyJSON);\n                }\n                catch (e) {\n                    throw new Error('access_token is not a proper JWT, invalid JSON in body');\n                }\n                if (typeof parsed === 'object' && parsed && typeof parsed.exp === 'number') {\n                    expires_at = parsed.exp;\n                    expires_in = timeNow - parsed.exp;\n                }\n                else {\n                    throw new Error('access_token is not a proper JWT, missing exp claim');\n                }\n                if (timeNow > expires_at) {\n                    const { data, error } = yield this.api.refreshAccessToken(refresh_token);\n                    if (error) {\n                        return { session: null, error: error };\n                    }\n                    session = data;\n                }\n                else {\n                    const { user, error } = yield this.api.getUser(access_token);\n                    if (error)\n                        throw error;\n                    session = {\n                        access_token,\n                        expires_in,\n                        expires_at,\n                        refresh_token,\n                        token_type: 'bearer',\n                        user: user,\n                    };\n                }\n            }\n            try {\n                this._saveSession(session);\n                this._notifyAllSubscribers('SIGNED_IN');\n                return { session, error: null };\n            }\n            catch (e) {\n                return { error: e, session: null };\n            }\n        });\n    }\n    /**\n     * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n     * @param access_token a jwt access token\n     */\n    setAuth(access_token) {\n        this.currentSession = Object.assign(Object.assign({}, this.currentSession), { access_token, token_type: 'bearer', user: this.user() });\n        this._notifyAllSubscribers('TOKEN_REFRESHED');\n        return this.currentSession;\n    }\n    /**\n     * Gets the session data from a URL string\n     * @param options.storeSession Optionally store the session in the browser\n     */\n    getSessionFromUrl(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!isBrowser())\n                    throw new Error('No browser detected.');\n                const error_description = getParameterByName('error_description');\n                if (error_description)\n                    throw new Error(error_description);\n                const provider_token = getParameterByName('provider_token');\n                const provider_refresh_token = getParameterByName('provider_refresh_token');\n                const access_token = getParameterByName('access_token');\n                if (!access_token)\n                    throw new Error('No access_token detected.');\n                const expires_in = getParameterByName('expires_in');\n                if (!expires_in)\n                    throw new Error('No expires_in detected.');\n                const refresh_token = getParameterByName('refresh_token');\n                if (!refresh_token)\n                    throw new Error('No refresh_token detected.');\n                const token_type = getParameterByName('token_type');\n                if (!token_type)\n                    throw new Error('No token_type detected.');\n                const timeNow = Math.round(Date.now() / 1000);\n                const expires_at = timeNow + parseInt(expires_in);\n                const { user, error } = yield this.api.getUser(access_token);\n                if (error)\n                    throw error;\n                const session = {\n                    provider_token,\n                    provider_refresh_token,\n                    access_token,\n                    expires_in: parseInt(expires_in),\n                    expires_at,\n                    refresh_token,\n                    token_type,\n                    user: user,\n                };\n                if (options === null || options === void 0 ? void 0 : options.storeSession) {\n                    this._saveSession(session);\n                    const recoveryMode = getParameterByName('type');\n                    this._notifyAllSubscribers('SIGNED_IN');\n                    if (recoveryMode === 'recovery') {\n                        this._notifyAllSubscribers('PASSWORD_RECOVERY');\n                    }\n                }\n                // Remove tokens from URL\n                window.location.hash = '';\n                return { data: session, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`. There is no way to revoke a user's session JWT before it automatically expires\n     */\n    signOut() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n            this._removeSession();\n            this._notifyAllSubscribers('SIGNED_OUT');\n            if (accessToken) {\n                const { error } = yield this.api.signOut(accessToken);\n                if (error)\n                    return { error };\n            }\n            return { error: null };\n        });\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n     */\n    onAuthStateChange(callback) {\n        try {\n            const id = uuid();\n            const subscription = {\n                id,\n                callback,\n                unsubscribe: () => {\n                    this.stateChangeEmitters.delete(id);\n                },\n            };\n            this.stateChangeEmitters.set(id, subscription);\n            return { data: subscription, error: null };\n        }\n        catch (e) {\n            return { data: null, error: e };\n        }\n    }\n    _handleEmailSignIn(email, password, options = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data, error } = yield this.api.signInWithEmail(email, password, {\n                    redirectTo: options.redirectTo,\n                    captchaToken: options.captchaToken,\n                });\n                if (error || !data)\n                    return { data: null, user: null, session: null, error };\n                if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return { data, user: data.user, session: data, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, session: null, error: e };\n            }\n        });\n    }\n    _handlePhoneSignIn(phone, password, options = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { data, error } = yield this.api.signInWithPhone(phone, password, options);\n                if (error || !data)\n                    return { data: null, user: null, session: null, error };\n                if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n                return { data, user: data.user, session: data, error: null };\n            }\n            catch (e) {\n                return { data: null, user: null, session: null, error: e };\n            }\n        });\n    }\n    _handleProviderSignIn(provider, options = {}) {\n        const url = this.api.getUrlForProvider(provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams,\n        });\n        try {\n            // try to open on the browser\n            if (isBrowser()) {\n                window.location.href = url;\n            }\n            return { provider, url, data: null, session: null, user: null, error: null };\n        }\n        catch (e) {\n            // fallback to returning the URL\n            if (url)\n                return { provider, url, data: null, session: null, user: null, error: null };\n            return { data: null, user: null, session: null, error: e };\n        }\n    }\n    _handleOpenIDConnectSignIn({ id_token, nonce, client_id, issuer, provider, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (id_token && nonce && ((client_id && issuer) || provider)) {\n                try {\n                    const { data, error } = yield this.api.signInWithOpenIDConnect({\n                        id_token,\n                        nonce,\n                        client_id,\n                        issuer,\n                        provider,\n                    });\n                    if (error || !data)\n                        return { user: null, session: null, error };\n                    this._saveSession(data);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                    return { user: data.user, session: data, error: null };\n                }\n                catch (e) {\n                    return { user: null, session: null, error: e };\n                }\n            }\n            throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`);\n        });\n    }\n    /**\n     * Attempts to get the session from LocalStorage\n     * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n     */\n    _recoverSession() {\n        try {\n            const data = getItemSynchronously(this.localStorage, STORAGE_KEY);\n            if (!data)\n                return null;\n            const { currentSession, expiresAt } = data;\n            const timeNow = Math.round(Date.now() / 1000);\n            if (expiresAt >= timeNow + EXPIRY_MARGIN && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n                this._saveSession(currentSession);\n                this._notifyAllSubscribers('SIGNED_IN');\n            }\n        }\n        catch (error) {\n            console.log('error', error);\n        }\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n    _recoverAndRefresh() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield getItemAsync(this.localStorage, STORAGE_KEY);\n                if (!data)\n                    return null;\n                const { currentSession, expiresAt } = data;\n                const timeNow = Math.round(Date.now() / 1000);\n                if (expiresAt < timeNow + EXPIRY_MARGIN) {\n                    if (this.autoRefreshToken && currentSession.refresh_token) {\n                        this.networkRetries++;\n                        const { error } = yield this._callRefreshToken(currentSession.refresh_token);\n                        if (error) {\n                            console.log(error.message);\n                            if (error.message === NETWORK_FAILURE.ERROR_MESSAGE &&\n                                this.networkRetries < NETWORK_FAILURE.MAX_RETRIES) {\n                                if (this.refreshTokenTimer)\n                                    clearTimeout(this.refreshTokenTimer);\n                                this.refreshTokenTimer = setTimeout(() => this._recoverAndRefresh(), Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100 // exponential backoff\n                                );\n                                return;\n                            }\n                            yield this._removeSession();\n                        }\n                        this.networkRetries = 0;\n                    }\n                    else {\n                        this._removeSession();\n                    }\n                }\n                else if (!currentSession) {\n                    console.log('Current session is missing data.');\n                    this._removeSession();\n                }\n                else {\n                    // should be handled on _recoverSession method already\n                    // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n                    this._saveSession(currentSession);\n                    this._notifyAllSubscribers('SIGNED_IN');\n                }\n            }\n            catch (err) {\n                console.error(err);\n                return null;\n            }\n        });\n    }\n    _callRefreshToken(refresh_token) {\n        var _a;\n        if (refresh_token === void 0) { refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token; }\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (!refresh_token) {\n                    throw new Error('No current session.');\n                }\n                const { data, error } = yield this.api.refreshAccessToken(refresh_token);\n                if (error)\n                    throw error;\n                if (!data)\n                    throw Error('Invalid session data.');\n                this._saveSession(data);\n                this._notifyAllSubscribers('TOKEN_REFRESHED');\n                this._notifyAllSubscribers('SIGNED_IN');\n                return { data, error: null };\n            }\n            catch (e) {\n                return { data: null, error: e };\n            }\n        });\n    }\n    _notifyAllSubscribers(event) {\n        this.stateChangeEmitters.forEach((x) => x.callback(event, this.currentSession));\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n    _saveSession(session) {\n        this.currentSession = session;\n        this.currentUser = session.user;\n        const expiresAt = session.expires_at;\n        if (expiresAt) {\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = expiresAt - timeNow;\n            const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5;\n            this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n        }\n        // Do we need any extra check before persist session\n        // access_token or user ?\n        if (this.persistSession && session.expires_at) {\n            this._persistSession(this.currentSession);\n        }\n    }\n    _persistSession(currentSession) {\n        const data = { currentSession, expiresAt: currentSession.expires_at };\n        setItemAsync(this.localStorage, STORAGE_KEY, data);\n    }\n    _removeSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.currentSession = null;\n            this.currentUser = null;\n            if (this.refreshTokenTimer)\n                clearTimeout(this.refreshTokenTimer);\n            removeItemAsync(this.localStorage, STORAGE_KEY);\n        });\n    }\n    /**\n     * Clear and re-create refresh token timer\n     * @param value time intervals in milliseconds\n     */\n    _startAutoRefreshToken(value) {\n        if (this.refreshTokenTimer)\n            clearTimeout(this.refreshTokenTimer);\n        if (value <= 0 || !this.autoRefreshToken)\n            return;\n        this.refreshTokenTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n            this.networkRetries++;\n            const { error } = yield this._callRefreshToken();\n            if (!error)\n                this.networkRetries = 0;\n            if ((error === null || error === void 0 ? void 0 : error.message) === NETWORK_FAILURE.ERROR_MESSAGE &&\n                this.networkRetries < NETWORK_FAILURE.MAX_RETRIES)\n                this._startAutoRefreshToken(Math.pow(NETWORK_FAILURE.RETRY_INTERVAL, this.networkRetries) * 100); // exponential backoff\n        }), value);\n        if (typeof this.refreshTokenTimer.unref === 'function')\n            this.refreshTokenTimer.unref();\n    }\n    /**\n     * Listens for changes to LocalStorage and updates the current session.\n     */\n    _listenForMultiTabEvents() {\n        if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            return false;\n        }\n        try {\n            window === null || window === void 0 ? void 0 : window.addEventListener('storage', (e) => {\n                var _a;\n                if (e.key === STORAGE_KEY) {\n                    const newSession = JSON.parse(String(e.newValue));\n                    if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n                        this._saveSession(newSession.currentSession);\n                        this._notifyAllSubscribers('SIGNED_IN');\n                    }\n                    else {\n                        this._removeSession();\n                        this._notifyAllSubscribers('SIGNED_OUT');\n                    }\n                }\n            });\n        }\n        catch (error) {\n            console.error('_listenForMultiTabEvents', error);\n        }\n    }\n    _handleVisibilityChange() {\n        if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            return false;\n        }\n        try {\n            window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', () => {\n                if (document.visibilityState === 'visible') {\n                    this._recoverAndRefresh();\n                }\n            });\n        }\n        catch (error) {\n            console.error('_handleVisibilityChange', error);\n        }\n    }\n}\n//# sourceMappingURL=GoTrueClient.js.map","import GoTrueApi from './GoTrueApi'\nimport {\n  isBrowser,\n  getParameterByName,\n  uuid,\n  setItemAsync,\n  removeItemAsync,\n  getItemSynchronously,\n  getItemAsync,\n} from './lib/helpers'\nimport {\n  GOTRUE_URL,\n  DEFAULT_HEADERS,\n  STORAGE_KEY,\n  EXPIRY_MARGIN,\n  NETWORK_FAILURE,\n} from './lib/constants'\nimport { polyfillGlobalThis } from './lib/polyfills'\nimport { Fetch } from './lib/fetch'\n\nimport type {\n  ApiError,\n  Session,\n  User,\n  UserAttributes,\n  Provider,\n  Subscription,\n  AuthChangeEvent,\n  CookieOptions,\n  UserCredentials,\n  VerifyOTPParams,\n  OpenIDConnectCredentials,\n  SupportedStorage,\n} from './lib/types'\n\npolyfillGlobalThis() // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS,\n}\n\nconst decodeBase64URL = (value: string): string => {\n  try {\n    // atob is present in all browsers and nodejs >= 16\n    // but if it is not it will throw a ReferenceError in which case we can try to use Buffer\n    // replace are here to convert the Base64-URL into Base64 which is what atob supports\n    // replace with //g regex acts like replaceAll\n    return atob(value.replace(/[-]/g, '+').replace(/[_]/g, '/'))\n  } catch (e) {\n    if (e instanceof ReferenceError) {\n      // running on nodejs < 16\n      // Buffer supports Base64-URL transparently\n      return Buffer.from(value, 'base64').toString('utf-8')\n    } else {\n      throw e\n    }\n  }\n}\n\nexport default class GoTrueClient {\n  /**\n   * Namespace for the GoTrue API methods.\n   * These can be used for example to get a user from a JWT in a server environment or reset a user's password.\n   */\n  api: GoTrueApi\n  /**\n   * The currently logged in user or null.\n   */\n  protected currentUser: User | null\n  /**\n   * The session object for the currently logged in user or null.\n   */\n  protected currentSession: Session | null\n\n  protected autoRefreshToken: boolean\n  protected persistSession: boolean\n  protected localStorage: SupportedStorage\n  protected multiTab: boolean\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\n  protected refreshTokenTimer?: ReturnType<typeof setTimeout>\n  protected networkRetries: number = 0\n\n  /**\n   * Create a new client for use in the browser.\n   * @param options.url The URL of the GoTrue server.\n   * @param options.headers Any additional headers to send to the GoTrue server.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.cookieOptions\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(options: {\n    url?: string\n    headers?: { [key: string]: string }\n    detectSessionInUrl?: boolean\n    autoRefreshToken?: boolean\n    persistSession?: boolean\n    localStorage?: SupportedStorage\n    multiTab?: boolean\n    cookieOptions?: CookieOptions\n    fetch?: Fetch\n  }) {\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n    this.currentUser = null\n    this.currentSession = null\n    this.autoRefreshToken = settings.autoRefreshToken\n    this.persistSession = settings.persistSession\n    this.multiTab = settings.multiTab\n    this.localStorage = settings.localStorage || globalThis.localStorage\n    this.api = new GoTrueApi({\n      url: settings.url,\n      headers: settings.headers,\n      cookieOptions: settings.cookieOptions,\n      fetch: settings.fetch,\n    })\n    this._recoverSession()\n    this._recoverAndRefresh()\n    this._listenForMultiTabEvents()\n    this._handleVisibilityChange()\n\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n      // Handle the OAuth redirect\n      this.getSessionFromUrl({ storeSession: true }).then(({ error }) => {\n        if (error) {\n          throw new Error('Error getting session from URL.')\n        }\n      })\n    }\n  }\n\n  /**\n   * Creates a new user.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param phone The user's phone number.\n   * @param redirectTo The redirect URL attached to the signup confirmation link. Does not redirect the user if it's a mobile signup.\n   * @param data Optional user metadata.\n   */\n  async signUp(\n    { email, password, phone }: UserCredentials,\n    options: {\n      redirectTo?: string\n      data?: object\n      captchaToken?: string\n    } = {}\n  ): Promise<{\n    user: User | null\n    session: Session | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      const { data, error } =\n        phone && password\n          ? await this.api.signUpWithPhone(phone!, password!, {\n              data: options.data,\n              captchaToken: options.captchaToken,\n            })\n          : await this.api.signUpWithEmail(email!, password!, {\n              redirectTo: options.redirectTo,\n              data: options.data,\n              captchaToken: options.captchaToken,\n            })\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw 'An error occurred on sign up.'\n      }\n\n      let session: Session | null = null\n      let user: User | null = null\n\n      if ((data as Session).access_token) {\n        session = data as Session\n        user = session.user as User\n        this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      if ((data as User).id) {\n        user = data as User\n      }\n\n      return { user, session, error: null }\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Log in an existing user, or login via a third-party provider.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param phone The user's phone number.\n   * @param password The user's password.\n   * @param refreshToken A valid refresh token that was returned on login.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL to send the user to after they are confirmed (OAuth logins only).\n   * @param shouldCreateUser A boolean flag to indicate whether to automatically create a user on magiclink / otp sign-ins if the user doesn't exist. Defaults to true.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  async signIn(\n    { email, phone, password, refreshToken, provider, oidc }: UserCredentials,\n    options: {\n      redirectTo?: string\n      shouldCreateUser?: boolean\n      scopes?: string\n      captchaToken?: string\n      queryParams?: { [key: string]: string }\n    } = {}\n  ): Promise<{\n    session: Session | null\n    user: User | null\n    provider?: Provider\n    url?: string | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      if (email && !password) {\n        const { error } = await this.api.sendMagicLinkEmail(email, {\n          redirectTo: options.redirectTo,\n          shouldCreateUser: options.shouldCreateUser,\n          captchaToken: options.captchaToken,\n        })\n        return { user: null, session: null, error }\n      }\n      if (email && password) {\n        return this._handleEmailSignIn(email, password, {\n          redirectTo: options.redirectTo,\n          captchaToken: options.captchaToken,\n        })\n      }\n      if (phone && !password) {\n        const { error } = await this.api.sendMobileOTP(phone, {\n          shouldCreateUser: options.shouldCreateUser,\n          captchaToken: options.captchaToken,\n        })\n        return { user: null, session: null, error }\n      }\n      if (phone && password) {\n        return this._handlePhoneSignIn(phone, password)\n      }\n      if (refreshToken) {\n        // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n        const { error } = await this._callRefreshToken(refreshToken)\n        if (error) throw error\n\n        return {\n          user: this.currentUser,\n          session: this.currentSession,\n          error: null,\n        }\n      }\n      if (provider) {\n        return this._handleProviderSignIn(provider, {\n          redirectTo: options.redirectTo,\n          scopes: options.scopes,\n          queryParams: options.queryParams,\n        })\n      }\n      if (oidc) {\n        return this._handleOpenIDConnectSignIn(oidc)\n      }\n      throw new Error(\n        `You must provide either an email, phone number, a third-party provider or OpenID Connect.`\n      )\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   * @param email The user's email address.\n   * @param phone The user's phone number.\n   * @param token The user's password.\n   * @param type The user's verification type.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyOTP(\n    params: VerifyOTPParams,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{\n    user: User | null\n    session: Session | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      const { data, error } = await this.api.verifyOTP(params, options)\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw 'An error occurred on token verification.'\n      }\n\n      let session: Session | null = null\n      let user: User | null = null\n\n      if ((data as Session).access_token) {\n        session = data as Session\n        user = session.user as User\n        this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      if ((data as User).id) {\n        user = data as User\n      }\n\n      return { user, session, error: null }\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n   *\n   * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n   */\n  user(): User | null {\n    return this.currentUser\n  }\n\n  /**\n   * Returns the session data, if there is an active session.\n   */\n  session(): Session | null {\n    return this.currentSession\n  }\n\n  /**\n   * Force refreshes the session including the user data in case it was updated in a different session.\n   */\n  async refreshSession(): Promise<{\n    data: Session | null\n    user: User | null\n    error: ApiError | null\n  }> {\n    try {\n      if (!this.currentSession?.access_token) throw new Error('Not logged in.')\n\n      // currentSession and currentUser will be updated to latest on _callRefreshToken\n      const { error } = await this._callRefreshToken()\n      if (error) throw error\n\n      return { data: this.currentSession, user: this.currentUser, error: null }\n    } catch (e) {\n      return { data: null, user: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n  async update(\n    attributes: UserAttributes\n  ): Promise<{ data: User | null; user: User | null; error: ApiError | null }> {\n    try {\n      if (!this.currentSession?.access_token) throw new Error('Not logged in.')\n\n      const { user, error } = await this.api.updateUser(\n        this.currentSession.access_token,\n        attributes\n      )\n      if (error) throw error\n      if (!user) throw Error('Invalid user data.')\n\n      const session = { ...this.currentSession, user }\n      this._saveSession(session)\n      this._notifyAllSubscribers('USER_UPDATED')\n\n      return { data: user, user, error: null }\n    } catch (e) {\n      return { data: null, user: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sets the session from the provided session information. The access_token\n   * is reused if it is not expired, otherwise a new access token is fetched by\n   * refreshing the session with the provided refresh_token.\n   *\n   * This method is useful when using in a server-side rendered context.\n   *\n   * @param params.refresh_token A valid refresh token (typically obtained from a cookie)\n   * @param params.access_token An access token (typically obtained from a cookie)\n   */\n  async setSession(params: {\n    refresh_token: string\n    access_token: string\n  }): Promise<{ session: Session | null; error: ApiError | null }>\n\n  /**\n   * Sets the session data from refresh_token and returns current Session and Error\n   * @param refresh_token a JWT token\n   */\n  async setSession(\n    refresh_token: string\n  ): Promise<{ session: Session | null; error: ApiError | null }>\n\n  async setSession(\n    arg0: string | { access_token: string; refresh_token: string }\n  ): Promise<{ session: Session | null; error: ApiError | null }> {\n    let session: Session\n\n    if (typeof arg0 === 'string') {\n      // using the refresh_token string API\n      const refresh_token = arg0\n\n      const { data, error } = await this.api.refreshAccessToken(refresh_token)\n      if (error) {\n        return { session: null, error: error }\n      }\n\n      session = data!\n    } else {\n      // using the object parameter API\n\n      const timeNow = Math.round(Date.now() / 1000)\n\n      let { refresh_token, access_token } = arg0\n      let expires_at = 0\n      let expires_in = 0\n\n      const tokenParts = access_token.split('.')\n      if (tokenParts.length !== 3) throw new Error('access_token is not a proper JWT')\n\n      const bodyJSON = decodeBase64URL(tokenParts[1])\n\n      let parsed: any = undefined\n      try {\n        parsed = JSON.parse(bodyJSON)\n      } catch (e) {\n        throw new Error('access_token is not a proper JWT, invalid JSON in body')\n      }\n\n      if (typeof parsed === 'object' && parsed && typeof parsed.exp === 'number') {\n        expires_at = parsed.exp\n        expires_in = timeNow - parsed.exp\n      } else {\n        throw new Error('access_token is not a proper JWT, missing exp claim')\n      }\n\n      if (timeNow > expires_at) {\n        const { data, error } = await this.api.refreshAccessToken(refresh_token)\n        if (error) {\n          return { session: null, error: error }\n        }\n\n        session = data!\n      } else {\n        const { user, error } = await this.api.getUser(access_token)\n        if (error) throw error\n\n        session = {\n          access_token,\n          expires_in,\n          expires_at,\n          refresh_token,\n          token_type: 'bearer',\n          user: user!,\n        }\n      }\n    }\n\n    try {\n      this._saveSession(session)\n      this._notifyAllSubscribers('SIGNED_IN')\n      return { session, error: null }\n    } catch (e) {\n      return { error: e as ApiError, session: null }\n    }\n  }\n\n  /**\n   * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n   * @param access_token a jwt access token\n   */\n  setAuth(access_token: string): Session {\n    this.currentSession = {\n      ...this.currentSession,\n      access_token,\n      token_type: 'bearer',\n      user: this.user(),\n    }\n\n    this._notifyAllSubscribers('TOKEN_REFRESHED')\n\n    return this.currentSession\n  }\n\n  /**\n   * Gets the session data from a URL string\n   * @param options.storeSession Optionally store the session in the browser\n   */\n  async getSessionFromUrl(options?: {\n    storeSession?: boolean\n  }): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      if (!isBrowser()) throw new Error('No browser detected.')\n\n      const error_description = getParameterByName('error_description')\n      if (error_description) throw new Error(error_description)\n\n      const provider_token = getParameterByName('provider_token')\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\n      const access_token = getParameterByName('access_token')\n      if (!access_token) throw new Error('No access_token detected.')\n      const expires_in = getParameterByName('expires_in')\n      if (!expires_in) throw new Error('No expires_in detected.')\n      const refresh_token = getParameterByName('refresh_token')\n      if (!refresh_token) throw new Error('No refresh_token detected.')\n      const token_type = getParameterByName('token_type')\n      if (!token_type) throw new Error('No token_type detected.')\n\n      const timeNow = Math.round(Date.now() / 1000)\n      const expires_at = timeNow + parseInt(expires_in)\n\n      const { user, error } = await this.api.getUser(access_token)\n      if (error) throw error\n\n      const session: Session = {\n        provider_token,\n        provider_refresh_token,\n        access_token,\n        expires_in: parseInt(expires_in),\n        expires_at,\n        refresh_token,\n        token_type,\n        user: user!,\n      }\n      if (options?.storeSession) {\n        this._saveSession(session)\n        const recoveryMode = getParameterByName('type')\n        this._notifyAllSubscribers('SIGNED_IN')\n        if (recoveryMode === 'recovery') {\n          this._notifyAllSubscribers('PASSWORD_RECOVERY')\n        }\n      }\n      // Remove tokens from URL\n      window.location.hash = ''\n\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`. There is no way to revoke a user's session JWT before it automatically expires\n   */\n  async signOut(): Promise<{ error: ApiError | null }> {\n    const accessToken = this.currentSession?.access_token\n    this._removeSession()\n    this._notifyAllSubscribers('SIGNED_OUT')\n    if (accessToken) {\n      const { error } = await this.api.signOut(accessToken)\n      if (error) return { error }\n    }\n    return { error: null }\n  }\n\n  /**\n   * Receive a notification every time an auth event happens.\n   * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n   */\n  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): {\n    data: Subscription | null\n    error: ApiError | null\n  } {\n    try {\n      const id: string = uuid()\n      const subscription: Subscription = {\n        id,\n        callback,\n        unsubscribe: () => {\n          this.stateChangeEmitters.delete(id)\n        },\n      }\n      this.stateChangeEmitters.set(id, subscription)\n      return { data: subscription, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  private async _handleEmailSignIn(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ) {\n    try {\n      const { data, error } = await this.api.signInWithEmail(email, password, {\n        redirectTo: options.redirectTo,\n        captchaToken: options.captchaToken,\n      })\n      if (error || !data) return { data: null, user: null, session: null, error }\n\n      if (data?.user?.confirmed_at || data?.user?.email_confirmed_at) {\n        this._saveSession(data)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      return { data, user: data.user, session: data, error: null }\n    } catch (e) {\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  private async _handlePhoneSignIn(\n    phone: string,\n    password: string,\n    options: {\n      captchaToken?: string\n    } = {}\n  ) {\n    try {\n      const { data, error } = await this.api.signInWithPhone(phone, password, options)\n      if (error || !data) return { data: null, user: null, session: null, error }\n\n      if (data?.user?.phone_confirmed_at) {\n        this._saveSession(data)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      return { data, user: data.user, session: data, error: null }\n    } catch (e) {\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  private _handleProviderSignIn(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    } = {}\n  ) {\n    const url: string = this.api.getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams,\n    })\n\n    try {\n      // try to open on the browser\n      if (isBrowser()) {\n        window.location.href = url\n      }\n      return { provider, url, data: null, session: null, user: null, error: null }\n    } catch (e) {\n      // fallback to returning the URL\n      if (url) return { provider, url, data: null, session: null, user: null, error: null }\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  private async _handleOpenIDConnectSignIn({\n    id_token,\n    nonce,\n    client_id,\n    issuer,\n    provider,\n  }: OpenIDConnectCredentials): Promise<{\n    session: Session | null\n    user: User | null\n    error: ApiError | null\n  }> {\n    if (id_token && nonce && ((client_id && issuer) || provider)) {\n      try {\n        const { data, error } = await this.api.signInWithOpenIDConnect({\n          id_token,\n          nonce,\n          client_id,\n          issuer,\n          provider,\n        })\n        if (error || !data) return { user: null, session: null, error }\n        this._saveSession(data)\n        this._notifyAllSubscribers('SIGNED_IN')\n        return { user: data.user, session: data, error: null }\n      } catch (e) {\n        return { user: null, session: null, error: e as ApiError }\n      }\n    }\n    throw new Error(`You must provide a OpenID Connect provider with your id token and nonce.`)\n  }\n\n  /**\n   * Attempts to get the session from LocalStorage\n   * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n   */\n  private _recoverSession() {\n    try {\n      const data = getItemSynchronously(this.localStorage, STORAGE_KEY)\n      if (!data) return null\n      const { currentSession, expiresAt } = data\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if (expiresAt >= timeNow + EXPIRY_MARGIN && currentSession?.user) {\n        this._saveSession(currentSession)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n    } catch (error) {\n      console.log('error', error)\n    }\n  }\n\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  private async _recoverAndRefresh() {\n    try {\n      const data = await getItemAsync(this.localStorage, STORAGE_KEY)\n      if (!data) return null\n      const { currentSession, expiresAt } = data\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if (expiresAt < timeNow + EXPIRY_MARGIN) {\n        if (this.autoRefreshToken && currentSession.refresh_token) {\n          this.networkRetries++\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\n          if (error) {\n            console.log(error.message)\n            if (\n              error.message === NETWORK_FAILURE.ERROR_MESSAGE &&\n              this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\n            ) {\n              if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n              this.refreshTokenTimer = setTimeout(\n                () => this._recoverAndRefresh(),\n                NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100 // exponential backoff\n              )\n              return\n            }\n            await this._removeSession()\n          }\n          this.networkRetries = 0\n        } else {\n          this._removeSession()\n        }\n      } else if (!currentSession) {\n        console.log('Current session is missing data.')\n        this._removeSession()\n      } else {\n        // should be handled on _recoverSession method already\n        // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n        this._saveSession(currentSession)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n    } catch (err) {\n      console.error(err)\n      return null\n    }\n  }\n\n  private async _callRefreshToken(refresh_token = this.currentSession?.refresh_token) {\n    try {\n      if (!refresh_token) {\n        throw new Error('No current session.')\n      }\n      const { data, error } = await this.api.refreshAccessToken(refresh_token)\n      if (error) throw error\n      if (!data) throw Error('Invalid session data.')\n\n      this._saveSession(data)\n      this._notifyAllSubscribers('TOKEN_REFRESHED')\n      this._notifyAllSubscribers('SIGNED_IN')\n\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  private _notifyAllSubscribers(event: AuthChangeEvent) {\n    this.stateChangeEmitters.forEach((x) => x.callback(event, this.currentSession))\n  }\n\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  private _saveSession(session: Session) {\n    this.currentSession = session\n    this.currentUser = session.user\n\n    const expiresAt = session.expires_at\n    if (expiresAt) {\n      const timeNow = Math.round(Date.now() / 1000)\n      const expiresIn = expiresAt - timeNow\n      const refreshDurationBeforeExpires = expiresIn > EXPIRY_MARGIN ? EXPIRY_MARGIN : 0.5\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000)\n    }\n\n    // Do we need any extra check before persist session\n    // access_token or user ?\n    if (this.persistSession && session.expires_at) {\n      this._persistSession(this.currentSession)\n    }\n  }\n\n  private _persistSession(currentSession: Session) {\n    const data = { currentSession, expiresAt: currentSession.expires_at }\n    setItemAsync(this.localStorage, STORAGE_KEY, data)\n  }\n\n  private async _removeSession() {\n    this.currentSession = null\n    this.currentUser = null\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n    removeItemAsync(this.localStorage, STORAGE_KEY)\n  }\n\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds\n   */\n  private _startAutoRefreshToken(value: number) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n    if (value <= 0 || !this.autoRefreshToken) return\n\n    this.refreshTokenTimer = setTimeout(async () => {\n      this.networkRetries++\n      const { error } = await this._callRefreshToken()\n      if (!error) this.networkRetries = 0\n      if (\n        error?.message === NETWORK_FAILURE.ERROR_MESSAGE &&\n        this.networkRetries < NETWORK_FAILURE.MAX_RETRIES\n      )\n        this._startAutoRefreshToken(NETWORK_FAILURE.RETRY_INTERVAL ** this.networkRetries * 100) // exponential backoff\n    }, value)\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref()\n  }\n\n  /**\n   * Listens for changes to LocalStorage and updates the current session.\n   */\n  private _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !window?.addEventListener) {\n      return false\n    }\n\n    try {\n      window?.addEventListener('storage', (e: StorageEvent) => {\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue))\n          if (newSession?.currentSession?.access_token) {\n            this._saveSession(newSession.currentSession)\n            this._notifyAllSubscribers('SIGNED_IN')\n          } else {\n            this._removeSession()\n            this._notifyAllSubscribers('SIGNED_OUT')\n          }\n        }\n      })\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error)\n    }\n  }\n\n  private _handleVisibilityChange() {\n    if (!this.multiTab || !isBrowser() || !window?.addEventListener) {\n      return false\n    }\n\n    try {\n      window?.addEventListener('visibilitychange', () => {\n        if (document.visibilityState === 'visible') {\n          this._recoverAndRefresh()\n        }\n      })\n    } catch (error) {\n      console.error('_handleVisibilityChange', error)\n    }\n  }\n}\n","/**\n * https://mathiasbynens.be/notes/globalthis\n */\nexport function polyfillGlobalThis() {\n    if (typeof globalThis === 'object')\n        return;\n    try {\n        Object.defineProperty(Object.prototype, '__magic__', {\n            get: function () {\n                return this;\n            },\n            configurable: true,\n        });\n        // @ts-expect-error 'Allow access to magic'\n        __magic__.globalThis = __magic__;\n        // @ts-expect-error 'Allow access to magic'\n        delete Object.prototype.__magic__;\n    }\n    catch (e) {\n        if (typeof self !== 'undefined') {\n            // @ts-expect-error 'Allow access to globals'\n            self.globalThis = self;\n        }\n    }\n}\n//# sourceMappingURL=polyfills.js.map","/**\n * https://mathiasbynens.be/notes/globalthis\n */\nexport function polyfillGlobalThis() {\n  if (typeof globalThis === 'object') return\n  try {\n    Object.defineProperty(Object.prototype, '__magic__', {\n      get: function () {\n        return this\n      },\n      configurable: true,\n    })\n    // @ts-expect-error 'Allow access to magic'\n    __magic__.globalThis = __magic__\n    // @ts-expect-error 'Allow access to magic'\n    delete Object.prototype.__magic__\n  } catch (e) {\n    if (typeof self !== 'undefined') {\n      // @ts-expect-error 'Allow access to globals'\n      self.globalThis = self\n    }\n  }\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","export type Provider =\n  | 'apple'\n  | 'azure'\n  | 'bitbucket'\n  | 'discord'\n  | 'facebook'\n  | 'github'\n  | 'gitlab'\n  | 'google'\n  | 'keycloak'\n  | 'linkedin'\n  | 'notion'\n  | 'slack'\n  | 'spotify'\n  | 'twitch'\n  | 'twitter'\n  | 'workos'\n\nexport type AuthChangeEvent =\n  | 'PASSWORD_RECOVERY'\n  | 'SIGNED_IN'\n  | 'SIGNED_OUT'\n  | 'TOKEN_REFRESHED'\n  | 'USER_UPDATED'\n  | 'USER_DELETED'\n\nexport interface ApiError {\n  message: string\n  status: number\n}\n\nexport interface Session {\n  provider_token?: string | null\n  provider_refresh_token?: string | null\n  access_token: string\n  /**\n   * The number of seconds until the token expires (since it was issued). Returned when a login is confirmed.\n   */\n  expires_in?: number\n  /**\n   * A timestamp of when the token will expire. Returned when a login is confirmed.\n   */\n  expires_at?: number\n  refresh_token?: string\n  token_type: string\n  user: User | null\n}\n\nexport interface UserIdentity {\n  id: string\n  user_id: string\n  identity_data: {\n    [key: string]: any\n  }\n  provider: string\n  created_at: string\n  last_sign_in_at: string\n  updated_at?: string\n}\n\nexport interface UserAppMetadata {\n  provider?: string\n  [key: string]: any\n}\n\nexport interface UserMetadata {\n  [key: string]: any\n}\n\nexport interface User {\n  id: string\n  app_metadata: UserAppMetadata\n  user_metadata: UserMetadata\n  aud: string\n  confirmation_sent_at?: string\n  recovery_sent_at?: string\n  email_change_sent_at?: string\n  new_email?: string\n  invited_at?: string\n  action_link?: string\n  email?: string\n  phone?: string\n  created_at: string\n  confirmed_at?: string\n  email_confirmed_at?: string\n  phone_confirmed_at?: string\n  last_sign_in_at?: string\n  role?: string\n  updated_at?: string\n  identities?: UserIdentity[]\n}\n\nexport interface UserAttributes {\n  /**\n   * The user's email.\n   */\n  email?: string\n\n  /**\n   * The user's phone.\n   */\n  phone?: string\n\n  /**\n   * The user's password.\n   */\n  password?: string\n\n  /**\n   * An email change token.\n   */\n  email_change_token?: string\n\n  /**\n   * A custom data object for user_metadata that a user can modify. Can be any JSON.\n   */\n  data?: object\n}\n\nexport interface AdminUserAttributes extends UserAttributes {\n  /**\n   * A custom data object for user_metadata.\n   *\n   * Can be any JSON.\n   *\n   * Only a service role can modify.\n   *\n   * Note: When using the GoTrueAdminApi and wanting to modify a user's user_metadata,\n   * this attribute is used instead of UserAttributes data.\n   *\n   */\n  user_metadata?: object\n\n  /**\n   * A custom data object for app_metadata that.\n   *\n   * Only a service role can modify.\n   *\n   * Can be any JSON that includes app-specific info, such as identity providers, roles, and other\n   * access control information.\n   */\n  app_metadata?: object\n\n  /**\n   * Sets if a user has confirmed their email address.\n   *\n   * Only a service role can modify.\n   */\n  email_confirm?: boolean\n\n  /**\n   * Sets if a user has confirmed their phone number.\n   *\n   * Only a service role can modify.\n   */\n  phone_confirm?: boolean\n}\n\nexport interface Subscription {\n  /**\n   * The subscriber UUID. This will be set by the client.\n   */\n  id: string\n  /**\n   * The function to call every time there is an event. eg: (eventName) => {}\n   */\n  callback: (event: AuthChangeEvent, session: Session | null) => void\n  /**\n   * Call this to remove the listener.\n   */\n  unsubscribe: () => void\n}\n\nexport interface CookieOptions {\n  // (Optional) The Cookie name prefix. Defaults to `sb` meaning the cookies will be `sb-access-token` and `sb-refresh-token`.\n  name?: string\n  // (Optional) The cookie lifetime (expiration) in seconds. Set to 8 hours by default.\n  lifetime?: number\n  // (Optional) The cookie domain this should run on. Leave it blank to restrict it to your domain.\n  domain?: string\n  path?: string\n  // (Optional) SameSite configuration for the session cookie. Defaults to 'lax', but can be changed to 'strict' or 'none'. Set it to false if you want to disable the SameSite setting.\n  sameSite?: string\n}\n\nexport interface UserCredentials {\n  email?: string\n  phone?: string\n  password?: string\n  refreshToken?: string\n  // (Optional) The name of the provider.\n  provider?: Provider\n  oidc?: OpenIDConnectCredentials\n}\n\nexport type VerifyOTPParams = VerifyMobileOTPParams | VerifyEmailOTPParams\nexport interface VerifyMobileOTPParams {\n  email?: undefined\n  phone: string\n  token: string\n  type?: MobileOTPType\n}\nexport interface VerifyEmailOTPParams {\n  email: string\n  phone?: undefined\n  token: string\n  type: EmailOTPType\n}\nexport type MobileOTPType = 'sms' | 'phone_change'\nexport type EmailOTPType = 'signup' | 'invite' | 'magiclink' | 'recovery' | 'email_change'\n\nexport interface OpenIDConnectCredentials {\n  id_token: string\n  nonce: string\n  provider?: Provider\n  client_id?: string\n  issuer?: string\n}\n\ntype AnyFunction = (...args: any[]) => any\ntype MaybePromisify<T> = T | Promise<T>\n\ntype PromisifyMethods<T> = {\n  [K in keyof T]: T[K] extends AnyFunction\n    ? (...args: Parameters<T[K]>) => MaybePromisify<ReturnType<T[K]>>\n    : T[K]\n}\n\nexport type SupportedStorage = PromisifyMethods<Pick<Storage, 'getItem' | 'setItem' | 'removeItem'>>\n","import { PostgrestQueryBuilder } from '@supabase/postgrest-js';\nimport { SupabaseRealtimeClient } from './SupabaseRealtimeClient';\nexport class SupabaseQueryBuilder extends PostgrestQueryBuilder {\n    constructor(url, { headers = {}, schema, realtime, table, fetch, shouldThrowOnError, }) {\n        super(url, { headers, schema, fetch, shouldThrowOnError });\n        this._subscription = null;\n        this._realtime = realtime;\n        this._headers = headers;\n        this._schema = schema;\n        this._table = table;\n    }\n    /**\n     * Subscribe to realtime changes in your database.\n     * @param event The database event which you would like to receive updates for, or you can use the special wildcard `*` to listen to all changes.\n     * @param callback A callback that will handle the payload that is sent whenever your database changes.\n     */\n    on(event, callback) {\n        if (!this._realtime.isConnected()) {\n            this._realtime.connect();\n        }\n        if (!this._subscription) {\n            this._subscription = new SupabaseRealtimeClient(this._realtime, this._headers, this._schema, this._table);\n        }\n        return this._subscription.on(event, callback);\n    }\n}\n//# sourceMappingURL=SupabaseQueryBuilder.js.map","import { PostgrestQueryBuilder } from '@supabase/postgrest-js'\nimport { SupabaseRealtimeClient } from './SupabaseRealtimeClient'\nimport { RealtimeClient } from '@supabase/realtime-js'\nimport { Fetch, GenericObject, SupabaseEventTypes, SupabaseRealtimePayload } from './types'\n\nexport class SupabaseQueryBuilder<T> extends PostgrestQueryBuilder<T> {\n  private _subscription: SupabaseRealtimeClient | null = null\n  private _realtime: RealtimeClient\n  private _headers: GenericObject\n  private _schema: string\n  private _table: string\n\n  constructor(\n    url: string,\n    {\n      headers = {},\n      schema,\n      realtime,\n      table,\n      fetch,\n      shouldThrowOnError,\n    }: {\n      headers?: GenericObject\n      schema: string\n      realtime: RealtimeClient\n      table: string\n      fetch?: Fetch\n      shouldThrowOnError?: boolean\n    }\n  ) {\n    super(url, { headers, schema, fetch, shouldThrowOnError })\n\n    this._realtime = realtime\n    this._headers = headers\n    this._schema = schema\n    this._table = table\n  }\n\n  /**\n   * Subscribe to realtime changes in your database.\n   * @param event The database event which you would like to receive updates for, or you can use the special wildcard `*` to listen to all changes.\n   * @param callback A callback that will handle the payload that is sent whenever your database changes.\n   */\n  on(\n    event: SupabaseEventTypes,\n    callback: (payload: SupabaseRealtimePayload<T>) => void\n  ): SupabaseRealtimeClient {\n    if (!this._realtime.isConnected()) {\n      this._realtime.connect()\n    }\n    if (!this._subscription) {\n      this._subscription = new SupabaseRealtimeClient(\n        this._realtime,\n        this._headers,\n        this._schema,\n        this._table\n      )\n    }\n    return this._subscription.on(event, callback)\n  }\n}\n","import PostgrestClient from './PostgrestClient'\nimport PostgrestFilterBuilder from './lib/PostgrestFilterBuilder'\nimport PostgrestQueryBuilder from './lib/PostgrestQueryBuilder'\nimport {\n  PostgrestBuilder,\n  PostgrestResponse,\n  PostgrestSingleResponse,\n  PostgrestMaybeSingleResponse,\n  PostgrestError,\n} from './lib/types'\n\nexport {\n  PostgrestClient,\n  PostgrestBuilder,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestResponse,\n  PostgrestSingleResponse,\n  PostgrestMaybeSingleResponse,\n  PostgrestError,\n}\n","import PostgrestQueryBuilder from './lib/PostgrestQueryBuilder';\nimport PostgrestRpcBuilder from './lib/PostgrestRpcBuilder';\nimport { DEFAULT_HEADERS } from './lib/constants';\nexport default class PostgrestClient {\n    /**\n     * Creates a PostgREST client.\n     *\n     * @param url  URL of the PostgREST endpoint.\n     * @param headers  Custom headers.\n     * @param schema  Postgres schema to switch to.\n     */\n    constructor(url, { headers = {}, schema, fetch, throwOnError, } = {}) {\n        this.url = url;\n        this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n        this.schema = schema;\n        this.fetch = fetch;\n        this.shouldThrowOnError = throwOnError;\n    }\n    /**\n     * Authenticates the request with JWT.\n     *\n     * @param token  The JWT token to use.\n     */\n    auth(token) {\n        this.headers['Authorization'] = `Bearer ${token}`;\n        return this;\n    }\n    /**\n     * Perform a table operation.\n     *\n     * @param table  The table name to operate on.\n     */\n    from(table) {\n        const url = `${this.url}/${table}`;\n        return new PostgrestQueryBuilder(url, {\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            shouldThrowOnError: this.shouldThrowOnError,\n        });\n    }\n    /**\n     * Perform a function call.\n     *\n     * @param fn  The function name to call.\n     * @param params  The parameters to pass to the function call.\n     * @param head  When set to true, no data will be returned.\n     * @param count  Count algorithm to use to count rows in a table.\n     */\n    rpc(fn, params, { head = false, count = null, } = {}) {\n        const url = `${this.url}/rpc/${fn}`;\n        return new PostgrestRpcBuilder(url, {\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch,\n            shouldThrowOnError: this.shouldThrowOnError,\n        }).rpc(params, { head, count });\n    }\n}\n//# sourceMappingURL=PostgrestClient.js.map","import PostgrestQueryBuilder from './lib/PostgrestQueryBuilder'\nimport PostgrestRpcBuilder from './lib/PostgrestRpcBuilder'\nimport PostgrestFilterBuilder from './lib/PostgrestFilterBuilder'\nimport { DEFAULT_HEADERS } from './lib/constants'\nimport { Fetch } from './lib/types'\n\nexport default class PostgrestClient {\n  url: string\n  headers: { [key: string]: string }\n  schema?: string\n  fetch?: Fetch\n  shouldThrowOnError?: boolean\n\n  /**\n   * Creates a PostgREST client.\n   *\n   * @param url  URL of the PostgREST endpoint.\n   * @param headers  Custom headers.\n   * @param schema  Postgres schema to switch to.\n   */\n  constructor(\n    url: string,\n    {\n      headers = {},\n      schema,\n      fetch,\n      throwOnError,\n    }: {\n      headers?: { [key: string]: string }\n      schema?: string\n      fetch?: Fetch\n      throwOnError?: boolean\n    } = {}\n  ) {\n    this.url = url\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.schema = schema\n    this.fetch = fetch\n    this.shouldThrowOnError = throwOnError\n  }\n\n  /**\n   * Authenticates the request with JWT.\n   *\n   * @param token  The JWT token to use.\n   */\n  auth(token: string): this {\n    this.headers['Authorization'] = `Bearer ${token}`\n    return this\n  }\n\n  /**\n   * Perform a table operation.\n   *\n   * @param table  The table name to operate on.\n   */\n  from<T = any>(table: string): PostgrestQueryBuilder<T> {\n    const url = `${this.url}/${table}`\n    return new PostgrestQueryBuilder<T>(url, {\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      shouldThrowOnError: this.shouldThrowOnError,\n    })\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn  The function name to call.\n   * @param params  The parameters to pass to the function call.\n   * @param head  When set to true, no data will be returned.\n   * @param count  Count algorithm to use to count rows in a table.\n   */\n  rpc<T = any>(\n    fn: string,\n    params?: object,\n    {\n      head = false,\n      count = null,\n    }: {\n      head?: boolean\n      count?: null | 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<T> {\n    const url = `${this.url}/rpc/${fn}`\n    return new PostgrestRpcBuilder<T>(url, {\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      shouldThrowOnError: this.shouldThrowOnError,\n    }).rpc(params, { head, count })\n  }\n}\n","import { PostgrestBuilder } from './types';\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder';\nexport default class PostgrestQueryBuilder extends PostgrestBuilder {\n    constructor(url, { headers = {}, schema, fetch, shouldThrowOnError, } = {}) {\n        super({ fetch, shouldThrowOnError });\n        this.url = new URL(url);\n        this.headers = Object.assign({}, headers);\n        this.schema = schema;\n    }\n    /**\n     * Performs vertical filtering with SELECT.\n     *\n     * @param columns  The columns to retrieve, separated by commas.\n     * @param head  When set to true, select will void data.\n     * @param count  Count algorithm to use to count rows in a table.\n     */\n    select(columns = '*', { head = false, count = null, } = {}) {\n        this.method = 'GET';\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = columns\n            .split('')\n            .map((c) => {\n            if (/\\s/.test(c) && !quoted) {\n                return '';\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        })\n            .join('');\n        this.url.searchParams.set('select', cleanedColumns);\n        if (count) {\n            this.headers['Prefer'] = `count=${count}`;\n        }\n        if (head) {\n            this.method = 'HEAD';\n        }\n        return new PostgrestFilterBuilder(this);\n    }\n    insert(values, { upsert = false, onConflict, returning = 'representation', count = null, } = {}) {\n        this.method = 'POST';\n        const prefersHeaders = [`return=${returning}`];\n        if (upsert)\n            prefersHeaders.push('resolution=merge-duplicates');\n        if (upsert && onConflict !== undefined)\n            this.url.searchParams.set('on_conflict', onConflict);\n        this.body = values;\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (this.headers['Prefer']) {\n            prefersHeaders.unshift(this.headers['Prefer']);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`);\n                this.url.searchParams.set('columns', uniqueColumns.join(','));\n            }\n        }\n        return new PostgrestFilterBuilder(this);\n    }\n    /**\n     * Performs an UPSERT into the table.\n     *\n     * @param values  The values to insert.\n     * @param onConflict  By specifying the `on_conflict` query parameter, you can make UPSERT work on a column(s) that has a UNIQUE constraint.\n     * @param returning  By default the new record is returned. Set this to 'minimal' if you don't need this value.\n     * @param count  Count algorithm to use to count rows in a table.\n     * @param ignoreDuplicates  Specifies if duplicate rows should be ignored and not inserted.\n     */\n    upsert(values, { onConflict, returning = 'representation', count = null, ignoreDuplicates = false, } = {}) {\n        this.method = 'POST';\n        const prefersHeaders = [\n            `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`,\n            `return=${returning}`,\n        ];\n        if (onConflict !== undefined)\n            this.url.searchParams.set('on_conflict', onConflict);\n        this.body = values;\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (this.headers['Prefer']) {\n            prefersHeaders.unshift(this.headers['Prefer']);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new PostgrestFilterBuilder(this);\n    }\n    /**\n     * Performs an UPDATE on the table.\n     *\n     * @param values  The values to update.\n     * @param returning  By default the updated record is returned. Set this to 'minimal' if you don't need this value.\n     * @param count  Count algorithm to use to count rows in a table.\n     */\n    update(values, { returning = 'representation', count = null, } = {}) {\n        this.method = 'PATCH';\n        const prefersHeaders = [`return=${returning}`];\n        this.body = values;\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (this.headers['Prefer']) {\n            prefersHeaders.unshift(this.headers['Prefer']);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new PostgrestFilterBuilder(this);\n    }\n    /**\n     * Performs a DELETE on the table.\n     *\n     * @param returning  If `true`, return the deleted row(s) in the response.\n     * @param count  Count algorithm to use to count rows in a table.\n     */\n    delete({ returning = 'representation', count = null, } = {}) {\n        this.method = 'DELETE';\n        const prefersHeaders = [`return=${returning}`];\n        if (count) {\n            prefersHeaders.push(`count=${count}`);\n        }\n        if (this.headers['Prefer']) {\n            prefersHeaders.unshift(this.headers['Prefer']);\n        }\n        this.headers['Prefer'] = prefersHeaders.join(',');\n        return new PostgrestFilterBuilder(this);\n    }\n}\n//# sourceMappingURL=PostgrestQueryBuilder.js.map","import { Fetch, PostgrestBuilder } from './types'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\n\nexport default class PostgrestQueryBuilder<T> extends PostgrestBuilder<T> {\n  constructor(\n    url: string,\n    {\n      headers = {},\n      schema,\n      fetch,\n      shouldThrowOnError,\n    }: {\n      headers?: { [key: string]: string }\n      schema?: string\n      fetch?: Fetch\n      shouldThrowOnError?: boolean\n    } = {}\n  ) {\n    super(({ fetch, shouldThrowOnError } as unknown) as PostgrestBuilder<T>)\n    this.url = new URL(url)\n    this.headers = { ...headers }\n    this.schema = schema\n  }\n\n  /**\n   * Performs vertical filtering with SELECT.\n   *\n   * @param columns  The columns to retrieve, separated by commas.\n   * @param head  When set to true, select will void data.\n   * @param count  Count algorithm to use to count rows in a table.\n   */\n  select(\n    columns = '*',\n    {\n      head = false,\n      count = null,\n    }: {\n      head?: boolean\n      count?: null | 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<T> {\n    this.method = 'GET'\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = columns\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    if (count) {\n      this.headers['Prefer'] = `count=${count}`\n    }\n    if (head) {\n      this.method = 'HEAD'\n    }\n    return new PostgrestFilterBuilder(this)\n  }\n\n  /**\n   * Performs an INSERT into the table.\n   *\n   * @param values  The values to insert.\n   * @param returning  By default the new record is returned. Set this to 'minimal' if you don't need this value.\n   * @param count  Count algorithm to use to count rows in a table.\n   */\n  insert(\n    values: Partial<T> | Partial<T>[],\n    options?: {\n      returning?: 'minimal' | 'representation'\n      count?: null | 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<T>\n  /**\n   * @deprecated Use `upsert()` instead.\n   */\n  insert(\n    values: Partial<T> | Partial<T>[],\n    options?: {\n      upsert?: boolean\n      onConflict?: string\n      returning?: 'minimal' | 'representation'\n      count?: null | 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<T>\n  insert(\n    values: Partial<T> | Partial<T>[],\n    {\n      upsert = false,\n      onConflict,\n      returning = 'representation',\n      count = null,\n    }: {\n      upsert?: boolean\n      onConflict?: string\n      returning?: 'minimal' | 'representation'\n      count?: null | 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<T> {\n    this.method = 'POST'\n\n    const prefersHeaders = [`return=${returning}`]\n    if (upsert) prefersHeaders.push('resolution=merge-duplicates')\n\n    if (upsert && onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\n    this.body = values\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder(this)\n  }\n\n  /**\n   * Performs an UPSERT into the table.\n   *\n   * @param values  The values to insert.\n   * @param onConflict  By specifying the `on_conflict` query parameter, you can make UPSERT work on a column(s) that has a UNIQUE constraint.\n   * @param returning  By default the new record is returned. Set this to 'minimal' if you don't need this value.\n   * @param count  Count algorithm to use to count rows in a table.\n   * @param ignoreDuplicates  Specifies if duplicate rows should be ignored and not inserted.\n   */\n  upsert(\n    values: Partial<T> | Partial<T>[],\n    {\n      onConflict,\n      returning = 'representation',\n      count = null,\n      ignoreDuplicates = false,\n    }: {\n      onConflict?: string\n      returning?: 'minimal' | 'representation'\n      count?: null | 'exact' | 'planned' | 'estimated'\n      ignoreDuplicates?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<T> {\n    this.method = 'POST'\n\n    const prefersHeaders = [\n      `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`,\n      `return=${returning}`,\n    ]\n\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\n    this.body = values\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder(this)\n  }\n\n  /**\n   * Performs an UPDATE on the table.\n   *\n   * @param values  The values to update.\n   * @param returning  By default the updated record is returned. Set this to 'minimal' if you don't need this value.\n   * @param count  Count algorithm to use to count rows in a table.\n   */\n  update(\n    values: Partial<T>,\n    {\n      returning = 'representation',\n      count = null,\n    }: {\n      returning?: 'minimal' | 'representation'\n      count?: null | 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<T> {\n    this.method = 'PATCH'\n    const prefersHeaders = [`return=${returning}`]\n    this.body = values\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n    return new PostgrestFilterBuilder(this)\n  }\n\n  /**\n   * Performs a DELETE on the table.\n   *\n   * @param returning  If `true`, return the deleted row(s) in the response.\n   * @param count  Count algorithm to use to count rows in a table.\n   */\n  delete({\n    returning = 'representation',\n    count = null,\n  }: {\n    returning?: 'minimal' | 'representation'\n    count?: null | 'exact' | 'planned' | 'estimated'\n  } = {}): PostgrestFilterBuilder<T> {\n    this.method = 'DELETE'\n    const prefersHeaders = [`return=${returning}`]\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n    return new PostgrestFilterBuilder(this)\n  }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport class PostgrestBuilder {\n    constructor(builder) {\n        Object.assign(this, builder);\n        let _fetch;\n        if (builder.fetch) {\n            _fetch = builder.fetch;\n        }\n        else if (typeof fetch === 'undefined') {\n            _fetch = (...args) => __awaiter(this, void 0, void 0, function* () { return yield (yield import('cross-fetch')).fetch(...args); });\n        }\n        else {\n            _fetch = fetch;\n        }\n        this.fetch = (...args) => _fetch(...args);\n        this.shouldThrowOnError = builder.shouldThrowOnError || false;\n        this.allowEmpty = builder.allowEmpty || false;\n    }\n    /**\n     * If there's an error with the query, throwOnError will reject the promise by\n     * throwing the error instead of returning it as part of a successful response.\n     *\n     * {@link https://github.com/supabase/supabase-js/issues/92}\n     */\n    throwOnError(throwOnError) {\n        if (throwOnError === null || throwOnError === undefined) {\n            throwOnError = true;\n        }\n        this.shouldThrowOnError = throwOnError;\n        return this;\n    }\n    then(onfulfilled, onrejected) {\n        // https://postgrest.org/en/stable/api.html#switching-schemas\n        if (typeof this.schema === 'undefined') {\n            // skip\n        }\n        else if (['GET', 'HEAD'].includes(this.method)) {\n            this.headers['Accept-Profile'] = this.schema;\n        }\n        else {\n            this.headers['Content-Profile'] = this.schema;\n        }\n        if (this.method !== 'GET' && this.method !== 'HEAD') {\n            this.headers['Content-Type'] = 'application/json';\n        }\n        let res = this.fetch(this.url.toString(), {\n            method: this.method,\n            headers: this.headers,\n            body: JSON.stringify(this.body),\n            signal: this.signal,\n        }).then((res) => __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c, _d;\n            let error = null;\n            let data = null;\n            let count = null;\n            let status = res.status;\n            let statusText = res.statusText;\n            if (res.ok) {\n                const isReturnMinimal = (_a = this.headers['Prefer']) === null || _a === void 0 ? void 0 : _a.split(',').includes('return=minimal');\n                if (this.method !== 'HEAD' && !isReturnMinimal) {\n                    const text = yield res.text();\n                    if (!text) {\n                        // discard `text`\n                    }\n                    else if (this.headers['Accept'] === 'text/csv') {\n                        data = text;\n                    }\n                    else {\n                        data = JSON.parse(text);\n                    }\n                }\n                const countHeader = (_b = this.headers['Prefer']) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);\n                const contentRange = (_c = res.headers.get('content-range')) === null || _c === void 0 ? void 0 : _c.split('/');\n                if (countHeader && contentRange && contentRange.length > 1) {\n                    count = parseInt(contentRange[1]);\n                }\n            }\n            else {\n                const body = yield res.text();\n                try {\n                    error = JSON.parse(body);\n                }\n                catch (_e) {\n                    error = {\n                        message: body,\n                    };\n                }\n                if (error && this.allowEmpty && ((_d = error === null || error === void 0 ? void 0 : error.details) === null || _d === void 0 ? void 0 : _d.includes('Results contain 0 rows'))) {\n                    error = null;\n                    status = 200;\n                    statusText = 'OK';\n                }\n                if (error && this.shouldThrowOnError) {\n                    throw error;\n                }\n            }\n            const postgrestResponse = {\n                error,\n                data,\n                count,\n                status,\n                statusText,\n                body: data,\n            };\n            return postgrestResponse;\n        }));\n        if (!this.shouldThrowOnError) {\n            res = res.catch((fetchError) => ({\n                error: {\n                    message: `FetchError: ${fetchError.message}`,\n                    details: '',\n                    hint: '',\n                    code: fetchError.code || '',\n                },\n                data: null,\n                body: null,\n                count: null,\n                status: 400,\n                statusText: 'Bad Request',\n            }));\n        }\n        return res.then(onfulfilled, onrejected);\n    }\n}\n//# sourceMappingURL=types.js.map","export type Fetch = typeof fetch\n\n/**\n * Error format\n *\n * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n */\nexport type PostgrestError = {\n  message: string\n  details: string\n  hint: string\n  code: string\n}\n\n/**\n * Response format\n *\n * {@link https://github.com/supabase/supabase-js/issues/32}\n */\ninterface PostgrestResponseBase {\n  status: number\n  statusText: string\n}\n\ninterface PostgrestResponseSuccess<T> extends PostgrestResponseBase {\n  error: null\n  data: T[]\n  body: T[]\n  count: number | null\n}\ninterface PostgrestResponseFailure extends PostgrestResponseBase {\n  error: PostgrestError\n  data: null\n  // For backward compatibility: body === data\n  body: null\n  count: null\n}\nexport type PostgrestResponse<T> = PostgrestResponseSuccess<T> | PostgrestResponseFailure\n\ninterface PostgrestSingleResponseSuccess<T> extends PostgrestResponseBase {\n  error: null\n  data: T\n  // For backward compatibility: body === data\n  body: T\n}\nexport type PostgrestSingleResponse<T> =\n  | PostgrestSingleResponseSuccess<T>\n  | PostgrestResponseFailure\nexport type PostgrestMaybeSingleResponse<T> = PostgrestSingleResponse<T | null>\n\nexport abstract class PostgrestBuilder<T> implements PromiseLike<PostgrestResponse<T>> {\n  protected method!: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n  protected url!: URL\n  protected headers!: { [key: string]: string }\n  protected schema?: string\n  protected body?: Partial<T> | Partial<T>[]\n  protected shouldThrowOnError: boolean\n  protected signal?: AbortSignal\n  protected fetch: Fetch\n  protected allowEmpty: boolean\n\n  constructor(builder: PostgrestBuilder<T>) {\n    Object.assign(this, builder)\n    let _fetch: Fetch\n    if (builder.fetch) {\n      _fetch = builder.fetch\n    } else if (typeof fetch === 'undefined') {\n      _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\n    } else {\n      _fetch = fetch\n    }\n    this.fetch = (...args) => _fetch(...args)\n    this.shouldThrowOnError = builder.shouldThrowOnError || false\n    this.allowEmpty = builder.allowEmpty || false\n  }\n\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n  throwOnError(throwOnError?: boolean): this {\n    if (throwOnError === null || throwOnError === undefined) {\n      throwOnError = true\n    }\n    this.shouldThrowOnError = throwOnError\n    return this\n  }\n\n  then<TResult1 = PostgrestResponse<T>, TResult2 = never>(\n    onfulfilled?:\n      | ((value: PostgrestResponse<T>) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): PromiseLike<TResult1 | TResult2> {\n    // https://postgrest.org/en/stable/api.html#switching-schemas\n    if (typeof this.schema === 'undefined') {\n      // skip\n    } else if (['GET', 'HEAD'].includes(this.method)) {\n      this.headers['Accept-Profile'] = this.schema\n    } else {\n      this.headers['Content-Profile'] = this.schema\n    }\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\n      this.headers['Content-Type'] = 'application/json'\n    }\n\n    let res = this.fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal,\n    }).then(async (res) => {\n      let error = null\n      let data = null\n      let count = null\n      let status = res.status\n      let statusText = res.statusText\n\n      if (res.ok) {\n        const isReturnMinimal = this.headers['Prefer']?.split(',').includes('return=minimal')\n        if (this.method !== 'HEAD' && !isReturnMinimal) {\n          const text = await res.text()\n          if (!text) {\n            // discard `text`\n          } else if (this.headers['Accept'] === 'text/csv') {\n            data = text\n          } else {\n            data = JSON.parse(text)\n          }\n        }\n\n        const countHeader = this.headers['Prefer']?.match(/count=(exact|planned|estimated)/)\n        const contentRange = res.headers.get('content-range')?.split('/')\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1])\n        }\n      } else {\n        const body = await res.text()\n\n        try {\n          error = JSON.parse(body)\n        } catch {\n          error = {\n            message: body,\n          }\n        }\n\n        if (error && this.allowEmpty && error?.details?.includes('Results contain 0 rows')) {\n          error = null\n          status = 200\n          statusText = 'OK'\n        }\n\n        if (error && this.shouldThrowOnError) {\n          throw error\n        }\n      }\n\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status,\n        statusText,\n        body: data,\n      }\n\n      return postgrestResponse\n    })\n    if (!this.shouldThrowOnError) {\n      res = res.catch((fetchError) => ({\n        error: {\n          message: `FetchError: ${fetchError.message}`,\n          details: '',\n          hint: '',\n          code: fetchError.code || '',\n        },\n        data: null,\n        body: null,\n        count: null,\n        status: 400,\n        statusText: 'Bad Request',\n      }))\n    }\n\n    return res.then(onfulfilled, onrejected)\n  }\n}\n","import PostgrestTransformBuilder from './PostgrestTransformBuilder';\nexport default class PostgrestFilterBuilder extends PostgrestTransformBuilder {\n    constructor() {\n        super(...arguments);\n        /** @deprecated Use `contains()` instead. */\n        this.cs = this.contains;\n        /** @deprecated Use `containedBy()` instead. */\n        this.cd = this.containedBy;\n        /** @deprecated Use `rangeLt()` instead. */\n        this.sl = this.rangeLt;\n        /** @deprecated Use `rangeGt()` instead. */\n        this.sr = this.rangeGt;\n        /** @deprecated Use `rangeGte()` instead. */\n        this.nxl = this.rangeGte;\n        /** @deprecated Use `rangeLte()` instead. */\n        this.nxr = this.rangeLte;\n        /** @deprecated Use `rangeAdjacent()` instead. */\n        this.adj = this.rangeAdjacent;\n        /** @deprecated Use `overlaps()` instead. */\n        this.ov = this.overlaps;\n    }\n    /**\n     * Finds all rows which doesn't satisfy the filter.\n     *\n     * @param column  The column to filter on.\n     * @param operator  The operator to filter with.\n     * @param value  The value to filter with.\n     */\n    not(column, operator, value) {\n        this.url.searchParams.append(`${column}`, `not.${operator}.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows satisfying at least one of the filters.\n     *\n     * @param filters  The filters to use, separated by commas.\n     * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n     */\n    or(filters, { foreignTable } = {}) {\n        const key = typeof foreignTable === 'undefined' ? 'or' : `${foreignTable}.or`;\n        this.url.searchParams.append(key, `(${filters})`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` exactly matches the\n     * specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n    eq(column, value) {\n        this.url.searchParams.append(`${column}`, `eq.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` doesn't match the\n     * specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n    neq(column, value) {\n        this.url.searchParams.append(`${column}`, `neq.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is greater than the\n     * specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n    gt(column, value) {\n        this.url.searchParams.append(`${column}`, `gt.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is greater than or\n     * equal to the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n    gte(column, value) {\n        this.url.searchParams.append(`${column}`, `gte.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is less than the\n     * specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n    lt(column, value) {\n        this.url.searchParams.append(`${column}`, `lt.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is less than or equal\n     * to the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n    lte(column, value) {\n        this.url.searchParams.append(`${column}`, `lte.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value in the stated `column` matches the supplied\n     * `pattern` (case sensitive).\n     *\n     * @param column  The column to filter on.\n     * @param pattern  The pattern to filter with.\n     */\n    like(column, pattern) {\n        this.url.searchParams.append(`${column}`, `like.${pattern}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value in the stated `column` matches the supplied\n     * `pattern` (case insensitive).\n     *\n     * @param column  The column to filter on.\n     * @param pattern  The pattern to filter with.\n     */\n    ilike(column, pattern) {\n        this.url.searchParams.append(`${column}`, `ilike.${pattern}`);\n        return this;\n    }\n    /**\n     * A check for exact equality (null, true, false), finds all rows whose\n     * value on the stated `column` exactly match the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n    is(column, value) {\n        this.url.searchParams.append(`${column}`, `is.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose value on the stated `column` is found on the\n     * specified `values`.\n     *\n     * @param column  The column to filter on.\n     * @param values  The values to filter with.\n     */\n    in(column, values) {\n        const cleanedValues = values\n            .map((s) => {\n            // handle postgrest reserved characters\n            // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n            if (typeof s === 'string' && new RegExp('[,()]').test(s))\n                return `\"${s}\"`;\n            else\n                return `${s}`;\n        })\n            .join(',');\n        this.url.searchParams.append(`${column}`, `in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n     * Finds all rows whose json, array, or range value on the stated `column`\n     * contains the values specified in `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n    contains(column, value) {\n        if (typeof value === 'string') {\n            // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n            // keep it simple and accept a string\n            this.url.searchParams.append(`${column}`, `cs.${value}`);\n        }\n        else if (Array.isArray(value)) {\n            // array\n            this.url.searchParams.append(`${column}`, `cs.{${value.join(',')}}`);\n        }\n        else {\n            // json\n            this.url.searchParams.append(`${column}`, `cs.${JSON.stringify(value)}`);\n        }\n        return this;\n    }\n    /**\n     * Finds all rows whose json, array, or range value on the stated `column` is\n     * contained by the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n    containedBy(column, value) {\n        if (typeof value === 'string') {\n            // range\n            this.url.searchParams.append(`${column}`, `cd.${value}`);\n        }\n        else if (Array.isArray(value)) {\n            // array\n            this.url.searchParams.append(`${column}`, `cd.{${value.join(',')}}`);\n        }\n        else {\n            // json\n            this.url.searchParams.append(`${column}`, `cd.${JSON.stringify(value)}`);\n        }\n        return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` is strictly to the\n     * left of the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */\n    rangeLt(column, range) {\n        this.url.searchParams.append(`${column}`, `sl.${range}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` is strictly to\n     * the right of the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */\n    rangeGt(column, range) {\n        this.url.searchParams.append(`${column}`, `sr.${range}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` does not extend\n     * to the left of the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */\n    rangeGte(column, range) {\n        this.url.searchParams.append(`${column}`, `nxl.${range}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` does not extend\n     * to the right of the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */\n    rangeLte(column, range) {\n        this.url.searchParams.append(`${column}`, `nxr.${range}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose range value on the stated `column` is adjacent to\n     * the specified `range`.\n     *\n     * @param column  The column to filter on.\n     * @param range  The range to filter with.\n     */\n    rangeAdjacent(column, range) {\n        this.url.searchParams.append(`${column}`, `adj.${range}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose array or range value on the stated `column` overlaps\n     * (has a value in common) with the specified `value`.\n     *\n     * @param column  The column to filter on.\n     * @param value  The value to filter with.\n     */\n    overlaps(column, value) {\n        if (typeof value === 'string') {\n            // range\n            this.url.searchParams.append(`${column}`, `ov.${value}`);\n        }\n        else {\n            // array\n            this.url.searchParams.append(`${column}`, `ov.{${value.join(',')}}`);\n        }\n        return this;\n    }\n    /**\n     * Finds all rows whose text or tsvector value on the stated `column` matches\n     * the tsquery in `query`.\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     * @param type  The type of tsquery conversion to use on `query`.\n     */\n    textSearch(column, query, { config, type = null, } = {}) {\n        let typePart = '';\n        if (type === 'plain') {\n            typePart = 'pl';\n        }\n        else if (type === 'phrase') {\n            typePart = 'ph';\n        }\n        else if (type === 'websearch') {\n            typePart = 'w';\n        }\n        const configPart = config === undefined ? '' : `(${config})`;\n        this.url.searchParams.append(`${column}`, `${typePart}fts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose tsvector value on the stated `column` matches\n     * to_tsquery(`query`).\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     *\n     * @deprecated Use `textSearch()` instead.\n     */\n    fts(column, query, { config } = {}) {\n        const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n        this.url.searchParams.append(`${column}`, `fts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose tsvector value on the stated `column` matches\n     * plainto_tsquery(`query`).\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     *\n     * @deprecated Use `textSearch()` with `type: 'plain'` instead.\n     */\n    plfts(column, query, { config } = {}) {\n        const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n        this.url.searchParams.append(`${column}`, `plfts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose tsvector value on the stated `column` matches\n     * phraseto_tsquery(`query`).\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     *\n     * @deprecated Use `textSearch()` with `type: 'phrase'` instead.\n     */\n    phfts(column, query, { config } = {}) {\n        const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n        this.url.searchParams.append(`${column}`, `phfts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose tsvector value on the stated `column` matches\n     * websearch_to_tsquery(`query`).\n     *\n     * @param column  The column to filter on.\n     * @param query  The Postgres tsquery string to filter with.\n     * @param config  The text search configuration to use.\n     *\n     * @deprecated Use `textSearch()` with `type: 'websearch'` instead.\n     */\n    wfts(column, query, { config } = {}) {\n        const configPart = typeof config === 'undefined' ? '' : `(${config})`;\n        this.url.searchParams.append(`${column}`, `wfts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose `column` satisfies the filter.\n     *\n     * @param column  The column to filter on.\n     * @param operator  The operator to filter with.\n     * @param value  The value to filter with.\n     */\n    filter(column, operator, value) {\n        this.url.searchParams.append(`${column}`, `${operator}.${value}`);\n        return this;\n    }\n    /**\n     * Finds all rows whose columns match the specified `query` object.\n     *\n     * @param query  The object to filter with, with column names as keys mapped\n     *               to their filter values.\n     */\n    match(query) {\n        Object.keys(query).forEach((key) => {\n            this.url.searchParams.append(`${key}`, `eq.${query[key]}`);\n        });\n        return this;\n    }\n}\n//# sourceMappingURL=PostgrestFilterBuilder.js.map","import PostgrestTransformBuilder from './PostgrestTransformBuilder'\n\n/**\n * Filters\n */\n\ntype FilterOperator =\n  | 'eq'\n  | 'neq'\n  | 'gt'\n  | 'gte'\n  | 'lt'\n  | 'lte'\n  | 'like'\n  | 'ilike'\n  | 'is'\n  | 'in'\n  | 'cs'\n  | 'cd'\n  | 'sl'\n  | 'sr'\n  | 'nxl'\n  | 'nxr'\n  | 'adj'\n  | 'ov'\n  | 'fts'\n  | 'plfts'\n  | 'phfts'\n  | 'wfts'\n  | 'not.eq'\n  | 'not.neq'\n  | 'not.gt'\n  | 'not.gte'\n  | 'not.lt'\n  | 'not.lte'\n  | 'not.like'\n  | 'not.ilike'\n  | 'not.is'\n  | 'not.in'\n  | 'not.cs'\n  | 'not.cd'\n  | 'not.sl'\n  | 'not.sr'\n  | 'not.nxl'\n  | 'not.nxr'\n  | 'not.adj'\n  | 'not.ov'\n  | 'not.fts'\n  | 'not.plfts'\n  | 'not.phfts'\n  | 'not.wfts'\n\nexport default class PostgrestFilterBuilder<T> extends PostgrestTransformBuilder<T> {\n  /**\n   * Finds all rows which doesn't satisfy the filter.\n   *\n   * @param column  The column to filter on.\n   * @param operator  The operator to filter with.\n   * @param value  The value to filter with.\n   */\n  not(column: keyof T, operator: FilterOperator, value: any): this {\n    this.url.searchParams.append(`${column}`, `not.${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows satisfying at least one of the filters.\n   *\n   * @param filters  The filters to use, separated by commas.\n   * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n   */\n  or(filters: string, { foreignTable }: { foreignTable?: string } = {}): this {\n    const key = typeof foreignTable === 'undefined' ? 'or' : `${foreignTable}.or`\n    this.url.searchParams.append(key, `(${filters})`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` exactly matches the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  eq(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `eq.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` doesn't match the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  neq(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `neq.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is greater than the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  gt(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `gt.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is greater than or\n   * equal to the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  gte(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `gte.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is less than the\n   * specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  lt(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `lt.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is less than or equal\n   * to the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  lte(column: keyof T, value: T[keyof T]): this {\n    this.url.searchParams.append(`${column}`, `lte.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value in the stated `column` matches the supplied\n   * `pattern` (case sensitive).\n   *\n   * @param column  The column to filter on.\n   * @param pattern  The pattern to filter with.\n   */\n  like(column: keyof T, pattern: string): this {\n    this.url.searchParams.append(`${column}`, `like.${pattern}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value in the stated `column` matches the supplied\n   * `pattern` (case insensitive).\n   *\n   * @param column  The column to filter on.\n   * @param pattern  The pattern to filter with.\n   */\n  ilike(column: keyof T, pattern: string): this {\n    this.url.searchParams.append(`${column}`, `ilike.${pattern}`)\n    return this\n  }\n\n  /**\n   * A check for exact equality (null, true, false), finds all rows whose\n   * value on the stated `column` exactly match the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  is(column: keyof T, value: boolean | null): this {\n    this.url.searchParams.append(`${column}`, `is.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose value on the stated `column` is found on the\n   * specified `values`.\n   *\n   * @param column  The column to filter on.\n   * @param values  The values to filter with.\n   */\n  in(column: keyof T, values: T[keyof T][]): this {\n    const cleanedValues = values\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(`${column}`, `in.(${cleanedValues})`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose json, array, or range value on the stated `column`\n   * contains the values specified in `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  contains(column: keyof T, value: string | T[keyof T][] | object): this {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(`${column}`, `cs.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(`${column}`, `cs.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(`${column}`, `cs.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  /** @deprecated Use `contains()` instead. */\n  cs = this.contains\n\n  /**\n   * Finds all rows whose json, array, or range value on the stated `column` is\n   * contained by the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  containedBy(column: keyof T, value: string | T[keyof T][] | object): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(`${column}`, `cd.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(`${column}`, `cd.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(`${column}`, `cd.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  /** @deprecated Use `containedBy()` instead. */\n  cd = this.containedBy\n\n  /**\n   * Finds all rows whose range value on the stated `column` is strictly to the\n   * left of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeLt(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `sl.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeLt()` instead. */\n  sl = this.rangeLt\n\n  /**\n   * Finds all rows whose range value on the stated `column` is strictly to\n   * the right of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeGt(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `sr.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeGt()` instead. */\n  sr = this.rangeGt\n\n  /**\n   * Finds all rows whose range value on the stated `column` does not extend\n   * to the left of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeGte(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `nxl.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeGte()` instead. */\n  nxl = this.rangeGte\n\n  /**\n   * Finds all rows whose range value on the stated `column` does not extend\n   * to the right of the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeLte(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `nxr.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeLte()` instead. */\n  nxr = this.rangeLte\n\n  /**\n   * Finds all rows whose range value on the stated `column` is adjacent to\n   * the specified `range`.\n   *\n   * @param column  The column to filter on.\n   * @param range  The range to filter with.\n   */\n  rangeAdjacent(column: keyof T, range: string): this {\n    this.url.searchParams.append(`${column}`, `adj.${range}`)\n    return this\n  }\n\n  /** @deprecated Use `rangeAdjacent()` instead. */\n  adj = this.rangeAdjacent\n\n  /**\n   * Finds all rows whose array or range value on the stated `column` overlaps\n   * (has a value in common) with the specified `value`.\n   *\n   * @param column  The column to filter on.\n   * @param value  The value to filter with.\n   */\n  overlaps(column: keyof T, value: string | T[keyof T][]): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(`${column}`, `ov.${value}`)\n    } else {\n      // array\n      this.url.searchParams.append(`${column}`, `ov.{${value.join(',')}}`)\n    }\n    return this\n  }\n\n  /** @deprecated Use `overlaps()` instead. */\n  ov = this.overlaps\n\n  /**\n   * Finds all rows whose text or tsvector value on the stated `column` matches\n   * the tsquery in `query`.\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   * @param type  The type of tsquery conversion to use on `query`.\n   */\n  textSearch(\n    column: keyof T,\n    query: string,\n    {\n      config,\n      type = null,\n    }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' | null } = {}\n  ): this {\n    let typePart = ''\n    if (type === 'plain') {\n      typePart = 'pl'\n    } else if (type === 'phrase') {\n      typePart = 'ph'\n    } else if (type === 'websearch') {\n      typePart = 'w'\n    }\n    const configPart = config === undefined ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `${typePart}fts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * to_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` instead.\n   */\n  fts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `fts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * plainto_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'plain'` instead.\n   */\n  plfts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `plfts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * phraseto_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'phrase'` instead.\n   */\n  phfts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `phfts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose tsvector value on the stated `column` matches\n   * websearch_to_tsquery(`query`).\n   *\n   * @param column  The column to filter on.\n   * @param query  The Postgres tsquery string to filter with.\n   * @param config  The text search configuration to use.\n   *\n   * @deprecated Use `textSearch()` with `type: 'websearch'` instead.\n   */\n  wfts(column: keyof T, query: string, { config }: { config?: string } = {}): this {\n    const configPart = typeof config === 'undefined' ? '' : `(${config})`\n    this.url.searchParams.append(`${column}`, `wfts${configPart}.${query}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose `column` satisfies the filter.\n   *\n   * @param column  The column to filter on.\n   * @param operator  The operator to filter with.\n   * @param value  The value to filter with.\n   */\n  filter(column: keyof T, operator: FilterOperator, value: any): this {\n    this.url.searchParams.append(`${column}`, `${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Finds all rows whose columns match the specified `query` object.\n   *\n   * @param query  The object to filter with, with column names as keys mapped\n   *               to their filter values.\n   */\n  match(query: Record<string, unknown>): this {\n    Object.keys(query).forEach((key) => {\n      this.url.searchParams.append(`${key}`, `eq.${query[key]}`)\n    })\n    return this\n  }\n}\n","import { PostgrestBuilder } from './types';\n/**\n * Post-filters (transforms)\n */\nexport default class PostgrestTransformBuilder extends PostgrestBuilder {\n    /**\n     * Performs vertical filtering with SELECT.\n     *\n     * @param columns  The columns to retrieve, separated by commas.\n     */\n    select(columns = '*') {\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = columns\n            .split('')\n            .map((c) => {\n            if (/\\s/.test(c) && !quoted) {\n                return '';\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        })\n            .join('');\n        this.url.searchParams.set('select', cleanedColumns);\n        return this;\n    }\n    /**\n     * Orders the result with the specified `column`.\n     *\n     * @param column  The column to order on.\n     * @param ascending  If `true`, the result will be in ascending order.\n     * @param nullsFirst  If `true`, `null`s appear first.\n     * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n     */\n    order(column, { ascending = true, nullsFirst = false, foreignTable, } = {}) {\n        const key = typeof foreignTable === 'undefined' ? 'order' : `${foreignTable}.order`;\n        const existingOrder = this.url.searchParams.get(key);\n        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}.${nullsFirst ? 'nullsfirst' : 'nullslast'}`);\n        return this;\n    }\n    /**\n     * Limits the result with the specified `count`.\n     *\n     * @param count  The maximum no. of rows to limit to.\n     * @param foreignTable  The foreign table to use (for foreign columns).\n     */\n    limit(count, { foreignTable } = {}) {\n        const key = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`;\n        this.url.searchParams.set(key, `${count}`);\n        return this;\n    }\n    /**\n     * Limits the result to rows within the specified range, inclusive.\n     *\n     * @param from  The starting index from which to limit the result, inclusive.\n     * @param to  The last index to which to limit the result, inclusive.\n     * @param foreignTable  The foreign table to use (for foreign columns).\n     */\n    range(from, to, { foreignTable } = {}) {\n        const keyOffset = typeof foreignTable === 'undefined' ? 'offset' : `${foreignTable}.offset`;\n        const keyLimit = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`;\n        this.url.searchParams.set(keyOffset, `${from}`);\n        // Range is inclusive, so add 1\n        this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n        return this;\n    }\n    /**\n     * Sets the AbortSignal for the fetch request.\n     */\n    abortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    /**\n     * Retrieves only one row from the result. Result must be one row (e.g. using\n     * `limit`), otherwise this will result in an error.\n     */\n    single() {\n        this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n        return this;\n    }\n    /**\n     * Retrieves at most one row from the result. Result must be at most one row\n     * (e.g. using `eq` on a UNIQUE column), otherwise this will result in an\n     * error.\n     */\n    maybeSingle() {\n        this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n        this.allowEmpty = true;\n        return this;\n    }\n    /**\n     * Set the response type to CSV.\n     */\n    csv() {\n        this.headers['Accept'] = 'text/csv';\n        return this;\n    }\n}\n//# sourceMappingURL=PostgrestTransformBuilder.js.map","import { PostgrestBuilder, PostgrestMaybeSingleResponse, PostgrestSingleResponse } from './types'\n\n/**\n * Post-filters (transforms)\n */\n\nexport default class PostgrestTransformBuilder<T> extends PostgrestBuilder<T> {\n  /**\n   * Performs vertical filtering with SELECT.\n   *\n   * @param columns  The columns to retrieve, separated by commas.\n   */\n  select(columns = '*'): this {\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = columns\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    return this\n  }\n\n  /**\n   * Orders the result with the specified `column`.\n   *\n   * @param column  The column to order on.\n   * @param ascending  If `true`, the result will be in ascending order.\n   * @param nullsFirst  If `true`, `null`s appear first.\n   * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n   */\n  order(\n    column: keyof T,\n    {\n      ascending = true,\n      nullsFirst = false,\n      foreignTable,\n    }: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: string } = {}\n  ): this {\n    const key = typeof foreignTable === 'undefined' ? 'order' : `${foreignTable}.order`\n    const existingOrder = this.url.searchParams.get(key)\n\n    this.url.searchParams.set(\n      key,\n      `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}.${\n        nullsFirst ? 'nullsfirst' : 'nullslast'\n      }`\n    )\n    return this\n  }\n\n  /**\n   * Limits the result with the specified `count`.\n   *\n   * @param count  The maximum no. of rows to limit to.\n   * @param foreignTable  The foreign table to use (for foreign columns).\n   */\n  limit(count: number, { foreignTable }: { foreignTable?: string } = {}): this {\n    const key = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\n    this.url.searchParams.set(key, `${count}`)\n    return this\n  }\n\n  /**\n   * Limits the result to rows within the specified range, inclusive.\n   *\n   * @param from  The starting index from which to limit the result, inclusive.\n   * @param to  The last index to which to limit the result, inclusive.\n   * @param foreignTable  The foreign table to use (for foreign columns).\n   */\n  range(from: number, to: number, { foreignTable }: { foreignTable?: string } = {}): this {\n    const keyOffset = typeof foreignTable === 'undefined' ? 'offset' : `${foreignTable}.offset`\n    const keyLimit = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\n    this.url.searchParams.set(keyOffset, `${from}`)\n    // Range is inclusive, so add 1\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`)\n    return this\n  }\n\n  /**\n   * Sets the AbortSignal for the fetch request.\n   */\n  abortSignal(signal: AbortSignal): this {\n    this.signal = signal\n    return this\n  }\n\n  /**\n   * Retrieves only one row from the result. Result must be one row (e.g. using\n   * `limit`), otherwise this will result in an error.\n   */\n  single(): PromiseLike<PostgrestSingleResponse<T>> {\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\n    return this as PromiseLike<PostgrestSingleResponse<T>>\n  }\n\n  /**\n   * Retrieves at most one row from the result. Result must be at most one row\n   * (e.g. using `eq` on a UNIQUE column), otherwise this will result in an\n   * error.\n   */\n  maybeSingle(): PromiseLike<PostgrestMaybeSingleResponse<T>> {\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\n    this.allowEmpty = true\n    return this as PromiseLike<PostgrestMaybeSingleResponse<T>>\n  }\n\n  /**\n   * Set the response type to CSV.\n   */\n  csv(): PromiseLike<PostgrestSingleResponse<string>> {\n    this.headers['Accept'] = 'text/csv'\n    return this as PromiseLike<PostgrestSingleResponse<string>>\n  }\n}\n","import { PostgrestBuilder } from './types';\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder';\nexport default class PostgrestRpcBuilder extends PostgrestBuilder {\n    constructor(url, { headers = {}, schema, fetch, shouldThrowOnError, } = {}) {\n        super({ fetch, shouldThrowOnError });\n        this.url = new URL(url);\n        this.headers = Object.assign({}, headers);\n        this.schema = schema;\n    }\n    /**\n     * Perform a function call.\n     */\n    rpc(params, { head = false, count = null, } = {}) {\n        if (head) {\n            this.method = 'HEAD';\n            if (params) {\n                Object.entries(params).forEach(([name, value]) => {\n                    this.url.searchParams.append(name, value);\n                });\n            }\n        }\n        else {\n            this.method = 'POST';\n            this.body = params;\n        }\n        if (count) {\n            if (this.headers['Prefer'] !== undefined)\n                this.headers['Prefer'] += `,count=${count}`;\n            else\n                this.headers['Prefer'] = `count=${count}`;\n        }\n        return new PostgrestFilterBuilder(this);\n    }\n}\n//# sourceMappingURL=PostgrestRpcBuilder.js.map","import { Fetch, PostgrestBuilder } from './types'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\n\nexport default class PostgrestRpcBuilder<T> extends PostgrestBuilder<T> {\n  constructor(\n    url: string,\n    {\n      headers = {},\n      schema,\n      fetch,\n      shouldThrowOnError,\n    }: {\n      headers?: { [key: string]: string }\n      schema?: string\n      fetch?: Fetch\n      shouldThrowOnError?: boolean\n    } = {}\n  ) {\n    super(({ fetch, shouldThrowOnError } as unknown) as PostgrestBuilder<T>)\n    this.url = new URL(url)\n    this.headers = { ...headers }\n    this.schema = schema\n  }\n\n  /**\n   * Perform a function call.\n   */\n  rpc(\n    params?: object,\n    {\n      head = false,\n      count = null,\n    }: {\n      head?: boolean\n      count?: null | 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<T> {\n    if (head) {\n      this.method = 'HEAD'\n\n      if (params) {\n        Object.entries(params).forEach(([name, value]) => {\n          this.url.searchParams.append(name, value)\n        })\n      }\n    } else {\n      this.method = 'POST'\n      this.body = params\n    }\n\n    if (count) {\n      if (this.headers['Prefer'] !== undefined) this.headers['Prefer'] += `,count=${count}`\n      else this.headers['Prefer'] = `count=${count}`\n    }\n\n    return new PostgrestFilterBuilder(this)\n  }\n}\n","import { version } from './version';\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `postgrest-js/${version}` };\n//# sourceMappingURL=constants.js.map","import { version } from './version'\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `postgrest-js/${version}` }\n","// generated by genversion\nexport const version = '0.37.4';\n//# sourceMappingURL=version.js.map","// generated by genversion\nexport const version = '0.37.4'\n","import { Transformers } from '@supabase/realtime-js';\nexport class SupabaseRealtimeClient {\n    constructor(socket, headers, schema, tableName) {\n        const chanParams = {};\n        const topic = tableName === '*' ? `realtime:${schema}` : `realtime:${schema}:${tableName}`;\n        const userToken = headers['Authorization'].split(' ')[1];\n        if (userToken) {\n            chanParams['user_token'] = userToken;\n        }\n        this.subscription = socket.channel(topic, chanParams);\n    }\n    getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {},\n        };\n        if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n            records.new = Transformers.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n            records.old = Transformers.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n    /**\n     * The event you want to listen to.\n     *\n     * @param event The event\n     * @param callback A callback function that is called whenever the event occurs.\n     */\n    on(event, callback) {\n        this.subscription.on(event, (payload) => {\n            let enrichedPayload = {\n                schema: payload.schema,\n                table: payload.table,\n                commit_timestamp: payload.commit_timestamp,\n                eventType: payload.type,\n                new: {},\n                old: {},\n                errors: payload.errors,\n            };\n            enrichedPayload = Object.assign(Object.assign({}, enrichedPayload), this.getPayloadRecords(payload));\n            callback(enrichedPayload);\n        });\n        return this;\n    }\n    /**\n     * Enables the subscription.\n     */\n    subscribe(callback = () => { }) {\n        this.subscription.onError((e) => callback('SUBSCRIPTION_ERROR', e));\n        this.subscription.onClose(() => callback('CLOSED'));\n        this.subscription\n            .subscribe()\n            .receive('ok', () => callback('SUBSCRIBED'))\n            .receive('error', (e) => callback('SUBSCRIPTION_ERROR', e))\n            .receive('timeout', () => callback('RETRYING_AFTER_TIMEOUT'));\n        return this.subscription;\n    }\n}\n//# sourceMappingURL=SupabaseRealtimeClient.js.map","import { RealtimeSubscription, RealtimeClient, Transformers } from '@supabase/realtime-js'\nimport { GenericObject, SupabaseEventTypes, SupabaseRealtimePayload } from './types'\n\nexport class SupabaseRealtimeClient {\n  subscription: RealtimeSubscription\n\n  constructor(socket: RealtimeClient, headers: GenericObject, schema: string, tableName: string) {\n    const chanParams: GenericObject = {}\n    const topic = tableName === '*' ? `realtime:${schema}` : `realtime:${schema}:${tableName}`\n    const userToken = headers['Authorization'].split(' ')[1]\n\n    if (userToken) {\n      chanParams['user_token'] = userToken\n    }\n\n    this.subscription = socket.channel(topic, chanParams) as RealtimeSubscription\n  }\n\n  private getPayloadRecords(payload: any) {\n    const records = {\n      new: {},\n      old: {},\n    }\n\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(payload.columns, payload.record)\n    }\n\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(payload.columns, payload.old_record)\n    }\n\n    return records\n  }\n\n  /**\n   * The event you want to listen to.\n   *\n   * @param event The event\n   * @param callback A callback function that is called whenever the event occurs.\n   */\n  on(event: SupabaseEventTypes, callback: (payload: SupabaseRealtimePayload<any>) => void) {\n    this.subscription.on(event, (payload: any) => {\n      let enrichedPayload: SupabaseRealtimePayload<any> = {\n        schema: payload.schema,\n        table: payload.table,\n        commit_timestamp: payload.commit_timestamp,\n        eventType: payload.type,\n        new: {},\n        old: {},\n        errors: payload.errors,\n      }\n\n      enrichedPayload = { ...enrichedPayload, ...this.getPayloadRecords(payload) }\n\n      callback(enrichedPayload)\n    })\n    return this\n  }\n\n  /**\n   * Enables the subscription.\n   */\n  subscribe(callback: Function = () => {}) {\n    this.subscription.onError((e: Error) => callback('SUBSCRIPTION_ERROR', e))\n    this.subscription.onClose(() => callback('CLOSED'))\n    this.subscription\n      .subscribe()\n      .receive('ok', () => callback('SUBSCRIBED'))\n      .receive('error', (e: Error) => callback('SUBSCRIPTION_ERROR', e))\n      .receive('timeout', () => callback('RETRYING_AFTER_TIMEOUT'))\n    return this.subscription\n  }\n}\n","import * as Transformers from './lib/transformers'\nimport RealtimeClient, {\n  Options as RealtimeClientOptions,\n} from './RealtimeClient'\nimport RealtimeSubscription from './RealtimeSubscription'\n\nexport {\n  RealtimeClient,\n  RealtimeClientOptions,\n  RealtimeSubscription,\n  Transformers,\n}\n","/**\n * Helpers to convert the change Payload into native JS types.\n */\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nexport var PostgresTypes;\n(function (PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"text\"] = \"text\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nexport const convertChangeData = (columns, record, options = {}) => {\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    return Object.keys(record).reduce((acc, rec_key) => {\n        acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n        return acc;\n    }, {});\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nexport const convertColumn = (columnName, columns, record, skipTypes) => {\n    const column = columns.find((x) => x.name === columnName);\n    const colType = column === null || column === void 0 ? void 0 : column.type;\n    const value = record[columnName];\n    if (colType && !skipTypes.includes(colType)) {\n        return convertCell(colType, value);\n    }\n    return noop(value);\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} stringValue The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nexport const convertCell = (type, value) => {\n    // if data type is an array\n    if (type.charAt(0) === '_') {\n        const dataType = type.slice(1, type.length);\n        return toArray(value, dataType);\n    }\n    // If not null, convert to correct type.\n    switch (type) {\n        case PostgresTypes.bool:\n            return toBoolean(value);\n        case PostgresTypes.float4:\n        case PostgresTypes.float8:\n        case PostgresTypes.int2:\n        case PostgresTypes.int4:\n        case PostgresTypes.int8:\n        case PostgresTypes.numeric:\n        case PostgresTypes.oid:\n            return toNumber(value);\n        case PostgresTypes.json:\n        case PostgresTypes.jsonb:\n            return toJson(value);\n        case PostgresTypes.timestamp:\n            return toTimestampString(value); // Format to be consistent with PostgREST\n        case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n        case PostgresTypes.date: // To allow users to cast it based on Timezone\n        case PostgresTypes.daterange:\n        case PostgresTypes.int4range:\n        case PostgresTypes.int8range:\n        case PostgresTypes.money:\n        case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n        case PostgresTypes.text:\n        case PostgresTypes.time: // To allow users to cast it based on Timezone\n        case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n        case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n        case PostgresTypes.tsrange:\n        case PostgresTypes.tstzrange:\n            return noop(value);\n        default:\n            // Return the value for remaining types\n            return noop(value);\n    }\n};\nconst noop = (value) => {\n    return value;\n};\nexport const toBoolean = (value) => {\n    switch (value) {\n        case 't':\n            return true;\n        case 'f':\n            return false;\n        default:\n            return value;\n    }\n};\nexport const toNumber = (value) => {\n    if (typeof value === 'string') {\n        const parsedValue = parseFloat(value);\n        if (!Number.isNaN(parsedValue)) {\n            return parsedValue;\n        }\n    }\n    return value;\n};\nexport const toJson = (value) => {\n    if (typeof value === 'string') {\n        try {\n            return JSON.parse(value);\n        }\n        catch (error) {\n            console.log(`JSON parse error: ${error}`);\n            return value;\n        }\n    }\n    return value;\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\nexport const toArray = (value, type) => {\n    if (typeof value !== 'string') {\n        return value;\n    }\n    const lastIdx = value.length - 1;\n    const closeBrace = value[lastIdx];\n    const openBrace = value[0];\n    // Confirm value is a Postgres array by checking curly brackets\n    if (openBrace === '{' && closeBrace === '}') {\n        let arr;\n        const valTrim = value.slice(1, lastIdx);\n        // TODO: find a better solution to separate Postgres array data\n        try {\n            arr = JSON.parse('[' + valTrim + ']');\n        }\n        catch (_) {\n            // WARNING: splitting on comma does not cover all edge cases\n            arr = valTrim ? valTrim.split(',') : [];\n        }\n        return arr.map((val) => convertCell(type, val));\n    }\n    return value;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nexport const toTimestampString = (value) => {\n    if (typeof value === 'string') {\n        return value.replace(' ', 'T');\n    }\n    return value;\n};\n//# sourceMappingURL=transformers.js.map","/**\n * Helpers to convert the change Payload into native JS types.\n */\n\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\n\nexport enum PostgresTypes {\n  abstime = 'abstime',\n  bool = 'bool',\n  date = 'date',\n  daterange = 'daterange',\n  float4 = 'float4',\n  float8 = 'float8',\n  int2 = 'int2',\n  int4 = 'int4',\n  int4range = 'int4range',\n  int8 = 'int8',\n  int8range = 'int8range',\n  json = 'json',\n  jsonb = 'jsonb',\n  money = 'money',\n  numeric = 'numeric',\n  oid = 'oid',\n  reltime = 'reltime',\n  text = 'text',\n  time = 'time',\n  timestamp = 'timestamp',\n  timestamptz = 'timestamptz',\n  timetz = 'timetz',\n  tsrange = 'tsrange',\n  tstzrange = 'tstzrange',\n}\n\ntype Columns = {\n  name: string // the column name. eg: \"user_id\"\n  type: string // the column type. eg: \"uuid\"\n  flags?: string[] // any special flags for the column. eg: [\"key\"]\n  type_modifier?: number // the type modifier. eg: 4294967295\n}[]\n\ntype BaseValue = null | string | number | boolean\ntype RecordValue = BaseValue | BaseValue[]\n\ntype Record = {\n  [key: string]: RecordValue\n}\n\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nexport const convertChangeData = (\n  columns: Columns,\n  record: Record,\n  options: { skipTypes?: string[] } = {}\n): Record => {\n  const skipTypes = options.skipTypes ?? []\n\n  return Object.keys(record).reduce((acc, rec_key) => {\n    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes)\n    return acc\n  }, {} as Record)\n}\n\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nexport const convertColumn = (\n  columnName: string,\n  columns: Columns,\n  record: Record,\n  skipTypes: string[]\n): RecordValue => {\n  const column = columns.find((x) => x.name === columnName)\n  const colType = column?.type\n  const value = record[columnName]\n\n  if (colType && !skipTypes.includes(colType)) {\n    return convertCell(colType, value)\n  }\n\n  return noop(value)\n}\n\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} stringValue The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nexport const convertCell = (type: string, value: RecordValue): RecordValue => {\n  // if data type is an array\n  if (type.charAt(0) === '_') {\n    const dataType = type.slice(1, type.length)\n    return toArray(value, dataType)\n  }\n\n  // If not null, convert to correct type.\n  switch (type) {\n    case PostgresTypes.bool:\n      return toBoolean(value)\n    case PostgresTypes.float4:\n    case PostgresTypes.float8:\n    case PostgresTypes.int2:\n    case PostgresTypes.int4:\n    case PostgresTypes.int8:\n    case PostgresTypes.numeric:\n    case PostgresTypes.oid:\n      return toNumber(value)\n    case PostgresTypes.json:\n    case PostgresTypes.jsonb:\n      return toJson(value)\n    case PostgresTypes.timestamp:\n      return toTimestampString(value) // Format to be consistent with PostgREST\n    case PostgresTypes.abstime: // To allow users to cast it based on Timezone\n    case PostgresTypes.date: // To allow users to cast it based on Timezone\n    case PostgresTypes.daterange:\n    case PostgresTypes.int4range:\n    case PostgresTypes.int8range:\n    case PostgresTypes.money:\n    case PostgresTypes.reltime: // To allow users to cast it based on Timezone\n    case PostgresTypes.text:\n    case PostgresTypes.time: // To allow users to cast it based on Timezone\n    case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone\n    case PostgresTypes.timetz: // To allow users to cast it based on Timezone\n    case PostgresTypes.tsrange:\n    case PostgresTypes.tstzrange:\n      return noop(value)\n    default:\n      // Return the value for remaining types\n      return noop(value)\n  }\n}\n\nconst noop = (value: RecordValue): RecordValue => {\n  return value\n}\nexport const toBoolean = (value: RecordValue): RecordValue => {\n  switch (value) {\n    case 't':\n      return true\n    case 'f':\n      return false\n    default:\n      return value\n  }\n}\nexport const toNumber = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    const parsedValue = parseFloat(value)\n    if (!Number.isNaN(parsedValue)) {\n      return parsedValue\n    }\n  }\n  return value\n}\nexport const toJson = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    try {\n      return JSON.parse(value)\n    } catch (error) {\n      console.log(`JSON parse error: ${error}`)\n      return value\n    }\n  }\n  return value\n}\n\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */\nexport const toArray = (value: RecordValue, type: string): RecordValue => {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  const lastIdx = value.length - 1\n  const closeBrace = value[lastIdx]\n  const openBrace = value[0]\n\n  // Confirm value is a Postgres array by checking curly brackets\n  if (openBrace === '{' && closeBrace === '}') {\n    let arr\n    const valTrim = value.slice(1, lastIdx)\n\n    // TODO: find a better solution to separate Postgres array data\n    try {\n      arr = JSON.parse('[' + valTrim + ']')\n    } catch (_) {\n      // WARNING: splitting on comma does not cover all edge cases\n      arr = valTrim ? valTrim.split(',') : []\n    }\n\n    return arr.map((val: BaseValue) => convertCell(type, val))\n  }\n\n  return value\n}\n\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nexport const toTimestampString = (value: RecordValue): RecordValue => {\n  if (typeof value === 'string') {\n    return value.replace(' ', 'T')\n  }\n\n  return value\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE, } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeSubscription from './RealtimeSubscription';\nconst noop = () => { };\nexport default class RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket.\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers The optional headers to pass when connecting.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     */\n    constructor(endPoint, options) {\n        this.accessToken = null;\n        this.channels = [];\n        this.endPoint = '';\n        this.headers = DEFAULT_HEADERS;\n        this.params = {};\n        this.timeout = DEFAULT_TIMEOUT;\n        this.transport = w3cwebsocket;\n        this.heartbeatIntervalMs = 30000;\n        this.longpollerTimeout = 20000;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.ref = 0;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new Serializer();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: [],\n        };\n        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n        if (options === null || options === void 0 ? void 0 : options.params)\n            this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.headers)\n            this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n        if (options === null || options === void 0 ? void 0 : options.timeout)\n            this.timeout = options.timeout;\n        if (options === null || options === void 0 ? void 0 : options.logger)\n            this.logger = options.logger;\n        if (options === null || options === void 0 ? void 0 : options.transport)\n            this.transport = options.transport;\n        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)\n            this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n        if (options === null || options === void 0 ? void 0 : options.longpollerTimeout)\n            this.longpollerTimeout = options.longpollerTimeout;\n        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs\n            : (tries) => {\n                return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n            };\n        this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode\n            : (payload, callback) => {\n                return callback(JSON.stringify(payload));\n            };\n        this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode\n            : this.serializer.decode.bind(this.serializer);\n        this.reconnectTimer = new Timer(() => __awaiter(this, void 0, void 0, function* () {\n            yield this.disconnect();\n            this.connect();\n        }), this.reconnectAfterMs);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */\n    connect() {\n        if (this.conn) {\n            return;\n        }\n        this.conn = new this.transport(this.endPointURL(), [], null, this.headers);\n        if (this.conn) {\n            // this.conn.timeout = this.longpollerTimeout // TYPE ERROR\n            this.conn.binaryType = 'arraybuffer';\n            this.conn.onopen = () => this._onConnOpen();\n            this.conn.onerror = (error) => this._onConnError(error);\n            this.conn.onmessage = (event) => this.onConnMessage(event);\n            this.conn.onclose = (event) => this._onConnClose(event);\n        }\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n    disconnect(code, reason) {\n        return new Promise((resolve, _reject) => {\n            try {\n                if (this.conn) {\n                    this.conn.onclose = function () { }; // noop\n                    if (code) {\n                        this.conn.close(code, reason || '');\n                    }\n                    else {\n                        this.conn.close();\n                    }\n                    this.conn = null;\n                    // remove open handles\n                    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n                    this.reconnectTimer.reset();\n                }\n                resolve({ error: null, data: true });\n            }\n            catch (error) {\n                resolve({ error: error, data: false });\n            }\n        });\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overriden.\n     */\n    log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Registers a callback for connection state change event.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen(() => console.log(\"Socket opened.\"))\n     */\n    onOpen(callback) {\n        this.stateChangeCallbacks.open.push(callback);\n    }\n    /**\n     * Registers a callback for connection state change events.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen(() => console.log(\"Socket closed.\"))\n     */\n    onClose(callback) {\n        this.stateChangeCallbacks.close.push(callback);\n    }\n    /**\n     * Registers a callback for connection state change events.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen((error) => console.log(\"An error occurred\"))\n     */\n    onError(callback) {\n        this.stateChangeCallbacks.error.push(callback);\n    }\n    /**\n     * Calls a function any time a message is received.\n     *\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onMessage((message) => console.log(message))\n     */\n    onMessage(callback) {\n        this.stateChangeCallbacks.message.push(callback);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n    connectionState() {\n        switch (this.conn && this.conn.readyState) {\n            case SOCKET_STATES.connecting:\n                return CONNECTION_STATE.Connecting;\n            case SOCKET_STATES.open:\n                return CONNECTION_STATE.Open;\n            case SOCKET_STATES.closing:\n                return CONNECTION_STATE.Closing;\n            default:\n                return CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Retuns `true` is the connection is open.\n     */\n    isConnected() {\n        return this.connectionState() === CONNECTION_STATE.Open;\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     */\n    remove(channel) {\n        this.channels = this.channels.filter((c) => c.joinRef() !== channel.joinRef());\n    }\n    channel(topic, chanParams = {}) {\n        const chan = new RealtimeSubscription(topic, chanParams, this);\n        this.channels.push(chan);\n        return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n    push(data) {\n        const { topic, event, payload, ref } = data;\n        let callback = () => {\n            this.encode(data, (result) => {\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log('push', `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            callback();\n        }\n        else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg) => {\n            let { topic, event, payload, ref } = msg;\n            if ((ref && ref === this.pendingHeartbeatRef) ||\n                event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n                this.pendingHeartbeatRef = null;\n            }\n            this.log('receive', `${payload.status || ''} ${topic} ${event} ${(ref && '(' + ref + ')') || ''}`, payload);\n            this.channels\n                .filter((channel) => channel.isMember(topic))\n                .forEach((channel) => channel.trigger(event, payload, ref));\n            this.stateChangeCallbacks.message.forEach((callback) => callback(msg));\n        });\n    }\n    /**\n     * Returns the URL of the websocket.\n     */\n    endPointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     */\n    makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        }\n        else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n    setAuth(token) {\n        this.accessToken = token;\n        this.channels.forEach((channel) => {\n            token && channel.updateJoinPayload({ user_token: token });\n            if (channel.joinedOnce && channel.isJoined()) {\n                channel.push(CHANNEL_EVENTS.access_token, { access_token: token });\n            }\n        });\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     */\n    leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));\n        if (dupChannel) {\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    _onConnOpen() {\n        this.log('transport', `connected to ${this.endPointURL()}`);\n        this._flushSendBuffer();\n        this.reconnectTimer.reset();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs);\n        this.stateChangeCallbacks.open.forEach((callback) => callback());\n    }\n    _onConnClose(event) {\n        this.log('transport', 'close', event);\n        this._triggerChanError();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.scheduleTimeout();\n        this.stateChangeCallbacks.close.forEach((callback) => callback(event));\n    }\n    _onConnError(error) {\n        this.log('transport', error.message);\n        this._triggerChanError();\n        this.stateChangeCallbacks.error.forEach((callback) => callback(error));\n    }\n    _triggerChanError() {\n        this.channels.forEach((channel) => channel.trigger(CHANNEL_EVENTS.error));\n    }\n    _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? '&' : '?';\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    _flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback) => callback());\n            this.sendBuffer = [];\n        }\n    }\n    _sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            return;\n        }\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n            return;\n        }\n        this.pendingHeartbeatRef = this.makeRef();\n        this.push({\n            topic: 'phoenix',\n            event: 'heartbeat',\n            payload: {},\n            ref: this.pendingHeartbeatRef,\n        });\n        this.setAuth(this.accessToken);\n    }\n}\n//# sourceMappingURL=RealtimeClient.js.map","import { w3cwebsocket } from 'websocket'\nimport {\n  VSN,\n  CHANNEL_EVENTS,\n  TRANSPORTS,\n  SOCKET_STATES,\n  DEFAULT_TIMEOUT,\n  WS_CLOSE_NORMAL,\n  DEFAULT_HEADERS,\n  CONNECTION_STATE,\n} from './lib/constants'\nimport Timer from './lib/timer'\nimport Serializer from './lib/serializer'\nimport RealtimeSubscription from './RealtimeSubscription'\n\nexport type Options = {\n  transport?: WebSocket\n  timeout?: number\n  heartbeatIntervalMs?: number\n  longpollerTimeout?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: string }\n}\ntype Message = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n  join_ref?: string\n}\n\ntype ChannelParams = {\n  selfBroadcast?: boolean\n  [key: string]: any\n}\n\nconst noop = () => {}\n\nexport default class RealtimeClient {\n  accessToken: string | null = null\n  channels: RealtimeSubscription[] = []\n  endPoint: string = ''\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: any = w3cwebsocket\n  heartbeatIntervalMs: number = 30000\n  longpollerTimeout: number = 20000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocket | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint: string, options?: Options) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n\n    if (options?.params) this.params = options.params\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.transport) this.transport = options.transport\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n    if (options?.longpollerTimeout)\n      this.longpollerTimeout = options.longpollerTimeout\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      await this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    if (this.conn) {\n      return\n    }\n\n    this.conn = new this.transport(this.endPointURL(), [], null, this.headers)\n\n    if (this.conn) {\n      // this.conn.timeout = this.longpollerTimeout // TYPE ERROR\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error) => this._onConnError(error as ErrorEvent)\n      this.conn.onmessage = (event) => this.onConnMessage(event)\n      this.conn.onclose = (event) => this._onConnClose(event)\n    }\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(\n    code?: number,\n    reason?: string\n  ): Promise<{ error: Error | null; data: boolean }> {\n    return new Promise((resolve, _reject) => {\n      try {\n        if (this.conn) {\n          this.conn.onclose = function () {} // noop\n          if (code) {\n            this.conn.close(code, reason || '')\n          } else {\n            this.conn.close()\n          }\n          this.conn = null\n          // remove open handles\n          this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n          this.reconnectTimer.reset()\n        }\n        resolve({ error: null, data: true })\n      } catch (error) {\n        resolve({ error: error as Error, data: false })\n      }\n    })\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overriden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Registers a callback for connection state change event.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen(() => console.log(\"Socket opened.\"))\n   */\n  onOpen(callback: Function) {\n    this.stateChangeCallbacks.open.push(callback)\n  }\n\n  /**\n   * Registers a callback for connection state change events.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen(() => console.log(\"Socket closed.\"))\n   */\n  onClose(callback: Function) {\n    this.stateChangeCallbacks.close.push(callback)\n  }\n\n  /**\n   * Registers a callback for connection state change events.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen((error) => console.log(\"An error occurred\"))\n   */\n  onError(callback: Function) {\n    this.stateChangeCallbacks.error.push(callback)\n  }\n\n  /**\n   * Calls a function any time a message is received.\n   *\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onMessage((message) => console.log(message))\n   */\n  onMessage(callback: Function) {\n    this.stateChangeCallbacks.message.push(callback)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Retuns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   */\n  remove(channel: RealtimeSubscription) {\n    this.channels = this.channels.filter(\n      (c: RealtimeSubscription) => c.joinRef() !== channel.joinRef()\n    )\n  }\n\n  channel(topic: string, chanParams: ChannelParams = {}): RealtimeSubscription {\n    const chan = new RealtimeSubscription(topic, chanParams, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: Message): void {\n    const { topic, event, payload, ref } = data\n    let callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      callback()\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: Message) => {\n      let { topic, event, payload, ref } = msg\n\n      if (\n        (ref && ref === this.pendingHeartbeatRef) ||\n        event === payload?.type\n      ) {\n        this.pendingHeartbeatRef = null\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n      this.channels\n        .filter((channel: RealtimeSubscription) => channel.isMember(topic))\n        .forEach((channel: RealtimeSubscription) =>\n          channel.trigger(event, payload, ref)\n        )\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   */\n  endPointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   */\n  makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token: string | null) {\n    this.accessToken = token\n\n    this.channels.forEach((channel) => {\n      token && channel.updateJoinPayload({ user_token: token })\n\n      if (channel.joinedOnce && channel.isJoined()) {\n        channel.push(CHANNEL_EVENTS.access_token, { access_token: token })\n      }\n    })\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   */\n  leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c.isJoined() || c.isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  private _onConnOpen() {\n    this.log('transport', `connected to ${this.endPointURL()}`)\n    this._flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(\n      () => this._sendHeartbeat(),\n      this.heartbeatIntervalMs\n    )\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\n  }\n\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  private _onConnError(error: ErrorEvent) {\n    this.log('transport', error.message)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeSubscription) =>\n      channel.trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n\n    return `${url}${prefix}${query}`\n  }\n\n  private _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n\n  private _sendHeartbeat() {\n    if (!this.isConnected()) {\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this.makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.setAuth(this.accessToken)\n  }\n}\n","var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = require('es5-ext/global');\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = require('./version');\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n","module.exports = require('../package.json').version;\n","import { version } from './version';\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `realtime-js/${version}` };\nexport const VSN = '1.0.0';\nexport const DEFAULT_TIMEOUT = 10000;\nexport const WS_CLOSE_NORMAL = 1000;\nexport var SOCKET_STATES;\n(function (SOCKET_STATES) {\n    SOCKET_STATES[SOCKET_STATES[\"connecting\"] = 0] = \"connecting\";\n    SOCKET_STATES[SOCKET_STATES[\"open\"] = 1] = \"open\";\n    SOCKET_STATES[SOCKET_STATES[\"closing\"] = 2] = \"closing\";\n    SOCKET_STATES[SOCKET_STATES[\"closed\"] = 3] = \"closed\";\n})(SOCKET_STATES || (SOCKET_STATES = {}));\nexport var CHANNEL_STATES;\n(function (CHANNEL_STATES) {\n    CHANNEL_STATES[\"closed\"] = \"closed\";\n    CHANNEL_STATES[\"errored\"] = \"errored\";\n    CHANNEL_STATES[\"joined\"] = \"joined\";\n    CHANNEL_STATES[\"joining\"] = \"joining\";\n    CHANNEL_STATES[\"leaving\"] = \"leaving\";\n})(CHANNEL_STATES || (CHANNEL_STATES = {}));\nexport var CHANNEL_EVENTS;\n(function (CHANNEL_EVENTS) {\n    CHANNEL_EVENTS[\"close\"] = \"phx_close\";\n    CHANNEL_EVENTS[\"error\"] = \"phx_error\";\n    CHANNEL_EVENTS[\"join\"] = \"phx_join\";\n    CHANNEL_EVENTS[\"reply\"] = \"phx_reply\";\n    CHANNEL_EVENTS[\"leave\"] = \"phx_leave\";\n    CHANNEL_EVENTS[\"access_token\"] = \"access_token\";\n})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));\nexport var TRANSPORTS;\n(function (TRANSPORTS) {\n    TRANSPORTS[\"websocket\"] = \"websocket\";\n})(TRANSPORTS || (TRANSPORTS = {}));\nexport var CONNECTION_STATE;\n(function (CONNECTION_STATE) {\n    CONNECTION_STATE[\"Connecting\"] = \"connecting\";\n    CONNECTION_STATE[\"Open\"] = \"open\";\n    CONNECTION_STATE[\"Closing\"] = \"closing\";\n    CONNECTION_STATE[\"Closed\"] = \"closed\";\n})(CONNECTION_STATE || (CONNECTION_STATE = {}));\n//# sourceMappingURL=constants.js.map","import { version } from './version'\n\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `realtime-js/${version}` }\n\nexport const VSN: string = '1.0.0'\n\nexport const DEFAULT_TIMEOUT = 10000\n\nexport const WS_CLOSE_NORMAL = 1000\n\nexport enum SOCKET_STATES {\n  connecting = 0,\n  open = 1,\n  closing = 2,\n  closed = 3,\n}\n\nexport enum CHANNEL_STATES {\n  closed = 'closed',\n  errored = 'errored',\n  joined = 'joined',\n  joining = 'joining',\n  leaving = 'leaving',\n}\n\nexport enum CHANNEL_EVENTS {\n  close = 'phx_close',\n  error = 'phx_error',\n  join = 'phx_join',\n  reply = 'phx_reply',\n  leave = 'phx_leave',\n  access_token = 'access_token',\n}\n\nexport enum TRANSPORTS {\n  websocket = 'websocket',\n}\n\nexport enum CONNECTION_STATE {\n  Connecting = 'connecting',\n  Open = 'open',\n  Closing = 'closing',\n  Closed = 'closed',\n}\n","export const version = '1.7.5';\n//# sourceMappingURL=version.js.map","export const version = '1.7.5'\n","/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */\nexport default class Timer {\n    constructor(callback, timerCalc) {\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n        this.timer = undefined;\n        this.tries = 0;\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n    }\n    reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n    }\n    // Cancels any previous scheduleTimeout and schedules callback\n    scheduleTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(() => {\n            this.tries = this.tries + 1;\n            this.callback();\n        }, this.timerCalc(this.tries + 1));\n    }\n}\n//# sourceMappingURL=timer.js.map","/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */\nexport default class Timer {\n  timer: number | undefined = undefined\n  tries: number = 0\n\n  constructor(public callback: Function, public timerCalc: Function) {\n    this.callback = callback\n    this.timerCalc = timerCalc\n  }\n\n  reset() {\n    this.tries = 0\n    clearTimeout(this.timer)\n  }\n\n  // Cancels any previous scheduleTimeout and schedules callback\n  scheduleTimeout() {\n    clearTimeout(this.timer)\n\n    this.timer = <any>setTimeout(() => {\n      this.tries = this.tries + 1\n      this.callback()\n    }, this.timerCalc(this.tries + 1))\n  }\n}\n","// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe\n// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md\nexport default class Serializer {\n    constructor() {\n        this.HEADER_LENGTH = 1;\n    }\n    decode(rawPayload, callback) {\n        if (rawPayload.constructor === ArrayBuffer) {\n            return callback(this._binaryDecode(rawPayload));\n        }\n        if (typeof rawPayload === 'string') {\n            return callback(JSON.parse(rawPayload));\n        }\n        return callback({});\n    }\n    _binaryDecode(buffer) {\n        const view = new DataView(buffer);\n        const decoder = new TextDecoder();\n        return this._decodeBroadcast(buffer, view, decoder);\n    }\n    _decodeBroadcast(buffer, view, decoder) {\n        const topicSize = view.getUint8(1);\n        const eventSize = view.getUint8(2);\n        let offset = this.HEADER_LENGTH + 2;\n        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n        offset = offset + topicSize;\n        const event = decoder.decode(buffer.slice(offset, offset + eventSize));\n        offset = offset + eventSize;\n        const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));\n        return { ref: null, topic: topic, event: event, payload: data };\n    }\n}\n//# sourceMappingURL=serializer.js.map","// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe\n// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md\n\nexport default class Serializer {\n  HEADER_LENGTH = 1\n\n  decode(rawPayload: ArrayBuffer | string, callback: Function) {\n    if (rawPayload.constructor === ArrayBuffer) {\n      return callback(this._binaryDecode(rawPayload))\n    }\n\n    if (typeof rawPayload === 'string') {\n      return callback(JSON.parse(rawPayload))\n    }\n\n    return callback({})\n  }\n\n  private _binaryDecode(buffer: ArrayBuffer) {\n    const view = new DataView(buffer)\n    const decoder = new TextDecoder()\n\n    return this._decodeBroadcast(buffer, view, decoder)\n  }\n\n  private _decodeBroadcast(\n    buffer: ArrayBuffer,\n    view: DataView,\n    decoder: TextDecoder\n  ): {\n    ref: null\n    topic: string\n    event: string\n    payload: object\n  } {\n    const topicSize = view.getUint8(1)\n    const eventSize = view.getUint8(2)\n    let offset = this.HEADER_LENGTH + 2\n    const topic = decoder.decode(buffer.slice(offset, offset + topicSize))\n    offset = offset + topicSize\n    const event = decoder.decode(buffer.slice(offset, offset + eventSize))\n    offset = offset + eventSize\n    const data = JSON.parse(\n      decoder.decode(buffer.slice(offset, buffer.byteLength))\n    )\n\n    return { ref: null, topic: topic, event: event, payload: data }\n  }\n}\n","import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\nexport default class RealtimeSubscription {\n    constructor(topic, params = {}, socket) {\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = [];\n        this.state = CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.timeout = this.socket.timeout;\n        this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new Timer(() => this.rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive('ok', () => {\n            this.state = CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent) => pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this.onClose(() => {\n            this.rejoinTimer.reset();\n            this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`);\n            this.state = CHANNEL_STATES.closed;\n            this.socket.remove(this);\n        });\n        this.onError((reason) => {\n            if (this.isLeaving() || this.isClosed()) {\n                return;\n            }\n            this.socket.log('channel', `error ${this.topic}`, reason);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive('timeout', () => {\n            if (!this.isJoining()) {\n                return;\n            }\n            this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n            this.trigger(this.replyEventName(ref), payload);\n        });\n    }\n    rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this.rejoin();\n        }\n    }\n    subscribe(timeout = this.timeout) {\n        if (this.joinedOnce) {\n            throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;\n        }\n        else {\n            this.joinedOnce = true;\n            this.rejoin(timeout);\n            return this.joinPush;\n        }\n    }\n    onClose(callback) {\n        this.on(CHANNEL_EVENTS.close, callback);\n    }\n    onError(callback) {\n        this.on(CHANNEL_EVENTS.error, (reason) => callback(reason));\n    }\n    on(event, callback) {\n        this.bindings.push({ event, callback });\n    }\n    off(event) {\n        this.bindings = this.bindings.filter((bind) => bind.event !== event);\n    }\n    canPush() {\n        return this.socket.isConnected() && this.isJoined();\n    }\n    push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new Push(this, event, payload, timeout);\n        if (this.canPush()) {\n            pushEvent.send();\n        }\n        else {\n            pushEvent.startTimeout();\n            this.pushBuffer.push(pushEvent);\n        }\n        return pushEvent;\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n    unsubscribe(timeout = this.timeout) {\n        this.state = CHANNEL_STATES.leaving;\n        let onClose = () => {\n            this.socket.log('channel', `leave ${this.topic}`);\n            this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef());\n        };\n        // Destroy joinPush to avoid connection timeouts during unscription phase\n        this.joinPush.destroy();\n        let leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n        leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose());\n        leavePush.send();\n        if (!this.canPush()) {\n            leavePush.trigger('ok', {});\n        }\n        return leavePush;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     */\n    onMessage(event, payload, ref) {\n        return payload;\n    }\n    isMember(topic) {\n        return this.topic === topic;\n    }\n    joinRef() {\n        return this.joinPush.ref;\n    }\n    rejoin(timeout = this.timeout) {\n        if (this.isLeaving()) {\n            return;\n        }\n        this.socket.leaveOpenTopic(this.topic);\n        this.state = CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    trigger(event, payload, ref) {\n        let { close, error, leave, join } = CHANNEL_EVENTS;\n        let events = [close, error, leave, join];\n        if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {\n            return;\n        }\n        let handledPayload = this.onMessage(event, payload, ref);\n        if (payload && !handledPayload) {\n            throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n        }\n        this.bindings\n            .filter((bind) => {\n            // Bind all events if the user specifies a wildcard.\n            if (bind.event === '*') {\n                return event === (payload === null || payload === void 0 ? void 0 : payload.type);\n            }\n            else {\n                return bind.event === event;\n            }\n        })\n            .map((bind) => bind.callback(handledPayload, ref));\n    }\n    replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    isClosed() {\n        return this.state === CHANNEL_STATES.closed;\n    }\n    isErrored() {\n        return this.state === CHANNEL_STATES.errored;\n    }\n    isJoined() {\n        return this.state === CHANNEL_STATES.joined;\n    }\n    isJoining() {\n        return this.state === CHANNEL_STATES.joining;\n    }\n    isLeaving() {\n        return this.state === CHANNEL_STATES.leaving;\n    }\n}\n//# sourceMappingURL=RealtimeSubscription.js.map","import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\nimport Push from './lib/push'\nimport RealtimeClient from './RealtimeClient'\nimport Timer from './lib/timer'\n\nexport default class RealtimeSubscription {\n  bindings: any[] = []\n  timeout: number\n  state = CHANNEL_STATES.closed\n  joinedOnce = false\n  joinPush: Push\n  rejoinTimer: Timer\n  pushBuffer: Push[] = []\n\n  constructor(\n    public topic: string,\n    public params: { [key: string]: unknown } = {},\n    public socket: RealtimeClient\n  ) {\n    this.timeout = this.socket.timeout\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout\n    )\n    this.rejoinTimer = new Timer(\n      () => this.rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this.onClose(() => {\n      this.rejoinTimer.reset()\n      this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket.remove(this)\n    })\n    this.onError((reason: string) => {\n      if (this.isLeaving() || this.isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive('timeout', () => {\n      if (!this.isJoining()) {\n        return\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.on(CHANNEL_EVENTS.reply, (payload: any, ref: string) => {\n      this.trigger(this.replyEventName(ref), payload)\n    })\n  }\n\n  rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout()\n    if (this.socket.isConnected()) {\n      this.rejoin()\n    }\n  }\n\n  subscribe(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\n    } else {\n      this.joinedOnce = true\n      this.rejoin(timeout)\n      return this.joinPush\n    }\n  }\n\n  onClose(callback: Function) {\n    this.on(CHANNEL_EVENTS.close, callback)\n  }\n\n  onError(callback: Function) {\n    this.on(CHANNEL_EVENTS.error, (reason: string) => callback(reason))\n  }\n\n  on(event: string, callback: Function) {\n    this.bindings.push({ event, callback })\n  }\n\n  off(event: string) {\n    this.bindings = this.bindings.filter((bind) => bind.event !== event)\n  }\n\n  canPush() {\n    return this.socket.isConnected() && this.isJoined()\n  }\n\n  push(event: CHANNEL_EVENTS, payload: any, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if (this.canPush()) {\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  updateJoinPayload(payload: { [key: string]: unknown }): void {\n    this.joinPush.updatePayload(payload)\n  }\n\n  /**\n   * Leaves the channel\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout) {\n    this.state = CHANNEL_STATES.leaving\n    let onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`)\n      this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef())\n    }\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy()\n\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n    leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose())\n    leavePush.send()\n    if (!this.canPush()) {\n      leavePush.trigger('ok', {})\n    }\n\n    return leavePush\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   */\n  onMessage(event: string, payload: any, ref?: string) {\n    return payload\n  }\n\n  isMember(topic: string) {\n    return this.topic === topic\n  }\n\n  joinRef() {\n    return this.joinPush.ref\n  }\n\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return\n    }\n    this.socket.leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  trigger(event: string, payload?: any, ref?: string) {\n    let { close, error, leave, join } = CHANNEL_EVENTS\n    let events: string[] = [close, error, leave, join]\n    if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {\n      return\n    }\n    let handledPayload = this.onMessage(event, payload, ref)\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\n    }\n\n    this.bindings\n      .filter((bind) => {\n        // Bind all events if the user specifies a wildcard.\n        if (bind.event === '*') {\n          return event === payload?.type\n        } else {\n          return bind.event === event\n        }\n      })\n      .map((bind) => bind.callback(handledPayload, ref))\n  }\n\n  replyEventName(ref: string) {\n    return `chan_reply_${ref}`\n  }\n\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed\n  }\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored\n  }\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined\n  }\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining\n  }\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving\n  }\n}\n","import { DEFAULT_TIMEOUT } from '../lib/constants';\nexport default class Push {\n    /**\n     * Initializes the Push\n     *\n     * @param channel The Channel\n     * @param event The event, for example `\"phx_join\"`\n     * @param payload The payload, for example `{user_id: 123}`\n     * @param timeout The push timeout in milliseconds\n     */\n    constructor(channel, event, payload = {}, timeout = DEFAULT_TIMEOUT) {\n        this.channel = channel;\n        this.event = event;\n        this.payload = payload;\n        this.timeout = timeout;\n        this.sent = false;\n        this.timeoutTimer = undefined;\n        this.ref = '';\n        this.receivedResp = null;\n        this.recHooks = [];\n        this.refEvent = null;\n    }\n    resend(timeout) {\n        this.timeout = timeout;\n        this._cancelRefEvent();\n        this.ref = '';\n        this.refEvent = null;\n        this.receivedResp = null;\n        this.sent = false;\n        this.send();\n    }\n    send() {\n        if (this._hasReceived('timeout')) {\n            return;\n        }\n        this.startTimeout();\n        this.sent = true;\n        this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload,\n            ref: this.ref,\n            join_ref: this.channel.joinRef(),\n        });\n    }\n    updatePayload(payload) {\n        this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n    receive(status, callback) {\n        var _a;\n        if (this._hasReceived(status)) {\n            callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n        }\n        this.recHooks.push({ status, callback });\n        return this;\n    }\n    startTimeout() {\n        if (this.timeoutTimer) {\n            return;\n        }\n        this.ref = this.channel.socket.makeRef();\n        this.refEvent = this.channel.replyEventName(this.ref);\n        const callback = (payload) => {\n            this._cancelRefEvent();\n            this._cancelTimeout();\n            this.receivedResp = payload;\n            this._matchReceive(payload);\n        };\n        this.channel.on(this.refEvent, callback);\n        this.timeoutTimer = setTimeout(() => {\n            this.trigger('timeout', {});\n        }, this.timeout);\n    }\n    trigger(status, response) {\n        if (this.refEvent)\n            this.channel.trigger(this.refEvent, { status, response });\n    }\n    destroy() {\n        this._cancelRefEvent();\n        this._cancelTimeout();\n    }\n    _cancelRefEvent() {\n        if (!this.refEvent) {\n            return;\n        }\n        this.channel.off(this.refEvent);\n    }\n    _cancelTimeout() {\n        clearTimeout(this.timeoutTimer);\n        this.timeoutTimer = undefined;\n    }\n    _matchReceive({ status, response, }) {\n        this.recHooks\n            .filter((h) => h.status === status)\n            .forEach((h) => h.callback(response));\n    }\n    _hasReceived(status) {\n        return this.receivedResp && this.receivedResp.status === status;\n    }\n}\n//# sourceMappingURL=push.js.map","import { DEFAULT_TIMEOUT } from '../lib/constants'\nimport RealtimeSubscription from '../RealtimeSubscription'\n\nexport default class Push {\n  sent: boolean = false\n  timeoutTimer: number | undefined = undefined\n  ref: string = ''\n  receivedResp: {\n    status: string\n    response: Function\n  } | null = null\n  recHooks: {\n    status: string\n    callback: Function\n  }[] = []\n  refEvent: string | null = null\n\n  /**\n   * Initializes the Push\n   *\n   * @param channel The Channel\n   * @param event The event, for example `\"phx_join\"`\n   * @param payload The payload, for example `{user_id: 123}`\n   * @param timeout The push timeout in milliseconds\n   */\n  constructor(\n    public channel: RealtimeSubscription,\n    public event: string,\n    public payload: { [key: string]: unknown } = {},\n    public timeout: number = DEFAULT_TIMEOUT\n  ) {}\n\n  resend(timeout: number) {\n    this.timeout = timeout\n    this._cancelRefEvent()\n    this.ref = ''\n    this.refEvent = null\n    this.receivedResp = null\n    this.sent = false\n    this.send()\n  }\n\n  send() {\n    if (this._hasReceived('timeout')) {\n      return\n    }\n    this.startTimeout()\n    this.sent = true\n    this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload,\n      ref: this.ref,\n      join_ref: this.channel.joinRef(),\n    })\n  }\n\n  updatePayload(payload: { [key: string]: unknown }): void {\n    this.payload = { ...this.payload, ...payload }\n  }\n\n  receive(status: string, callback: Function) {\n    if (this._hasReceived(status)) {\n      callback(this.receivedResp?.response)\n    }\n\n    this.recHooks.push({ status, callback })\n    return this\n  }\n\n  startTimeout() {\n    if (this.timeoutTimer) {\n      return\n    }\n    this.ref = this.channel.socket.makeRef()\n    this.refEvent = this.channel.replyEventName(this.ref)\n\n    const callback = (payload: any) => {\n      this._cancelRefEvent()\n      this._cancelTimeout()\n      this.receivedResp = payload\n      this._matchReceive(payload)\n    }\n\n    this.channel.on(this.refEvent, callback)\n\n    this.timeoutTimer = <any>setTimeout(() => {\n      this.trigger('timeout', {})\n    }, this.timeout)\n  }\n\n  trigger(status: string, response: any) {\n    if (this.refEvent) this.channel.trigger(this.refEvent, { status, response })\n  }\n\n  destroy() {\n    this._cancelRefEvent()\n    this._cancelTimeout()\n  }\n\n  private _cancelRefEvent() {\n    if (!this.refEvent) {\n      return\n    }\n\n    this.channel.off(this.refEvent)\n  }\n\n  private _cancelTimeout() {\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = undefined\n  }\n\n  private _matchReceive({\n    status,\n    response,\n  }: {\n    status: string\n    response: Function\n  }) {\n    this.recHooks\n      .filter((h) => h.status === status)\n      .forEach((h) => h.callback(response))\n  }\n\n  private _hasReceived(status: string) {\n    return this.receivedResp && this.receivedResp.status === status\n  }\n}\n","import { StorageBucketApi, StorageFileApi } from './lib';\nexport class StorageClient extends StorageBucketApi {\n    constructor(url, headers = {}, fetch) {\n        super(url, headers, fetch);\n    }\n    /**\n     * Perform file operation in a bucket.\n     *\n     * @param id The bucket id to operate on.\n     */\n    from(id) {\n        return new StorageFileApi(this.url, this.headers, id, this.fetch);\n    }\n}\n//# sourceMappingURL=StorageClient.js.map","import { StorageBucketApi, StorageFileApi } from './lib'\nimport { Fetch } from './lib/fetch'\n\nexport class StorageClient extends StorageBucketApi {\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\n    super(url, headers, fetch)\n  }\n\n  /**\n   * Perform file operation in a bucket.\n   *\n   * @param id The bucket id to operate on.\n   */\n  from(id: string): StorageFileApi {\n    return new StorageFileApi(this.url, this.headers, id, this.fetch)\n  }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { DEFAULT_HEADERS } from './constants';\nimport { get, post, put, remove } from './fetch';\nimport { resolveFetch } from './helpers';\nexport class StorageBucketApi {\n    constructor(url, headers = {}, fetch) {\n        this.url = url;\n        this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch);\n    }\n    /**\n     * Retrieves the details of all Storage buckets within an existing project.\n     */\n    listBuckets() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/bucket`, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Retrieves the details of an existing Storage bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to retrieve.\n     */\n    getBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Creates a new Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are creating.\n     * @returns newly created bucket id\n     */\n    createBucket(id, options = { public: false }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/bucket`, { id, name: id, public: options.public }, { headers: this.headers });\n                return { data: data.name, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Updates a new Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are updating.\n     */\n    updateBucket(id, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield put(this.fetch, `${this.url}/bucket/${id}`, { id, name: id, public: options.public }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Removes all objects inside a single bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to empty.\n     */\n    emptyBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/bucket/${id}/empty`, {}, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n     * You must first `empty()` the bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to delete.\n     */\n    deleteBucket(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield remove(this.fetch, `${this.url}/bucket/${id}`, {}, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n}\n//# sourceMappingURL=StorageBucketApi.js.map","import { DEFAULT_HEADERS } from './constants'\nimport { Fetch, get, post, put, remove } from './fetch'\nimport { resolveFetch } from './helpers'\nimport { Bucket } from './types'\n\nexport class StorageBucketApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected fetch: Fetch\n\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\n    this.url = url\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Retrieves the details of all Storage buckets within an existing project.\n   */\n  async listBuckets(): Promise<{ data: Bucket[] | null; error: Error | null }> {\n    try {\n      const data = await get(this.fetch, `${this.url}/bucket`, { headers: this.headers })\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n\n  /**\n   * Retrieves the details of an existing Storage bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to retrieve.\n   */\n  async getBucket(id: string): Promise<{ data: Bucket | null; error: Error | null }> {\n    try {\n      const data = await get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers })\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n\n  /**\n   * Creates a new Storage bucket\n   *\n   * @param id A unique identifier for the bucket you are creating.\n   * @returns newly created bucket id\n   */\n  async createBucket(\n    id: string,\n    options: { public: boolean } = { public: false }\n  ): Promise<{ data: string | null; error: Error | null }> {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/bucket`,\n        { id, name: id, public: options.public },\n        { headers: this.headers }\n      )\n      return { data: data.name, error: null }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n\n  /**\n   * Updates a new Storage bucket\n   *\n   * @param id A unique identifier for the bucket you are updating.\n   */\n  async updateBucket(\n    id: string,\n    options: { public: boolean }\n  ): Promise<{ data: { message: string } | null; error: Error | null }> {\n    try {\n      const data = await put(\n        this.fetch,\n        `${this.url}/bucket/${id}`,\n        { id, name: id, public: options.public },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n\n  /**\n   * Removes all objects inside a single bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to empty.\n   */\n  async emptyBucket(\n    id: string\n  ): Promise<{ data: { message: string } | null; error: Error | null }> {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/bucket/${id}/empty`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n\n  /**\n   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n   * You must first `empty()` the bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to delete.\n   */\n  async deleteBucket(\n    id: string\n  ): Promise<{ data: { message: string } | null; error: Error | null }> {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/bucket/${id}`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n}\n","import { version } from './version';\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `storage-js/${version}` };\n//# sourceMappingURL=constants.js.map","import { version } from './version'\nexport const DEFAULT_HEADERS = { 'X-Client-Info': `storage-js/${version}` }\n","// generated by genversion\nexport const version = '1.7.3';\n//# sourceMappingURL=version.js.map","// generated by genversion\nexport const version = '1.7.3'\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst _getErrorMessage = (err) => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst handleError = (error, reject) => {\n    if (typeof error.json !== 'function') {\n        return reject(error);\n    }\n    error.json().then((err) => {\n        return reject({\n            message: _getErrorMessage(err),\n            status: (error === null || error === void 0 ? void 0 : error.status) || 500,\n        });\n    });\n};\nconst _getRequestParams = (method, options, parameters, body) => {\n    const params = { method, headers: (options === null || options === void 0 ? void 0 : options.headers) || {} };\n    if (method === 'GET') {\n        return params;\n    }\n    params.headers = Object.assign({ 'Content-Type': 'application/json' }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return Object.assign(Object.assign({}, params), parameters);\n};\nfunction _handleRequest(fetcher, method, url, options, parameters, body) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            fetcher(url, _getRequestParams(method, options, parameters, body))\n                .then((result) => {\n                if (!result.ok)\n                    throw result;\n                if (options === null || options === void 0 ? void 0 : options.noResolveJson)\n                    return resolve(result);\n                return result.json();\n            })\n                .then((data) => resolve(data))\n                .catch((error) => handleError(error, reject));\n        });\n    });\n}\nexport function get(fetcher, url, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'GET', url, options, parameters);\n    });\n}\nexport function post(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'POST', url, options, parameters, body);\n    });\n}\nexport function put(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'PUT', url, options, parameters, body);\n    });\n}\nexport function remove(fetcher, url, body, options, parameters) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return _handleRequest(fetcher, 'DELETE', url, options, parameters, body);\n    });\n}\n//# sourceMappingURL=fetch.js.map","export type Fetch = typeof fetch\n\nexport interface FetchOptions {\n  headers?: {\n    [key: string]: string\n  }\n  noResolveJson?: boolean\n}\n\nexport interface FetchParameters {\n  signal?: AbortSignal\n}\n\nexport type RequestMethodType = 'GET' | 'POST' | 'PUT' | 'DELETE'\n\nconst _getErrorMessage = (err: any): string =>\n  err.msg || err.message || err.error_description || err.error || JSON.stringify(err)\n\nconst handleError = (error: any, reject: any) => {\n  if (typeof error.json !== 'function') {\n    return reject(error)\n  }\n  error.json().then((err: any) => {\n    return reject({\n      message: _getErrorMessage(err),\n      status: error?.status || 500,\n    })\n  })\n}\n\nconst _getRequestParams = (\n  method: RequestMethodType,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n) => {\n  const params: { [k: string]: any } = { method, headers: options?.headers || {} }\n\n  if (method === 'GET') {\n    return params\n  }\n\n  params.headers = { 'Content-Type': 'application/json', ...options?.headers }\n  params.body = JSON.stringify(body)\n  return { ...params, ...parameters }\n}\n\nasync function _handleRequest(\n  fetcher: Fetch,\n  method: RequestMethodType,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters,\n  body?: object\n): Promise<any> {\n  return new Promise((resolve, reject) => {\n    fetcher(url, _getRequestParams(method, options, parameters, body))\n      .then((result) => {\n        if (!result.ok) throw result\n        if (options?.noResolveJson) return resolve(result)\n        return result.json()\n      })\n      .then((data) => resolve(data))\n      .catch((error) => handleError(error, reject))\n  })\n}\n\nexport async function get(\n  fetcher: Fetch,\n  url: string,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'GET', url, options, parameters)\n}\n\nexport async function post(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'POST', url, options, parameters, body)\n}\n\nexport async function put(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'PUT', url, options, parameters, body)\n}\n\nexport async function remove(\n  fetcher: Fetch,\n  url: string,\n  body: object,\n  options?: FetchOptions,\n  parameters?: FetchParameters\n): Promise<any> {\n  return _handleRequest(fetcher, 'DELETE', url, options, parameters, body)\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport const resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = (...args) => __awaiter(void 0, void 0, void 0, function* () { return yield (yield import('cross-fetch')).fetch(...args); });\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\n//# sourceMappingURL=helpers.js.map","type Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { get, post, remove } from './fetch';\nimport { resolveFetch } from './helpers';\nconst DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: 'name',\n        order: 'asc',\n    },\n};\nconst DEFAULT_FILE_OPTIONS = {\n    cacheControl: '3600',\n    contentType: 'text/plain;charset=UTF-8',\n    upsert: false,\n};\nexport class StorageFileApi {\n    constructor(url, headers = {}, bucketId, fetch) {\n        this.url = url;\n        this.headers = headers;\n        this.bucketId = bucketId;\n        this.fetch = resolveFetch(fetch);\n    }\n    /**\n     * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n     *\n     * @param method HTTP method.\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     * @param fileOptions HTTP headers.\n     * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n     * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n     * `upsert`: boolean, whether to perform an upsert.\n     */\n    uploadOrUpdate(method, path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                let body;\n                const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);\n                const headers = Object.assign(Object.assign({}, this.headers), (method === 'POST' && { 'x-upsert': String(options.upsert) }));\n                if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n                    body = new FormData();\n                    body.append('cacheControl', options.cacheControl);\n                    body.append('', fileBody);\n                }\n                else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n                    body = fileBody;\n                    body.append('cacheControl', options.cacheControl);\n                }\n                else {\n                    body = fileBody;\n                    headers['cache-control'] = `max-age=${options.cacheControl}`;\n                    headers['content-type'] = options.contentType;\n                }\n                const cleanPath = this._removeEmptyFolders(path);\n                const _path = this._getFinalPath(cleanPath);\n                const res = yield this.fetch(`${this.url}/object/${_path}`, {\n                    method,\n                    body: body,\n                    headers,\n                });\n                if (res.ok) {\n                    // const data = await res.json()\n                    // temporary fix till backend is updated to the latest storage-api version\n                    return { data: { Key: _path }, error: null };\n                }\n                else {\n                    const error = yield res.json();\n                    return { data: null, error };\n                }\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Uploads a file to an existing bucket.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     * @param fileOptions HTTP headers.\n     * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n     * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n     * `upsert`: boolean, whether to perform an upsert.\n     */\n    upload(path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.uploadOrUpdate('POST', path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Replaces an existing file at the specified path with a new one.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     * @param fileOptions HTTP headers.\n     * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n     * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n     * `upsert`: boolean, whether to perform an upsert.\n     */\n    update(path, fileBody, fileOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.uploadOrUpdate('PUT', path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Moves an existing file.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n     */\n    move(fromPath, toPath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/object/move`, { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Copies an existing file.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n     */\n    copy(fromPath, toPath) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/object/copy`, { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Create signed URL to download file without requiring permissions. This URL can be valid for a set number of seconds.\n     *\n     * @param path The file path to be downloaded, including the current file name. For example `folder/image.png`.\n     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n     */\n    createSignedUrl(path, expiresIn) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const _path = this._getFinalPath(path);\n                let data = yield post(this.fetch, `${this.url}/object/sign/${_path}`, { expiresIn }, { headers: this.headers });\n                const signedURL = `${this.url}${data.signedURL}`;\n                data = { signedURL };\n                return { data, error: null, signedURL };\n            }\n            catch (error) {\n                return { data: null, error, signedURL: null };\n            }\n        });\n    }\n    /**\n     * Create signed URLs to download files without requiring permissions. These URLs can be valid for a set number of seconds.\n     *\n     * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n     * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n     */\n    createSignedUrls(paths, expiresIn) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield post(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn, paths }, { headers: this.headers });\n                return {\n                    data: data.map((datum) => (Object.assign(Object.assign({}, datum), { signedURL: datum.signedURL ? `${this.url}${datum.signedURL}` : null }))),\n                    error: null,\n                };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Downloads a file.\n     *\n     * @param path The file path to be downloaded, including the path and file name. For example `folder/image.png`.\n     */\n    download(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const _path = this._getFinalPath(path);\n                const res = yield get(this.fetch, `${this.url}/object/${_path}`, {\n                    headers: this.headers,\n                    noResolveJson: true,\n                });\n                const data = yield res.blob();\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Retrieve URLs for assets in public buckets\n     *\n     * @param path The file path to be downloaded, including the path and file name. For example `folder/image.png`.\n     */\n    getPublicUrl(path) {\n        try {\n            const _path = this._getFinalPath(path);\n            const publicURL = `${this.url}/object/public/${_path}`;\n            const data = { publicURL };\n            return { data, error: null, publicURL };\n        }\n        catch (error) {\n            return { data: null, error, publicURL: null };\n        }\n    }\n    /**\n     * Deletes files within the same bucket\n     *\n     * @param paths An array of files to be deleted, including the path and file name. For example [`folder/image.png`].\n     */\n    remove(paths) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const data = yield remove(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: paths }, { headers: this.headers });\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    /**\n     * Get file metadata\n     * @param id the file id to retrieve metadata\n     */\n    // async getMetadata(id: string): Promise<{ data: Metadata | null; error: Error | null }> {\n    //   try {\n    //     const data = await get(`${this.url}/metadata/${id}`, { headers: this.headers })\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     return { data: null, error }\n    //   }\n    // }\n    /**\n     * Update file metadata\n     * @param id the file id to update metadata\n     * @param meta the new file metadata\n     */\n    // async updateMetadata(\n    //   id: string,\n    //   meta: Metadata\n    // ): Promise<{ data: Metadata | null; error: Error | null }> {\n    //   try {\n    //     const data = await post(`${this.url}/metadata/${id}`, { ...meta }, { headers: this.headers })\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     return { data: null, error }\n    //   }\n    // }\n    /**\n     * Lists all the files within a bucket.\n     * @param path The folder path.\n     * @param options Search options, including `limit`, `offset`, `sortBy`, and `search`.\n     * @param parameters Fetch parameters, currently only supports `signal`, which is an AbortController's signal\n     */\n    list(path, options, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), { prefix: path || '' });\n                const data = yield post(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, { headers: this.headers }, parameters);\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n    _getFinalPath(path) {\n        return `${this.bucketId}/${path}`;\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/');\n    }\n}\n//# sourceMappingURL=StorageFileApi.js.map","import { Fetch, FetchParameters, get, post, remove } from './fetch'\nimport { resolveFetch } from './helpers'\nimport { FileObject, FileOptions, SearchOptions } from './types'\n\nconst DEFAULT_SEARCH_OPTIONS = {\n  limit: 100,\n  offset: 0,\n  sortBy: {\n    column: 'name',\n    order: 'asc',\n  },\n}\n\nconst DEFAULT_FILE_OPTIONS: FileOptions = {\n  cacheControl: '3600',\n  contentType: 'text/plain;charset=UTF-8',\n  upsert: false,\n}\n\nexport class StorageFileApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected bucketId?: string\n  protected fetch: Fetch\n\n  constructor(\n    url: string,\n    headers: { [key: string]: string } = {},\n    bucketId?: string,\n    fetch?: Fetch\n  ) {\n    this.url = url\n    this.headers = headers\n    this.bucketId = bucketId\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n   *\n   * @param method HTTP method.\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   * @param fileOptions HTTP headers.\n   * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n   * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n   * `upsert`: boolean, whether to perform an upsert.\n   */\n  private async uploadOrUpdate(\n    method: 'POST' | 'PUT',\n    path: string,\n    fileBody:\n      | ArrayBuffer\n      | ArrayBufferView\n      | Blob\n      | Buffer\n      | File\n      | FormData\n      | NodeJS.ReadableStream\n      | ReadableStream<Uint8Array>\n      | URLSearchParams\n      | string,\n    fileOptions?: FileOptions\n  ): Promise<{ data: { Key: string } | null; error: Error | null }> {\n    try {\n      let body\n      const options = { ...DEFAULT_FILE_OPTIONS, ...fileOptions }\n      const headers: Record<string, string> = {\n        ...this.headers,\n        ...(method === 'POST' && { 'x-upsert': String(options.upsert as boolean) }),\n      }\n\n      if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n        body = new FormData()\n        body.append('cacheControl', options.cacheControl as string)\n        body.append('', fileBody)\n      } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n        body = fileBody\n        body.append('cacheControl', options.cacheControl as string)\n      } else {\n        body = fileBody\n        headers['cache-control'] = `max-age=${options.cacheControl}`\n        headers['content-type'] = options.contentType as string\n      }\n\n      const cleanPath = this._removeEmptyFolders(path)\n      const _path = this._getFinalPath(cleanPath)\n      const res = await this.fetch(`${this.url}/object/${_path}`, {\n        method,\n        body: body as BodyInit,\n        headers,\n      })\n\n      if (res.ok) {\n        // const data = await res.json()\n        // temporary fix till backend is updated to the latest storage-api version\n        return { data: { Key: _path }, error: null }\n      } else {\n        const error = await res.json()\n        return { data: null, error }\n      }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n\n  /**\n   * Uploads a file to an existing bucket.\n   *\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   * @param fileOptions HTTP headers.\n   * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n   * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n   * `upsert`: boolean, whether to perform an upsert.\n   */\n  async upload(\n    path: string,\n    fileBody:\n      | ArrayBuffer\n      | ArrayBufferView\n      | Blob\n      | Buffer\n      | File\n      | FormData\n      | NodeJS.ReadableStream\n      | ReadableStream<Uint8Array>\n      | URLSearchParams\n      | string,\n    fileOptions?: FileOptions\n  ): Promise<{ data: { Key: string } | null; error: Error | null }> {\n    return this.uploadOrUpdate('POST', path, fileBody, fileOptions)\n  }\n\n  /**\n   * Replaces an existing file at the specified path with a new one.\n   *\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   * @param fileOptions HTTP headers.\n   * `cacheControl`: string, the `Cache-Control: max-age=<seconds>` seconds value.\n   * `contentType`: string, the `Content-Type` header value. Should be specified if using a `fileBody` that is neither `Blob` nor `File` nor `FormData`, otherwise will default to `text/plain;charset=UTF-8`.\n   * `upsert`: boolean, whether to perform an upsert.\n   */\n  async update(\n    path: string,\n    fileBody:\n      | ArrayBuffer\n      | ArrayBufferView\n      | Blob\n      | Buffer\n      | File\n      | FormData\n      | NodeJS.ReadableStream\n      | ReadableStream<Uint8Array>\n      | URLSearchParams\n      | string,\n    fileOptions?: FileOptions\n  ): Promise<{ data: { Key: string } | null; error: Error | null }> {\n    return this.uploadOrUpdate('PUT', path, fileBody, fileOptions)\n  }\n\n  /**\n   * Moves an existing file.\n   *\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n   */\n  async move(\n    fromPath: string,\n    toPath: string\n  ): Promise<{ data: { message: string } | null; error: Error | null }> {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/move`,\n        { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n\n  /**\n   * Copies an existing file.\n   *\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n   */\n  async copy(\n    fromPath: string,\n    toPath: string\n  ): Promise<{ data: { message: string } | null; error: Error | null }> {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/copy`,\n        { bucketId: this.bucketId, sourceKey: fromPath, destinationKey: toPath },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n\n  /**\n   * Create signed URL to download file without requiring permissions. This URL can be valid for a set number of seconds.\n   *\n   * @param path The file path to be downloaded, including the current file name. For example `folder/image.png`.\n   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n   */\n  async createSignedUrl(\n    path: string,\n    expiresIn: number\n  ): Promise<{\n    data: { signedURL: string } | null\n    error: Error | null\n    signedURL: string | null\n  }> {\n    try {\n      const _path = this._getFinalPath(path)\n      let data = await post(\n        this.fetch,\n        `${this.url}/object/sign/${_path}`,\n        { expiresIn },\n        { headers: this.headers }\n      )\n      const signedURL = `${this.url}${data.signedURL}`\n      data = { signedURL }\n      return { data, error: null, signedURL }\n    } catch (error) {\n      return { data: null, error, signedURL: null }\n    }\n  }\n\n  /**\n   * Create signed URLs to download files without requiring permissions. These URLs can be valid for a set number of seconds.\n   *\n   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n   */\n  async createSignedUrls(\n    paths: string[],\n    expiresIn: number\n  ): Promise<{\n    data: { error: string | null; path: string | null; signedURL: string }[] | null\n    error: Error | null\n  }> {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/sign/${this.bucketId}`,\n        { expiresIn, paths },\n        { headers: this.headers }\n      )\n      return {\n        data: data.map((datum: { signedURL: string }) => ({\n          ...datum,\n          signedURL: datum.signedURL ? `${this.url}${datum.signedURL}` : null,\n        })),\n        error: null,\n      }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n\n  /**\n   * Downloads a file.\n   *\n   * @param path The file path to be downloaded, including the path and file name. For example `folder/image.png`.\n   */\n  async download(path: string): Promise<{ data: Blob | null; error: Error | null }> {\n    try {\n      const _path = this._getFinalPath(path)\n      const res = await get(this.fetch, `${this.url}/object/${_path}`, {\n        headers: this.headers,\n        noResolveJson: true,\n      })\n      const data = await res.blob()\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n\n  /**\n   * Retrieve URLs for assets in public buckets\n   *\n   * @param path The file path to be downloaded, including the path and file name. For example `folder/image.png`.\n   */\n  getPublicUrl(\n    path: string\n  ): {\n    data: { publicURL: string } | null\n    error: Error | null\n    publicURL: string | null\n  } {\n    try {\n      const _path = this._getFinalPath(path)\n      const publicURL = `${this.url}/object/public/${_path}`\n      const data = { publicURL }\n      return { data, error: null, publicURL }\n    } catch (error) {\n      return { data: null, error, publicURL: null }\n    }\n  }\n\n  /**\n   * Deletes files within the same bucket\n   *\n   * @param paths An array of files to be deleted, including the path and file name. For example [`folder/image.png`].\n   */\n  async remove(paths: string[]): Promise<{ data: FileObject[] | null; error: Error | null }> {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/object/${this.bucketId}`,\n        { prefixes: paths },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n\n  /**\n   * Get file metadata\n   * @param id the file id to retrieve metadata\n   */\n  // async getMetadata(id: string): Promise<{ data: Metadata | null; error: Error | null }> {\n  //   try {\n  //     const data = await get(`${this.url}/metadata/${id}`, { headers: this.headers })\n  //     return { data, error: null }\n  //   } catch (error) {\n  //     return { data: null, error }\n  //   }\n  // }\n\n  /**\n   * Update file metadata\n   * @param id the file id to update metadata\n   * @param meta the new file metadata\n   */\n  // async updateMetadata(\n  //   id: string,\n  //   meta: Metadata\n  // ): Promise<{ data: Metadata | null; error: Error | null }> {\n  //   try {\n  //     const data = await post(`${this.url}/metadata/${id}`, { ...meta }, { headers: this.headers })\n  //     return { data, error: null }\n  //   } catch (error) {\n  //     return { data: null, error }\n  //   }\n  // }\n\n  /**\n   * Lists all the files within a bucket.\n   * @param path The folder path.\n   * @param options Search options, including `limit`, `offset`, `sortBy`, and `search`.\n   * @param parameters Fetch parameters, currently only supports `signal`, which is an AbortController's signal\n   */\n  async list(\n    path?: string,\n    options?: SearchOptions,\n    parameters?: FetchParameters\n  ): Promise<{ data: FileObject[] | null; error: Error | null }> {\n    try {\n      const body = { ...DEFAULT_SEARCH_OPTIONS, ...options, prefix: path || '' }\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/list/${this.bucketId}`,\n        body,\n        { headers: this.headers },\n        parameters\n      )\n      return { data, error: null }\n    } catch (error) {\n      return { data: null, error }\n    }\n  }\n\n  _getFinalPath(path: string) {\n    return `${this.bucketId}/${path}`\n  }\n\n  _removeEmptyFolders(path: string) {\n    return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/')\n  }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { resolveFetch } from './helper';\nexport class FunctionsClient {\n    constructor(url, { headers = {}, customFetch, } = {}) {\n        this.url = url;\n        this.headers = headers;\n        this.fetch = resolveFetch(customFetch);\n    }\n    /**\n     * Updates the authorization header\n     * @params token - the new jwt token sent in the authorisation header\n     */\n    setAuth(token) {\n        this.headers.Authorization = `Bearer ${token}`;\n    }\n    /**\n     * Invokes a function\n     * @param functionName - the name of the function to invoke\n     * @param invokeOptions - object with the following properties\n     * `headers`: object representing the headers to send with the request\n     * `body`: the body of the request\n     * `responseType`: how the response should be parsed. The default is `json`\n     */\n    invoke(functionName, invokeOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { headers, body } = invokeOptions !== null && invokeOptions !== void 0 ? invokeOptions : {};\n                const response = yield this.fetch(`${this.url}/${functionName}`, {\n                    method: 'POST',\n                    headers: Object.assign({}, this.headers, headers),\n                    body,\n                });\n                const isRelayError = response.headers.get('x-relay-error');\n                if (isRelayError && isRelayError === 'true') {\n                    return { data: null, error: new Error(yield response.text()) };\n                }\n                let data;\n                const { responseType } = invokeOptions !== null && invokeOptions !== void 0 ? invokeOptions : {};\n                if (!responseType || responseType === 'json') {\n                    data = yield response.json();\n                }\n                else if (responseType === 'arrayBuffer') {\n                    data = yield response.arrayBuffer();\n                }\n                else if (responseType === 'blob') {\n                    data = yield response.blob();\n                }\n                else {\n                    data = yield response.text();\n                }\n                return { data, error: null };\n            }\n            catch (error) {\n                return { data: null, error };\n            }\n        });\n    }\n}\n//# sourceMappingURL=index.js.map","import { resolveFetch } from './helper'\nimport { Fetch, FunctionInvokeOptions } from './types'\n\nexport class FunctionsClient {\n  protected url: string\n  protected headers: Record<string, string>\n  protected fetch: Fetch\n\n  constructor(\n    url: string,\n    {\n      headers = {},\n      customFetch,\n    }: {\n      headers?: Record<string, string>\n      customFetch?: Fetch\n    } = {}\n  ) {\n    this.url = url\n    this.headers = headers\n    this.fetch = resolveFetch(customFetch)\n  }\n\n  /**\n   * Updates the authorization header\n   * @params token - the new jwt token sent in the authorisation header\n   */\n  setAuth(token: string) {\n    this.headers.Authorization = `Bearer ${token}`\n  }\n\n  /**\n   * Invokes a function\n   * @param functionName - the name of the function to invoke\n   * @param invokeOptions - object with the following properties\n   * `headers`: object representing the headers to send with the request\n   * `body`: the body of the request\n   * `responseType`: how the response should be parsed. The default is `json`\n   */\n  async invoke<T = any>(\n    functionName: string,\n    invokeOptions?: FunctionInvokeOptions\n  ): Promise<{ data: T; error: null } | { data: null; error: Error }> {\n    try {\n      const { headers, body } = invokeOptions ?? {}\n      const response = await this.fetch(`${this.url}/${functionName}`, {\n        method: 'POST',\n        headers: Object.assign({}, this.headers, headers),\n        body,\n      })\n\n      const isRelayError = response.headers.get('x-relay-error')\n      if (isRelayError && isRelayError === 'true') {\n        return { data: null, error: new Error(await response.text()) }\n      }\n\n      let data\n      const { responseType } = invokeOptions ?? {}\n      if (!responseType || responseType === 'json') {\n        data = await response.json()\n      } else if (responseType === 'arrayBuffer') {\n        data = await response.arrayBuffer()\n      } else if (responseType === 'blob') {\n        data = await response.blob()\n      } else {\n        data = await response.text()\n      }\n\n      return { data, error: null }\n    } catch (error: any) {\n      return { data: null, error }\n    }\n  }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport const resolveFetch = (customFetch) => {\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    }\n    else if (typeof fetch === 'undefined') {\n        _fetch = (...args) => __awaiter(void 0, void 0, void 0, function* () { return yield (yield import('cross-fetch')).fetch(...args); });\n    }\n    else {\n        _fetch = fetch;\n    }\n    return (...args) => _fetch(...args);\n};\n//# sourceMappingURL=helper.js.map","type Fetch = typeof fetch\n\nexport const resolveFetch = (customFetch?: Fetch): Fetch => {\n  let _fetch: Fetch\n  if (customFetch) {\n    _fetch = customFetch\n  } else if (typeof fetch === 'undefined') {\n    _fetch = async (...args) => await (await import('cross-fetch')).fetch(...args)\n  } else {\n    _fetch = fetch\n  }\n  return (...args) => _fetch(...args)\n}\n","export async function getPreview(url) {\r\n    const API_KEY = \"479caf1751a010ec074397313794465c\";  // LinkPreview API \r\n    const apiUrl = `https://api.linkpreview.net/?key=${API_KEY}&q=${encodeURIComponent(url)}`;\r\n\r\n    try {\r\n        const res = await fetch(apiUrl);\r\n        if (!res.ok) throw new Error(`HTTP: ${res.status}`);\r\n        const data = await res.json();\r\n        \r\n        return data.image || \"https://placehold.co/300x200\";  //  \r\n    } catch (error) {\r\n        console.error(\"URL:\", error);\r\n        return \"https://placehold.co/300x200\";  //  \r\n    }\r\n}"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","PostgresTypes","SOCKET_STATES","CHANNEL_STATES","CHANNEL_EVENTS","CONNECTION_STATE","$eeb0961446aae8e3$export$6100ba28696e12de","$7221566bd4d49f44$export$aafa59e2e03f2942","$7221566bd4d49f44$export$68d8715fc104d294","$3f01feefa94fd48b$export$4d213a7d364021dc","$b5dc48dc7c306f35$var$_globalThis","$3d531e63e1ea7f53$export$a6d0320a1563d49e","$3d531e63e1ea7f53$export$b83816118db74fe7","$3d531e63e1ea7f53$export$8db7548e65d6ea55","$3d531e63e1ea7f53$export$b2688bfb999f5751","$3d531e63e1ea7f53$export$deda39003d27273","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","then","$13590742ec5ba364$var$naiveFallback","self","window","prototype","error","__global__","JSON","parse","$c0fdce55fc03ad18$export$88a84136db6a4b64","$0c30a5a89f4b6341$export$4e09c449d6c407f7","$bc9c0ede130f94c1$export$5615c708618ee858","ERROR_MESSAGE","MAX_RETRIES","RETRY_INTERVAL","$bc9c0ede130f94c1$export$86880b4b2e1a2384","$bc9c0ede130f94c1$export$5d04dceb9d38c3f8","name","lifetime","domain","path","sameSite","$4bf44b5e4af6a5a5$var$__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","rejected","result","done","adopt","apply","$4bf44b5e4af6a5a5$var$_getErrorMessage","msg","message","error_description","stringify","$4bf44b5e4af6a5a5$var$handleError","status","json","$4bf44b5e4af6a5a5$var$_getRequestParams","method","options","body","params","headers","assign","$4bf44b5e4af6a5a5$var$_handleRequest","fetcher","url","ok","noResolveJson","data","catch","$4bf44b5e4af6a5a5$export$3988ae62b71be9a3","$4bf44b5e4af6a5a5$export$299ba2dee77727e9","$4bf44b5e4af6a5a5$export$327f7b26ebf455db","$f258538a2399bef1$export$cabcf1eb6b547ccb","req","res","cookies","strCookies","map","c","secure","_a","_b","_c","$f258538a2399bef1$var$isSecureEnvironment","host","indexOf","split","endsWith","$f258538a2399bef1$var$serialize","val","opt","enc","encodeURIComponent","fieldContentRegExp","TypeError","test","str","maxAge","isNaN","isFinite","Math","floor","expires","toUTCString","httpOnly","toLowerCase","cookie","Date","now","previousCookies","getHeader","Array","push","$f258538a2399bef1$export$31cdeeae171a741d","setHeader","$cca04edb6116d720$var$__awaiter","$cca04edb6116d720$export$e02d0a488392f690","expiresIn","timeNow","round","$cca04edb6116d720$export$4e09c449d6c407f7","$cca04edb6116d720$export$7a5418d73bdac342","location","href","results","regex","RegExp","replace","exec","decodeURIComponent","$cca04edb6116d720$export$98d92b1aa79f8cc7","customFetch","_fetch","fetch","args","$cca04edb6116d720$export$e82c36d29078a87f","storage","key","setItem","$cca04edb6116d720$export$ba6fcb7c333d32c0","getItem","$cca04edb6116d720$export$97dd154d855aafe0","$cca04edb6116d720$export$d35c645d585317ec","removeItem","$cfa76d5c64f3686e$var$__awaiter","$cfa76d5c64f3686e$export$2e2bcd8739ae039","cookieOptions","_createRequestHeaders","jwt","cookieName","getUrlForProvider","provider","urlParams","redirectTo","scopes","queryParams","query","URLSearchParams","join","signUpWithEmail","email","password","queryString","gotrue_meta_security","captcha_token","captchaToken","session","expires_in","expires_at","signInWithEmail","signUpWithPhone","phone","signInWithPhone","signInWithOpenIDConnect","id_token","nonce","client_id","issuer","sendMagicLinkEmail","shouldCreateUser","create_user","sendMobileOTP","signOut","verifyMobileOTP","token","type","redirect_to","verifyOTP","inviteUserByEmail","resetPasswordForEmail","refreshAccessToken","refreshToken","refresh_token","setAuthCookie","end","event","access_token","deleteAuthCookie","redirect","getAuthCookieString","generateLink","createUser","attributes","user","listUsers","users","getUserById","uid","getUserByCookie","getUserError","getUser","updateUserById","deleteUser","updateUser","uint8","tmp","len","length","extraBytes","parts","i","len2","$eeb0961446aae8e3$var$encodeChunk","start","output","$eeb0961446aae8e3$var$lookup","num","$eeb0961446aae8e3$var$revLookup","$eeb0961446aae8e3$var$Arr","Uint8Array","$eeb0961446aae8e3$var$code","$eeb0961446aae8e3$var$i","$eeb0961446aae8e3$var$len","charCodeAt","buffer","offset","isLE","mLen","nBytes","m","eLen","eMax","eBias","nBits","d","NaN","pow","rt","abs","Infinity","log","LN2","$51861dfc7ca9d588$var$customInspectSymbol","Symbol","$51861dfc7ca9d588$var$createBuffer","RangeError","buf","setPrototypeOf","$51861dfc7ca9d588$var$Buffer","arg","encodingOrOffset","$51861dfc7ca9d588$var$allocUnsafe","$51861dfc7ca9d588$var$from","$51861dfc7ca9d588$var$fromString","string","encoding","isEncoding","$51861dfc7ca9d588$var$byteLength","actual","write","slice","ArrayBuffer","isView","$51861dfc7ca9d588$var$fromArrayView","arrayView","$51861dfc7ca9d588$var$isInstance","copy","$51861dfc7ca9d588$var$fromArrayBuffer","byteOffset","byteLength","$51861dfc7ca9d588$var$fromArrayLike","SharedArrayBuffer","valueOf","from","b","$51861dfc7ca9d588$var$fromObject","obj","isBuffer","$51861dfc7ca9d588$var$checked","undefined","$51861dfc7ca9d588$var$numberIsNaN","isArray","toPrimitive","$51861dfc7ca9d588$var$assertSize","size","array","mustMatch","arguments","loweredCase","$51861dfc7ca9d588$var$utf8ToBytes","$51861dfc7ca9d588$var$base64ToBytes","$51861dfc7ca9d588$var$slowToString","$51861dfc7ca9d588$var$hexSlice","out","$51861dfc7ca9d588$var$hexSliceLookupTable","$51861dfc7ca9d588$var$utf8Slice","$51861dfc7ca9d588$var$asciiSlice","ret","min","String","fromCharCode","$51861dfc7ca9d588$var$latin1Slice","$51861dfc7ca9d588$var$utf16leSlice","bytes","$51861dfc7ca9d588$var$swap","$51861dfc7ca9d588$var$bidirectionalIndexOf","dir","$51861dfc7ca9d588$var$arrayIndexOf","lastIndexOf","arr","indexSize","arrLength","valLength","read","readUInt16BE","foundIndex","found","j","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","codePoints","$51861dfc7ca9d588$var$checkOffset","ext","$51861dfc7ca9d588$var$checkInt","max","$51861dfc7ca9d588$var$wrtBigUInt64LE","$51861dfc7ca9d588$var$checkIntBI","lo","Number","BigInt","hi","$51861dfc7ca9d588$var$wrtBigUInt64BE","$51861dfc7ca9d588$var$checkIEEE754","$51861dfc7ca9d588$var$writeFloat","littleEndian","noAssert","$51861dfc7ca9d588$var$writeDouble","TYPED_ARRAY_SUPPORT","$51861dfc7ca9d588$var$typedArraySupport","proto","foo","console","poolSize","alloc","fill","allocUnsafe","allocUnsafeSlow","_isBuffer","compare","a","x","y","concat","list","pos","swap16","swap32","swap64","toString","toLocaleString","equals","inspect","trim","target","thisStart","thisEnd","thisCopy","targetCopy","includes","remaining","$51861dfc7ca9d588$var$hexWrite","strLen","parsed","parseInt","substr","$51861dfc7ca9d588$var$blitBuffer","$51861dfc7ca9d588$var$asciiToBytes","byteArray","$51861dfc7ca9d588$var$utf16leToBytes","units","toJSON","_arr","newBuf","subarray","readUintLE","readUIntLE","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","$51861dfc7ca9d588$var$defineBigIntMethod","$51861dfc7ca9d588$var$validateNumber","first","last","$51861dfc7ca9d588$var$boundsError","readBigUInt64BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","maxBytes","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","$51861dfc7ca9d588$var$errors","$51861dfc7ca9d588$var$E","sym","getMessage","Base","writable","stack","$51861dfc7ca9d588$var$addNumericalSeparator","range","ERR_OUT_OF_RANGE","ERR_INVALID_ARG_TYPE","ERR_BUFFER_OUT_OF_BOUNDS","input","received","isInteger","$51861dfc7ca9d588$var$INVALID_BASE64_RE","leadSurrogate","$eeb0961446aae8e3$export$d622b2ad8d90c771","b64","lens","$eeb0961446aae8e3$var$getLens","validLen","placeHoldersLen","curByte","$51861dfc7ca9d588$var$base64clean","src","dst","alphabet","table","i16","fn","$51861dfc7ca9d588$var$BufferBigIntNotDefined","$aa752bc178c144d4$var$__awaiter","__magic__","$aa752bc178c144d4$var$DEFAULT_OPTIONS","autoRefreshToken","persistSession","detectSessionInUrl","multiTab","$aa752bc178c144d4$var$decodeBase64URL","atob","ReferenceError","$aa752bc178c144d4$require$Buffer","$aa752bc178c144d4$export$2e2bcd8739ae039","stateChangeEmitters","Map","networkRetries","settings","currentUser","currentSession","localStorage","api","_recoverSession","_recoverAndRefresh","_listenForMultiTabEvents","_handleVisibilityChange","getSessionFromUrl","storeSession","signUp","_removeSession","_saveSession","_notifyAllSubscribers","signIn","oidc","_handleEmailSignIn","_handlePhoneSignIn","_callRefreshToken","_handleProviderSignIn","_handleOpenIDConnectSignIn","refreshSession","update","setSession","arg0","tokenParts","bodyJSON","exp","token_type","setAuth","provider_token","provider_refresh_token","recoveryMode","hash","accessToken","onAuthStateChange","callback","r","random","subscription","unsubscribe","delete","confirmed_at","email_confirmed_at","phone_confirmed_at","expiresAt","refreshTokenTimer","clearTimeout","setTimeout","forEach","_startAutoRefreshToken","_persistSession","unref","addEventListener","newSession","newValue","document","visibilityState","$b6000684d7c6c56c$export$8199a418bb09bd56","$3aaf6419364c17d6$var$__awaiter","$3aaf6419364c17d6$export$3106e21688a06353","builder","shouldThrowOnError","allowEmpty","throwOnError","onfulfilled","onrejected","schema","signal","_d","count","statusText","isReturnMinimal","text","countHeader","match","contentRange","_e","details","fetchError","hint","$a1803de8df26892f$export$2e2bcd8739ae039","select","columns","quoted","cleanedColumns","searchParams","order","column","ascending","nullsFirst","foreignTable","existingOrder","to","keyOffset","keyLimit","abortSignal","single","maybeSingle","csv","$7183990437551054$export$2e2bcd8739ae039","cs","contains","cd","containedBy","sl","rangeLt","sr","rangeGt","nxl","rangeGte","nxr","rangeLte","adj","rangeAdjacent","ov","overlaps","not","operator","append","or","filters","eq","neq","gt","gte","lt","lte","like","pattern","ilike","is","in","values","cleanedValues","textSearch","config","typePart","configPart","fts","plfts","phfts","wfts","filter","keys","$c0d502ff80704788$export$2e2bcd8739ae039","URL","head","insert","upsert","onConflict","returning","prefersHeaders","unshift","reduce","acc","uniqueColumns","Set","ignoreDuplicates","$025be36b8ad4e2ba$export$2e2bcd8739ae039","rpc","entries","$3212d5f3017e8dc3$export$88a84136db6a4b64","$83c92f94715fb663$export$2e2bcd8739ae039","auth","$3f01feefa94fd48b$exports","$3f01feefa94fd48b$export$20ce708a1f594c5e","$3f01feefa94fd48b$export$c054edfec1afa88d","$3f01feefa94fd48b$export$3df02a362b86a91","$3f01feefa94fd48b$export$45b10814cc054894","$3f01feefa94fd48b$export$3c2e6d1b7583eee6","$3f01feefa94fd48b$export$a0a81dc3380ce7d3","$3f01feefa94fd48b$export$d5b7a8bf56ee1fe2","$3f01feefa94fd48b$export$eccf8c5d91d19e3a","record","skipTypes","rec_key","columnName","find","colType","$3f01feefa94fd48b$var$noop","charAt","bool","float4","float8","int2","int4","int8","numeric","oid","jsonb","timestamp","abstime","date","daterange","int4range","int8range","money","reltime","time","timestamptz","timetz","tsrange","tstzrange","parsedValue","parseFloat","lastIdx","closeBrace","openBrace","valTrim","_","$b5dc48dc7c306f35$exports","$b5dc48dc7c306f35$var$NativeWebSocket","WebSocket","MozWebSocket","$5ac4442c13841201$exports","$b5dc48dc7c306f35$var$W3CWebSocket","uri","protocols","native_instance","version","prop","$3d531e63e1ea7f53$export$88a84136db6a4b64","TRANSPORTS","$505c2b2d07197e20$export$2e2bcd8739ae039","timerCalc","timer","tries","reset","scheduleTimeout","$6805f7080ae1d67f$export$2e2bcd8739ae039","HEADER_LENGTH","decode","rawPayload","_binaryDecode","view","DataView","decoder","TextDecoder","_decodeBroadcast","topicSize","getUint8","eventSize","topic","ref","payload","$9b541112b15eb31d$export$2e2bcd8739ae039","channel","timeout","sent","timeoutTimer","receivedResp","recHooks","refEvent","resend","_cancelRefEvent","send","_hasReceived","startTimeout","socket","join_ref","joinRef","updatePayload","receive","response","makeRef","replyEventName","on","_cancelTimeout","_matchReceive","trigger","destroy","off","h","$ce3c1d0e07dc916d$export$2e2bcd8739ae039","bindings","state","closed","joinedOnce","pushBuffer","joinPush","rejoinTimer","rejoinUntilConnected","reconnectAfterMs","joined","pushEvent","onClose","remove","onError","reason","isLeaving","isClosed","errored","isJoining","reply","isConnected","rejoin","subscribe","close","bind","canPush","isJoined","updateJoinPayload","leaving","leavePush","leave","onMessage","isMember","leaveOpenTopic","joining","events","handledPayload","isErrored","$ae049384a7d1c7c8$var$noop","$ae049384a7d1c7c8$export$2e2bcd8739ae039","endPoint","channels","transport","w3cwebsocket","heartbeatIntervalMs","longpollerTimeout","heartbeatTimer","pendingHeartbeatRef","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","websocket","encode","reconnectTimer","disconnect","connect","endPointURL","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","onConnMessage","onclose","_onConnClose","_reject","clearInterval","kind","onOpen","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","chanParams","chan","rawMessage","_appendParams","vsn","newRef","user_token","dupChannel","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","prefix","$4f581467803a2661$export$a1c0cbe03b169679","tableName","userToken","getPayloadRecords","records","new","old","convertChangeData","old_record","enrichedPayload","commit_timestamp","eventType","errors","$eabf44873eaa7c75$export$d6b56fa12d975d17","realtime","_subscription","_realtime","_headers","_schema","_table","$f4c4e1deae4025ef$export$88a84136db6a4b64","$2ad35efa1b333042$var$__awaiter","$2ad35efa1b333042$var$_getErrorMessage","$2ad35efa1b333042$var$handleError","$2ad35efa1b333042$var$_getRequestParams","parameters","$2ad35efa1b333042$var$_handleRequest","$2ad35efa1b333042$export$3988ae62b71be9a3","$2ad35efa1b333042$export$299ba2dee77727e9","$2ad35efa1b333042$export$cd7f480d6b8286c3","$b8abd4fb4763e533$export$98d92b1aa79f8cc7","$68d30606960d068a$var$__awaiter","$68d30606960d068a$export$698875e798f36d2d","listBuckets","getBucket","createBucket","public","updateBucket","emptyBucket","deleteBucket","$6c2c44af3462c2fe$var$__awaiter","$6c2c44af3462c2fe$var$DEFAULT_SEARCH_OPTIONS","sortBy","$6c2c44af3462c2fe$var$DEFAULT_FILE_OPTIONS","cacheControl","contentType","$6c2c44af3462c2fe$export$f62f1779c09b9522","bucketId","uploadOrUpdate","fileBody","fileOptions","Blob","FormData","cleanPath","_removeEmptyFolders","_path","_getFinalPath","Key","upload","move","fromPath","toPath","sourceKey","destinationKey","createSignedUrl","signedURL","createSignedUrls","paths","datum","download","blob","getPublicUrl","publicURL","prefixes","$3ac213f23af4773a$export$6c85f5032e75eff9","$b1b44af3c77a62f9$export$98d92b1aa79f8cc7","$a976488f0e157f77$export$1d0b400bf8a0fa55","Authorization","invoke","functionName","invokeOptions","isRelayError","responseType","arrayBuffer","$adb6551412d48394$var$__awaiter","$adb6551412d48394$var$DEFAULT_OPTIONS","$87b5c749fa3f6a4f$export$a0b632a28672d3c0","$adb6551412d48394$export$2e2bcd8739ae039","supabaseUrl","supabaseKey","_supabaseUrl","restUrl","realtimeUrl","authUrl","storageUrl","urlParts","functionsUrl","_initSupabaseAuthClient","_initRealtimeClient","_listenForAuthEvents","functions","_getAuthHeaders","rest","_initPostgRESTClient","removeAllSubscriptions","allSubs","getSubscriptions","allSubPromises","removeSubscription","allRemovedSubs","all","_closeSubscription","openSubCount","openSubscriptions","unsubError","_unsubscribeSubscription","authHeaders","apikey","authBearer","previousAccessToken","_handleTokenChanged","source","changedAccessToken","$9d4f270d4dd0dae2$export$fc3b441efa2df883","title","category","userId","imageUrl","user_id","thumbnail_url","success","$9d4f270d4dd0dae2$export$71a7b09aee976d34","$9d4f270d4dd0dae2$export$3a99609c3dc7bce9","$e38d38144a63340f$export$41b3415e6330f1b5","apiUrl","image","getSession","urlForm","getElementById","urlList","thumbnailPreview","loadUrls","innerHTML","urls","fragment","createDocumentFragment","li","createElement","style","display","alignItems","gap","margin","img","width","height","alt","objectFit","link","innerText","flex","fontWeight","fontSize","color","textDecoration","btnDelete","classList","add","onclick","confirm","alert","appendChild","preventDefault","urlInput","titleInput","categoryInput"],"version":3,"file":"public.ce29b3c6.js.map"}